<html><head><script src='https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.js'></script><script src='https://cdnjs.cloudflare.com/ajax/libs/three.js/r79/three.min.js'></script><title>ivanGreatForest205</title></head><body><div id='canvasDiv' onclick='this.requestFullscreen();'  style='position: absolute; text-align: center; width: 800; height: 600'><canvas id='threeCanvas' style='position: absolute; display: block; margin: auto; width: 100%; height: 100%; top: 0; left: 0; z-index:40;' onclick=''></canvas><canvas id='gameCanvas' style='position: absolute; top: 0; left: 0; z-index:60; width: 100%; height: 100%; display: block; margin: auto' onclick=''></canvas></div><script type="text/javascript">
function cursorOverlap(x1, y1, h, w, x2, y2) { let r = x1 + w; let b = y1 + h; if (x2 >= x1 && x2 <= r) {if (y2 >= y1 && y2 <= b) { return true; } } return false; }var mouseCursor = {X:-150,Y:-350};
var prevX = 0;
var prevY = 0;
document.onmousemove = function(e) { if (keyval('h')==true) { prevX = 0; prevY = 0; } else { mouseCursor.X -= (prevX - e.pageX); mouseCursor.Y -= (prevY - e.pageY); prevX = e.pageX; prevY = e.pageY; drawString(mouseCursor.X, mouseCursor.Y, '+', '#FFF', 12); } };
function gameClick() { if (keyval('leftclick')==true) { for(var i in game.active().MyDashboard.MyBars) { let label = game.active().MyDashboard.MyBars[i]; if (cursorOverlap(label.X, label.Y, label.H, label.calculateWidth(), mouseCursor.X, mouseCursor.Y) == true) { label.submit(); } } } refreshClicks(); }
function refreshClicks() { keydown[1] = false; keydown[2] = false; keydown[3] = false; }

/* begin RDS HTMLCoreLoop for canvas */

/* basic supporting infrastructure */

/* Game loop itself */

THREE.Cache.enabled = true;
var FPS = 30;
var activeMidi = {};
function find(array, name) { return array.find(function(arr) { return arr.Name === name; }); }
function checkOverlap(one, two) { return (one.X + one.W > two.X && one.X < two.X + two.W) && (one.Y + one.H > two.Y && one.Y < two.Y + two.H); }
function resize2D(x,y) { if (y !== null && y > 0) { h2d=y; } if (x !== null && x > 0) { w2d=x; } }
function getXDrawBounds2D() { return 1600 * w2d; }
function getYDrawBounds2D() { return 1000 * h2d; }
function viewportCenterX() { return getXDrawBounds2D() / 2; }
function viewportCenterY() { return getYDrawBounds2D() / 2; }
var blockInput = false;
function BlockInput() { blockInput = true; }function wouldCollide(one, two) { return (one.X + one.W > two.X && one.X < two.X + two.W && one.Y + one.H > two.Y && one.Y < two.Y + two.H); }function downkey() { return keyval('down'); }
function upkey() { return keyval('up'); }
function leftkey() { return keyval('left'); }
function rightkey() { return keyval('right'); }
var keydown = { }; 
window.onkeyup = function(e) { keydown[e.keyCode] = false; }
window.onkeydown = function(e) { keydown[e.keyCode] = true; }
window.onclick = function(e) { keydown[e.which] = true; }
function keyval(input) {
 if (blockInput === true) { return false; }
if (keydown[lookup(input)] === true) {
return true;
}
}
function lookup(input) {
if (input === 'leftclick') { return 1; }
if (input === 'middleclick') { return 2; }
if (input === 'rightclick') { return 3; }
if (input === 'tab') { return 9; }
if (input === 'enter') { return 13; }
if (input === 'escape') { return 27; }
if (input === 'space') { return 32; }
if (input === 'left') { return 37; }
if (input === 'up') { return 38; }
if (input === 'right') { return 39; }
if (input === 'down') { return 40; }
if (input === '0') { return 48; }
if (input === '1') { return 49; }
if (input === '2') { return 50; }
if (input === '3') { return 51; }
if (input === '4') { return 52; }
if (input === '5') { return 53; }
if (input === '6') { return 54; }
if (input === '7') { return 55; }
if (input === '8') { return 56; }
if (input === '9') { return 57; }
if (input === 'a') { return 65; }
if (input === 'b') { return 66; }
if (input === 'c') { return 67; }
if (input === 'd') { return 68; }
if (input === 'e') { return 69; }
if (input === 'f') { return 70; }
if (input === 'g') { return 71; }
if (input === 'h') { return 72; }
if (input === 'i') { return 73; }
if (input === 'j') { return 74; }
if (input === 'k') { return 75; }
if (input === 'l') { return 76; }
if (input === 'm') { return 77; }
if (input === 'n') { return 78; }
if (input === 'o') { return 79; }
if (input === 'p') { return 80; }
if (input === 'q') { return 81; }
if (input === 'r') { return 82; }
if (input === 's') { return 83; }
if (input === 't') { return 84; }
if (input === 'u') { return 85; }
if (input === 'v') { return 86; }
if (input === 'w') { return 87; }
if (input === 'x') { return 88; }
if (input === 'y') { return 89; }
if (input === 'z') { return 90; }
}
var w2d = 0.8;
var h2d = 0.8;
var w3d = 1;
var h3d = 0.8;
var w2dd = 1;
var h2dd = 1;
var clearRect = true;
function askStartGame() { if(confirm('Are you sure you want to start the game?')) { startGame(); } }
function startGame() {
runMainSetup();
setInterval(function () 
{
resize2D(game.active().XResolution2D, game.active().YResolution2D);
gameClick();
draw();
update();
blockInput = false;
}, 1000 / FPS);
}
function draw() {
reallignCanvases();
document.getElementById('threeCanvas').width = window.innerWidth * w3d;
document.getElementById('gameCanvas').width = window.innerWidth * w2d;
document.getElementById('threeCanvas').height = window.innerHeight * h3d;
document.getElementById('gameCanvas').height = window.innerHeight * h2d;
if (clearRect === true) { var can = getCanvas(); can.clearRect(0,0,window.innerWidth*w2dd,window.innerHeight*h2dd); /*drawRectangle(0,0,window.innerWidth*w2dd,window.innerHeight*h2dd,'#007');*/ }
game.draw();
}
function update() {
if (keyval('0')) { document.getElementById('canvasDiv').requestFullscreen(); }
if (typeof serverSync === 'function') { serverSync(game); }game.update();
}
var cwg = null;/*game.Classes;*/
/* end RDS HTMLCoreLoop for canvas */
var game = {"hasChangeStack":
 function() { return (typeof localChangeStack != 'undefined' && localChangeStack instanceof Array); }
,"loadDash":
 function(nameOf) { for(var i in this.DataLibrary.DataViews) {if (this.DataLibrary.DataViews[i].Name==nameOf) {game.active().loadedDash = this.DataLibrary.DataViews[i].asDashboard();}}}
,"isObjectEmpty":
 function(obj) { return (Object.keys(obj).length === 0 && obj.constructor === Object); }
,"save":
 function() {game.EventBoard.saveGame();}
,"scene":
 function() {return this.active().active();}
,"renderMessage":
 function(msg) {drawRectangle(128, 384, 544, 192, '#777'); drawString(160, 416, msg, '#FFF');}
,"message":
 function(msg) {this.messages.push({MSG:msg, update: function() { game.renderMessage(this.MSG); } } );}
,"fadingMessage":
 function(msg,dur) {this.fadingMessages.push({MSG:msg,Duration:dur,ct:0,render:function() { drawRectangle(128, 384, 544, 192, '#777'); drawString(160, 416, this.MSG, '#FFF'); },update:function() { if (this.ct < this.Duration) { this.ct++; this.render(); } else { game.fadingMessages.splice(0, 1); game.unpause(); } }})}
,"interruptMessage":
 function(msg,dur) {this.fadingMessage(msg, dur); this.pause();}
,"getConfirmation":
 function(msg,runWith) {this.confirmations.push({MSG:msg,entry:0,OnEntry:runWith}); this.pause();}
,"dispelMessage":
 function(msg) {this.message(msg); this.pause();}
,"active":
 function() { return this.SceneContexts[this.Target]; }
,"setup":
function() { this.AOPEngine.setup(); for(var i in this.SceneContexts) { this.SceneContexts[i].setup(); }  }
,"findEntity":
function(entName) { return find(this.scene().allEntities(), entName); }
,"findThrentity":
function(threntName) { return find(this.scene().Threntities, threntName); }
,"update":
function() {if (this.shouldUpdate) {this.SceneContexts[this.Target].update(); }this.updateFadingMessages();this.updateConfirmations();this.updateMessages();}
,"updateConfirmations":
 function() {if (this.confirmations.length > 0) { game.renderMessage(this.confirmations[0].MSG);  if (this.confirmations[0].entry == 0) { drawRectangle(248,456,40,32,'#BBB'); } else { drawRectangle(536,456,40,32,'#BBB'); } if (game.active().isNewPress('left')) { this.confirmations[0].entry = 0; } else if (game.active().isNewPress('right')) { this.confirmations[0].entry = 1; } if (game.active().isNewPress('s')) { this.unpause(); this.confirmations[0].OnEntry(this.confirmations[0].entry); this.confirmations.splice(0, 1); } drawString(256, 480, 'Yes','#FFF'); drawString(544,480,'No','#FFF'); }}
,"updateMessages":
 function() {if (this.messages.length > 0) { this.messages[0].update(); } if (keydown.enter || keydown.space) { this.messages.splice(0,1); this.unpause(); }}
,"updateFadingMessages":
 function() {if (this.fadingMessages.length > 0) { this.fadingMessages[0].update(); }}
,"confirmations":
[]
,"fadingMessages":
[]
,"messages":
[]
,"draw":
function() {/*drawString(64, 64, this.Name, '#FFF');*/this.SceneContexts[this.Target].draw();}
,"pause":
 function() {this.shouldUpdate = false;}
,"unpause":
 function() {this.shouldUpdate = true;}
,"shouldUpdate":
true
,"Description":"","GameData":"","Target":0,"ServerId":null,"SceneContexts":[{"active":
function() {return this.Scenes[this.Target];}
,"setScene":
 function(index) {for( var i = scene.children.length - 1; i >= 0; i--) { var toClear = scene.children[i]; scene.remove(toClear); } this.Target = index; if (!this.active().isSetup || this.active().isSetup) { this.active().setup(); } this.active().reloadThrentities(); /*this.active().loadScene();*/}
,"setup":
 function() { this.MyDashboard.initialize();this.active().setup();}
,"update":
function() { this.Scenes[this.Target].update();this.MyLogic.update();for(var i in this.SceneGrids) { this.SceneGrids[i].update(this.SceneGrids[i].TargetEntity); }for(var i in this.SceneCubes) { this.SceneCubes[i].update(this.SceneCubes[i].TargetEntity); }for(var i in this.KeyHandlers) { this.KeyHandlers[i].update(); } }
,"isNewPress":
 function(key) {for(var i in this.KeyHandlers) { if (this.KeyHandlers[i].KeyName == key) { return this.KeyHandlers[i].isNewPress(); } } return false;}
,"draw":
function() { this.Scenes[this.Target].draw();this.activeDash().draw();}
,"resetDash":
function() { this.loadedDash = {}; }
,"loadedDash":
{}
,"hasLoadedDash":
function() { return game.isObjectEmpty(this.loadedDash) != true; }
,"activeDash":
 function() { if (this.hasLoadedDash() == true) {return this.loadedDash;}else { return this.MyDashboard; }}
,"Target":0,"Scenes":[{"reloadThrentities":
function() { var allT = this.allThrentities(); for(var i in allT) { setupThrentity(allT[i]); } }
,"setup":
 function() {if (this.isSetup !== true) {for(var i in this.TileGrids) { this.TileGrids[i].setup(this); } for(var i in this.PointLights) { this.PointLights[i].setup(this); } if (this.MyAudio !== null) { for (var i = 0; i < this.MyAudio.length; i++) { this.MyAudio[i].setup(); } }if (game.active().Omnipresent2D.length > 0) { var indices = this.entityIndexArray(); var allE = this.allEntities();  for(var i in allE) { if (allE[i].MyIndex != '') { var ind = indices.indexOf(allE[i].MyIndex); if(ind != -1) { indices.splice(ind, 1); } } else { allE[i].setup(indices[i]); } }  } else { for(var i in this.Entities) { this.Entities[i].setup(i); } }if (game.active().Omnipresent3D.length > 0) { var indices = this.threntityIndexArray(); var allT = this.allThrentities(); for(var i in allT) { if (allT[i].MyIndex != '') { var ind = indices.indexOf(allT[i].MyIndex); if (ind != -1) { indices.splice(ind, 1); } } else { allT[i].setup(indices[i]); } }  } else { for(var i in this.Threntities) { this.Threntities[i].setup(i); } }if (this.HasAmbientLight == true) { addAmbientLightToCurrentScene(this.AmbientLightColor, this.AmbientLightIntensity / parseFloat(100)); }this.isSetup = true; }}
,"update":
 function() {this.MyLogic.update();for(var i in this.MyAudio) { this.MyAudio[i].update(); } var allE = this.allEntities(); for(var i in allE) { allE[i].update(); }var allT = this.allThrentities(); for(var i in allT) { allT[i].update(); }for(var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].update(this.AdhocSceneRefs[i].TargetName); } for(var i in this.TileGrids) { this.TileGrids[i].update(); } }
,"draw":
 function() {for(var i in this.TileGrids) { this.TileGrids[i].draw(); } var allE = this.allEntities(); for(var i in allE) { if (allE[i].Disabled !== true) { allE[i].draw(); } }var allT = this.allThrentities(); for(var i in allT) { allT[i].draw(); } }
,"entityIndexArray":
function() { var ray = []; for(var x in game.active().Omnipresent2D) { ray.push(game.active().Omnipresent2D[x].MyIndex); } var rayLen = ray.length; for(i=0;i<rayLen+this.Entities.length;i++) { if (ray.includes((i).toString())) {  } else {  ray.push(i); } } return ray; }
,"threntityIndexArray":
function() { var ray = []; for(var x in game.active().Omnipresent3D) { ray.push(game.active().Omnipresent3D[x].MyIndex); } var rayLen = ray.length; for(i=0;i<rayLen+this.Threntities.length;i++) { if (ray.includes((i).toString())) {  } else {  ray.push(i); } } return ray; }
,"checkMovePoint3d":
function(point3dBefore, point3dAfter) {  var all = this.allThrentities(); for(var i in all) { if (this.checkPointCollision(all[i], point3dBefore, point3dAfter)==true) { return false; } } return true;  }
,"checkPointCollision":
function(targetThrent, point3dBefore, point3dAfter) { var xBef = point3dBefore.X;var xAft = point3dAfter.X;var yBef = point3dBefore.Y;var yAft = point3dAfter.Y;var zBef = point3dBefore.Z;var zAft = point3dAfter.Z;var minX = targetThrent.L();var maxX = targetThrent.R();var minY = targetThrent.B();var maxY = targetThrent.T();var minZ = targetThrent.A();var maxZ = targetThrent.F();var xOverlap = false; var yOverlap = false; var zOverlap = false;if (xBef<xAft) { xOverlap = this.checkRangeOverlap(xBef, xAft, minX, maxX); } else { xOverlap = this.checkRangeOverlap(xAft, xBef, minX, maxX); }if (yBef<yAft) { yOverlap = this.checkRangeOverlap(yBef, yAft, minY, maxY); } else { yOverlap = this.checkRangeOverlap(yAft, yBef, minY, maxY); }if (zBef<zAft) { zOverlap = this.checkRangeOverlap(zBef, zAft, minZ, maxZ); } else { zOverlap = this.checkRangeOverlap(zAft, zBef, minZ, maxZ); }if (xOverlap==true && yOverlap==true && zOverlap==true) { return true; } return false;}
,"checkRangeOverlap":
function (inputOneMin, inputOneMax, inputTwoMin, inputTwoMax) {if (inputOneMin > inputTwoMax || inputOneMax < inputTwoMin) { return false; }return true;}
,"threnCollideContextual":
function(thren, before, after) { var hasCollide = false;var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name) { if (this.ZStraddle(before, after, all[i])===true && this.XStraddle(before, after, all[i])===true && this.YStraddle(before, after, all[i])===true) { hasCollide = true; } if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { hasCollide = true; } } }return hasCollide;}
,"ZStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.Z - before.Z;let secondDiff = target.Z - after.Z;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"XStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.X - before.X;let secondDiff = target.X - after.Y;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"YStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.Y - before.Y;let secondDiff = target.Y - after.Y;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"getFirstThrenCollide":
function(thren) { var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { return thren; } } }
,"threnCollide":
 function(thren) {var hasCollide = false;var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { hasCollide = true; } }return hasCollide;}
,"moveAll2D":
function(x, y) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } for (var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].X += x; this.AdhocSceneRefs[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } }
,"moveAll2DAround":
function(x, y, entName) { var ent = find(game.scene().Entities, entName); if (this.wouldCollide(ent.transpose(-x, -y)) === false) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } } }
,"quickMoveAll2DAround":
function(x, y, ent) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } for(var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].X += x; this.AdhocSceneRefs[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } }
,"tryMoveAll2DAround":
function(x, y, entName) {if (this.getMainTilegrid() === -1) { return this.moveAll2DAround(x, y, entName); } else { this.dynamic2DMove(x, y, entName, this.getMainTilegrid()); } }
,"dynamic2DMove":
function(x, y, entName, tileGrid) {var ent = game.findEntity(entName);if (this.wouldCollide(ent.transpose(-x, -y)) === false) {this.dynamic2DMoveX(x, ent, tileGrid);this.dynamic2DMoveY(y, ent, tileGrid); }}
,"dynamic2DMoveUp":
function(y, ent, tileGrid) {var amtMoveHeroTowardsCenter = (ent.pastCenterY() === false && ent.isCenteredY() === false) ? 0 : (ent.myCenterY() - viewportCenterY());if (amtMoveHeroTowardsCenter >= y) { ent.Y -= y; return; } else { ent.Y -= amtMoveHeroTowardsCenter; }var remainder = y - amtMoveHeroTowardsCenter;var tileGridSlack = 0 - tileGrid.Y;if (remainder <= Math.abs(tileGridSlack)) { this.quickMoveAll2DAround(0, remainder, ent); return; } else { this.quickMoveAll2DAround(0, Math.abs(tileGridSlack), ent); }remainder = remainder - Math.abs(tileGridSlack);ent.Y -= remainder;}
,"dynamic2DMoveDown":
function(y, ent, tileGrid) {var absY = Math.abs(y);var amtMoveHeroTowardsCenter = (ent.isCenteredY() || ent.pastCenterY()) ? 0 : viewportCenterY() - ent.myCenterY();if (amtMoveHeroTowardsCenter >= absY) { ent.Y -= y; return; } else { ent.Y += amtMoveHeroTowardsCenter; }var remainder = absY - amtMoveHeroTowardsCenter;var tileGridSlack = tileGrid.B() - getYDrawBounds2D();if (remainder <= tileGridSlack) { this.quickMoveAll2DAround(0, -remainder, ent); return; } else { this.quickMoveAll2DAround(0, tileGridSlack, ent); }remainder = remainder - tileGridSlack;ent.Y += remainder;}
,"dynamic2DMoveLeft":
function(x, ent, tileGrid) {var amtMoveHeroTowardsCenter = (ent.pastCenterX() === false && ent.isCenteredX() === false) ? 0 : (ent.myCenterX() - viewportCenterX());if (amtMoveHeroTowardsCenter >= x) { ent.X -= x; return; } else { ent.X -= amtMoveHeroTowardsCenter; }var remainder = x - amtMoveHeroTowardsCenter;var tileGridSlack = 0 - tileGrid.X;if (remainder <= Math.abs(tileGridSlack)) { this.quickMoveAll2DAround(remainder, 0, ent); return; } else { this.quickMoveAll2DAround(Math.abs(tileGridSlack), 0, ent); }remainder = remainder - Math.abs(tileGridSlack);ent.X -= remainder;}
,"dynamic2DMoveRight":
function(x, ent, tileGrid) {var absX = Math.abs(x);var amtMoveHeroTowardsCenter = (ent.isCenteredX() || ent.pastCenterX()) ? 0 : viewportCenterX() - ent.myCenterX();if (amtMoveHeroTowardsCenter >= absX) { ent.X -= x; return; } else { ent.X += amtMoveHeroTowardsCenter; }var remainder = absX - amtMoveHeroTowardsCenter;var tileGridSlack = tileGrid.R() - getXDrawBounds2D();if (remainder <= tileGridSlack) { this.quickMoveAll2DAround(-remainder, 0, ent); return; } else { this.quickMoveAll2DAround(tileGridSlack, 0, ent); }remainder = remainder - tileGridSlack;ent.X += remainder;}
,"dynamic2DMoveX":
function(x, ent, tileGrid) { var movingLeft = x > 0;if (movingLeft) { this.dynamic2DMoveLeft(x, ent, tileGrid); return; } else { this.dynamic2DMoveRight(x, ent, tileGrid); return; }var tileGridSlackX = x < 0 ? -1 * tileGrid.X : tileGrid.R() - getXDrawBounds2D(); if (ent.isCenteredX() !== true) { var centerSlackX = (x < 0 ? ((getXDrawBounds2D() / 2) - ent.X) : ent.X - (getXDrawBounds2D() / 2)); if (centerSlackX > Math.abs(x)) { ent.X -= x; }else if (centerSlackX < Math.abs(x) && centerSlackX > 0) { ent.X -= centerSlackX; }  }else if (tileGridSlackX > Math.abs(x)) { this.moveAll2DAround(x, 0, ent.Name); }else if (tileGridSlackX < Math.abs(x) && tileGridSlackX > 0) { this.moveAll2DAround(tileGridSlackX, 0, ent.Name); }}
,"dynamic2DMoveY":
function(y, ent, tileGrid) { var movingUp = y > 0;if (movingUp) { this.dynamic2DMoveUp(y, ent, tileGrid); return; } else { this.dynamic2DMoveDown(y, ent, tileGrid); return; }var tileGridSlackY = y < 0 ? -1 * tileGrid.Y : tileGrid.B() - getYDrawBounds2D();if (ent.isCenteredY() !== true) { var centerSlackY = (y < 0 ? ((getYDrawBounds2D() / 2) - ent.Y) : ent.Y - (getYDrawBounds2D() / 2)); if (centerSlackY > Math.abs(y)) { ent.Y -= y; }else if (centerSlackY < Math.abs(y) && centerSlackY > 0) { ent.Y -= centerSlackY; }  }else if (tileGridSlackY > Math.abs(y)) { this.moveAll2DAround(y, 0, ent.Name); }else if (tileGridSlackY < Math.abs(y) && tileGridSlackY > 0) { this.moveAll2DAround(tileGridSlackY, 0, ent.Name); }}
,"prepareForRenderer":
 function() {return {  };}
,"loadScene":
function() { loadThrentitiesIntoNewScene(this.allThrentities(), this.PointLights); }
,"allThrentities":
function() { return game.active().Omnipresent3D.concat(this.validLocalThrentities()); }
,"validLocalThrentities":
function() { return this.Threntities.filter(function(obj) { return Object.keys(obj).length > 0; }); }
,"getThrentity":
function (index) { var ent = game.active().getOmni3D(index); if (ent != null) { return ent; } var obj = this.Threntities[index]; if (obj == null || Object.keys(obj).length == 0) { return game.active().getOmni3D(index); } else { return this.Threntities[index]; } }
,"allEntities":
function() { return game.active().Omnipresent2D.concat(this.validLocalEntities()); }
,"validLocalEntities":
function() { return this.Entities.filter(function(obj) { return Object.keys(obj).length > 0; }); }
,"getEntity":
function (index) { var ent = game.active().getOmni2D(index); if (ent != null) { return ent; } var obj = this.Entities[index]; if (obj == null || Object.keys(obj).length == 0) { return game.active().getOmni2D(index); } else { return this.Entities[index]; } }
,"getMainTilegrid":
function() { for(var i in this.TileGrids) { if (this.TileGrids[i].MainGrid === true) { return this.TileGrids[i]; } } return -1; }
,"shiftToTop":
function() {  var main = this.getMainTilegrid(); if (main !== -1) { var moveY = main.Y; this.moveAll2D(0, moveY); return moveY; } }
,"shiftToBottom":
function() {  var main = this.getMainTilegrid(); if (main !== -1) { var moveY = -(main.B() - getYDrawBounds2D()); this.moveAll2D(0, moveY); return moveY; } }
,"shiftToRight":
function() { if (this.shiftedToRight == true) {  }  var main = this.getMainTilegrid(); if (main !== -1) {  var moveX = -(main.R() - getXDrawBounds2D()); this.moveAll2D(moveX, 0); this.shiftedToLeft = false; this.shiftedToRight = true; return moveX; } }
,"shiftToLeft":
function() { if (this.shiftedToLeft == true) {  } var main = this.getMainTilegrid(); if (main !== -1) {  var moveX = main.X; this.moveAll2D(moveX, 0);  this.shiftedToLeft = true; this.shiftedToRight = false; return moveX; } }
,"shiftedToLeft":
false
,"shiftedToRight":
false
,"shiftedToTop":
false
,"shiftedToBottom":
false
,"wouldCollide":
 function(entity) {var hasCollide = false;for (var i in this.TileGrids) { if (this.TileGrids[i].wouldCollide(entity) === true) { hasCollide = true; } }var all = this.allEntities(); for (var i in all) { if (all[i].NotWorldLevel !== true && all[i].NonCorporeal !== true && all[i].Disabled !== true && all[i].Name !== entity.name && all[i].wouldCollide(entity)) { hasCollide = true; } }return hasCollide;}
,"isSetup":
false
,"XResolution":640,"YResolution":400,"HasAmbientLight":false,"AmbientLightIntensity":75,"AmbientLightColor":"0xffffcf","Bounds2DX":0,"Bounds2DY":0,"TileGrids":[{"setup":
function(parent) { if (this.DelimitedGrid && this.DelimitedGrid.length > 0){ var rows = this.DelimitedGrid.split(';');for (var j in rows) { this.tiles.push([]); var cells = rows[j].split(',');  for (var i in cells) { var tile=this.getTile(parent, cells[i]); this.tiles[j].push(tile); } } } }
,"getTile":
function(parentScene, tileId) {  var eName = this.EntityNameCSVKey.split(',')[tileId]; var tile = find(parentScene.allEntities(), eName); /* tile.draw = function(x,y,w,h) { this.MyImage.active().render(x,y,w,h); }; */ return tile;  }
,"draw":
function() { if (this.SkipDraw==true) { return; } for(var j in this.tiles) { for(var i in this.tiles[j]) { if (this.tiles[j][i] != null && this.tiles[j][i].MyImage != null) { this.tiles[j][i].MyImage.active().render(this.X + (i * this.TW),this.Y + (j * this.TH),this.TW,this.TH); } } } }
,"update":
 function() {}
,"tiles":
 [] 
,"R":
 function() {return this.X + (this.getWidth() * this.TW);}
,"B":
 function() {return this.Y + (this.getHeight() * this.TH);}
,"wouldCollide":
 function(entity) {for(var j in this.tiles)      {       for (var i in this.tiles[j])       {        if (this.tiles[j][i] != null && this.tiles[j][i].ForceCollision===true)        {         var x = this.X + (i * this.TW);         var y = this.Y + (j * this.TH);         if (checkOverlap({X:x,Y:y,W:this.TW,H:this.TH}, entity) === true)         {          console.log('overlap found');         var events = this.tiles[j][i].collisionEvents;         if (events !== null)         {         }         if (this.tiles[j][i].LedgeCollision === true)         {          if (/*notideal*/downkey() && !leftkey() && !rightkey())          {           console.log('ledge collision detected');           /*arbitrary*/var speed = 4;           /* make entity.MyLogic have a non null ActionBlock? */           entity.Me.MyLogic.ActionBlock.MyActions.push({Depth:((this.TH/speed)*2)+1,SelfDestruct:true,Ct:0,Destroyed:false,update:function() { console.log('updating action');  if (this.BlockInput === true) { BlockInput(); } if (this.SelfDestruct === true && this.Ct + 1 == this.Depth) { this.Destroyed = true; } if (this.Destroyed !== true) { this.MyScript(); this.Ct++; } },MyTarget:entity,BlockInput:true,LocalData:speed,MyScript:function() { console.log('performing action...'); this.MyTarget.Me.Y += this.LocalData; }});          }         }         return true;         }        }       }      }       return false;}
,"getWidth":
function() { if (this.getHeight() > 0) { return this.tiles[0].length; } else { return 0; } }
,"getHeight":
function() { return this.tiles.length; }
,"EntityIndexCSVKey":"","EntityNameCSVKey":"tile1,tile2,tile3,tile4,tile5","DelimitedGrid":"0,0,4,4,0,0,3,3,0,0,0,0,0,0,0,0,3,3,0,0,4,4,0,0;0,0,4,4,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,4,4,0,0;0,0,4,4,0,0,3,3,0,0,0,0,0,0,0,0,3,3,0,0,4,4,0,0;0,0,4,4,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,4,4,0,0;0,0,4,4,0,0,3,3,0,0,0,0,0,0,0,0,3,3,0,0,4,4,0,0;0,0,4,4,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,4,4,0,0;0,0,4,4,0,0,3,3,0,0,0,0,0,0,0,0,3,3,0,0,4,4,0,0;0,0,4,4,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,4,4,0,0;0,0,4,4,0,0,3,3,0,0,0,0,0,0,0,0,3,3,0,0,4,4,0,0;0,0,4,4,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,4,4,0,0;0,0,4,4,0,0,3,3,0,0,0,0,0,0,0,0,3,3,0,0,4,4,0,0;0,0,4,4,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,4,4,0,0;0,0,4,4,0,0,3,3,0,0,0,0,0,0,0,0,3,3,0,0,4,4,0,0;0,0,4,4,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,4,4,0,0;0,0,4,4,0,0,3,3,0,0,0,0,0,0,0,0,3,3,0,0,4,4,0,0;0,0,4,4,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,4,4,0,0;0,0,4,4,0,0,3,3,0,0,0,0,0,0,0,0,3,3,0,0,4,4,0,0;0,0,4,4,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,4,4,0,0;0,0,4,4,0,0,3,3,0,0,0,0,0,0,0,0,3,3,0,0,4,4,0,0;0,0,4,4,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,4,4,0,0;0,0,4,4,0,0,3,3,0,0,0,0,0,0,0,0,3,3,0,0,4,4,0,0;0,0,4,4,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,4,4,0,0;0,0,4,4,0,0,3,3,0,0,0,0,0,0,0,0,3,3,0,0,4,4,0,0;0,0,4,4,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,4,4,0,0","SkipDraw":false,"MainGrid":true,"TW":32,"TH":32,"X":0,"Y":0,"Name":"","LocalData":"","TypeName":"TileGrid","Id":299}],"AdhocSceneRefs":[],"Entities":[{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2166}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2160},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2160},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return true;}
,"imageFilePath":"grass32.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'grass32');}
,"NameOfTarget":"grass32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5933}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2160},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile1","LocalData":"","TypeName":"Entity","Id":2160},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2167}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2161},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2161},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return true;}
,"imageFilePath":"stone32.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'stone32');}
,"NameOfTarget":"stone32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5934}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2161},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile2","LocalData":"","TypeName":"Entity","Id":2161},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2168}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2162},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2162},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":8,"ImageFrames":[{"hasImagePath":
 function() {return true;}
,"imageFilePath":"water1.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water1');}
,"NameOfTarget":"water1","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5935},{"hasImagePath":
 function() {return true;}
,"imageFilePath":"water2.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water2');}
,"NameOfTarget":"water2","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5936},{"hasImagePath":
 function() {return true;}
,"imageFilePath":"water3.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water3');}
,"NameOfTarget":"water3","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5937},{"hasImagePath":
 function() {return true;}
,"imageFilePath":"water4.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water4');}
,"NameOfTarget":"water4","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5938},{"hasImagePath":
 function() {return true;}
,"imageFilePath":"water5.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water5');}
,"NameOfTarget":"water5","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5939},{"hasImagePath":
 function() {return true;}
,"imageFilePath":"water6.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water6');}
,"NameOfTarget":"water6","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5940},{"hasImagePath":
 function() {return true;}
,"imageFilePath":"water7.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water7');}
,"NameOfTarget":"water7","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5941},{"hasImagePath":
 function() {return true;}
,"imageFilePath":"water8.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water8');}
,"NameOfTarget":"water8","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5942},{"hasImagePath":
 function() {return true;}
,"imageFilePath":"water9.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water9');}
,"NameOfTarget":"water9","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5943},{"hasImagePath":
 function() {return true;}
,"imageFilePath":"water10.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water10');}
,"NameOfTarget":"water10","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5944},{"hasImagePath":
 function() {return true;}
,"imageFilePath":"water11.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water11');}
,"NameOfTarget":"water11","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5945},{"hasImagePath":
 function() {return true;}
,"imageFilePath":"water12.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water12');}
,"NameOfTarget":"water12","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5946},{"hasImagePath":
 function() {return true;}
,"imageFilePath":"water13.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water13');}
,"NameOfTarget":"water13","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5947},{"hasImagePath":
 function() {return true;}
,"imageFilePath":"water14.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water14');}
,"NameOfTarget":"water14","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5948},{"hasImagePath":
 function() {return true;}
,"imageFilePath":"water15.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water15');}
,"NameOfTarget":"water15","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5949}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2162},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile3","LocalData":"","TypeName":"Entity","Id":2162},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2169}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2163},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2163},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return true;}
,"imageFilePath":"stoneWall32.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'stoneWall32');}
,"NameOfTarget":"stoneWall32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5950}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2163},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":true,"LedgeCollision":true,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile4","LocalData":"","TypeName":"Entity","Id":2163},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2170}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2164},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2164},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return true;}
,"imageFilePath":"dirt32.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'dirt32');}
,"NameOfTarget":"dirt32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5951}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2164},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile5","LocalData":"","TypeName":"Entity","Id":2164},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2171}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2165},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2165},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return true;}
,"imageFilePath":"C:\\IISProj\\PlaceholderWebApp 10 Oct 2017 II\\PlaceholderWebApp\\PlaceholderWebApp\\Pages/TempImages/ivanGreatForest205_cc_tile60.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'ivanGreatForest205tile60');}
,"NameOfTarget":"","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5952}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2165},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":true,"LedgeCollision":true,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile6","LocalData":"","TypeName":"Entity","Id":2165},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { game.active().Omnipresent2D.push(this); this.MyIndex = index; return true; }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2172}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2166},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2166},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2166},"MyColor":"FFF","X":160,"Y":256,"W":32,"H":32,"MX":0,"MY":0,"Disabled":false,"MyIndex":"","Omnipresent":true,"NotWorldLevel":true,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"hero","LocalData":"","TypeName":"Entity","Id":2166}],"Threntities":[],"PointLights":[],"MyAudio":[],"MyLogic":{"update":
 function() {for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":null,"TypeName":"SceneProceduralStatement","Id":0},{"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"SceneProceduralStatement","Id":335}],"Name":"","LocalData":"","TypeName":"SceneLogicBox","Id":335},"Name":"","LocalData":"","TypeName":"Scene","Id":335},{"reloadThrentities":
function() { var allT = this.allThrentities(); for(var i in allT) { setupThrentity(allT[i]); } }
,"setup":
 function() {if (this.isSetup !== true) {for(var i in this.TileGrids) { this.TileGrids[i].setup(this); } for(var i in this.PointLights) { this.PointLights[i].setup(this); } if (this.MyAudio !== null) { for (var i = 0; i < this.MyAudio.length; i++) { this.MyAudio[i].setup(); } }if (game.active().Omnipresent2D.length > 0) { var indices = this.entityIndexArray(); var allE = this.allEntities();  for(var i in allE) { if (allE[i].MyIndex != '') { var ind = indices.indexOf(allE[i].MyIndex); if(ind != -1) { indices.splice(ind, 1); } } else { allE[i].setup(indices[i]); } }  } else { for(var i in this.Entities) { this.Entities[i].setup(i); } }if (game.active().Omnipresent3D.length > 0) { var indices = this.threntityIndexArray(); var allT = this.allThrentities(); for(var i in allT) { if (allT[i].MyIndex != '') { var ind = indices.indexOf(allT[i].MyIndex); if (ind != -1) { indices.splice(ind, 1); } } else { allT[i].setup(indices[i]); } }  } else { for(var i in this.Threntities) { this.Threntities[i].setup(i); } }if (this.HasAmbientLight == true) { addAmbientLightToCurrentScene(this.AmbientLightColor, this.AmbientLightIntensity / parseFloat(100)); }this.isSetup = true; }}
,"update":
 function() {this.MyLogic.update();for(var i in this.MyAudio) { this.MyAudio[i].update(); } var allE = this.allEntities(); for(var i in allE) { allE[i].update(); }var allT = this.allThrentities(); for(var i in allT) { allT[i].update(); }for(var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].update(this.AdhocSceneRefs[i].TargetName); } for(var i in this.TileGrids) { this.TileGrids[i].update(); } }
,"draw":
 function() {for(var i in this.TileGrids) { this.TileGrids[i].draw(); } var allE = this.allEntities(); for(var i in allE) { if (allE[i].Disabled !== true) { allE[i].draw(); } }var allT = this.allThrentities(); for(var i in allT) { allT[i].draw(); } }
,"entityIndexArray":
function() { var ray = []; for(var x in game.active().Omnipresent2D) { ray.push(game.active().Omnipresent2D[x].MyIndex); } var rayLen = ray.length; for(i=0;i<rayLen+this.Entities.length;i++) { if (ray.includes((i).toString())) {  } else {  ray.push(i); } } return ray; }
,"threntityIndexArray":
function() { var ray = []; for(var x in game.active().Omnipresent3D) { ray.push(game.active().Omnipresent3D[x].MyIndex); } var rayLen = ray.length; for(i=0;i<rayLen+this.Threntities.length;i++) { if (ray.includes((i).toString())) {  } else {  ray.push(i); } } return ray; }
,"checkMovePoint3d":
function(point3dBefore, point3dAfter) {  var all = this.allThrentities(); for(var i in all) { if (this.checkPointCollision(all[i], point3dBefore, point3dAfter)==true) { return false; } } return true;  }
,"checkPointCollision":
function(targetThrent, point3dBefore, point3dAfter) { var xBef = point3dBefore.X;var xAft = point3dAfter.X;var yBef = point3dBefore.Y;var yAft = point3dAfter.Y;var zBef = point3dBefore.Z;var zAft = point3dAfter.Z;var minX = targetThrent.L();var maxX = targetThrent.R();var minY = targetThrent.B();var maxY = targetThrent.T();var minZ = targetThrent.A();var maxZ = targetThrent.F();var xOverlap = false; var yOverlap = false; var zOverlap = false;if (xBef<xAft) { xOverlap = this.checkRangeOverlap(xBef, xAft, minX, maxX); } else { xOverlap = this.checkRangeOverlap(xAft, xBef, minX, maxX); }if (yBef<yAft) { yOverlap = this.checkRangeOverlap(yBef, yAft, minY, maxY); } else { yOverlap = this.checkRangeOverlap(yAft, yBef, minY, maxY); }if (zBef<zAft) { zOverlap = this.checkRangeOverlap(zBef, zAft, minZ, maxZ); } else { zOverlap = this.checkRangeOverlap(zAft, zBef, minZ, maxZ); }if (xOverlap==true && yOverlap==true && zOverlap==true) { return true; } return false;}
,"checkRangeOverlap":
function (inputOneMin, inputOneMax, inputTwoMin, inputTwoMax) {if (inputOneMin > inputTwoMax || inputOneMax < inputTwoMin) { return false; }return true;}
,"threnCollideContextual":
function(thren, before, after) { var hasCollide = false;var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name) { if (this.ZStraddle(before, after, all[i])===true && this.XStraddle(before, after, all[i])===true && this.YStraddle(before, after, all[i])===true) { hasCollide = true; } if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { hasCollide = true; } } }return hasCollide;}
,"ZStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.Z - before.Z;let secondDiff = target.Z - after.Z;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"XStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.X - before.X;let secondDiff = target.X - after.Y;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"YStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.Y - before.Y;let secondDiff = target.Y - after.Y;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"getFirstThrenCollide":
function(thren) { var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { return thren; } } }
,"threnCollide":
 function(thren) {var hasCollide = false;var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { hasCollide = true; } }return hasCollide;}
,"moveAll2D":
function(x, y) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } for (var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].X += x; this.AdhocSceneRefs[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } }
,"moveAll2DAround":
function(x, y, entName) { var ent = find(game.scene().Entities, entName); if (this.wouldCollide(ent.transpose(-x, -y)) === false) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } } }
,"quickMoveAll2DAround":
function(x, y, ent) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } for(var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].X += x; this.AdhocSceneRefs[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } }
,"tryMoveAll2DAround":
function(x, y, entName) {if (this.getMainTilegrid() === -1) { return this.moveAll2DAround(x, y, entName); } else { this.dynamic2DMove(x, y, entName, this.getMainTilegrid()); } }
,"dynamic2DMove":
function(x, y, entName, tileGrid) {var ent = game.findEntity(entName);if (this.wouldCollide(ent.transpose(-x, -y)) === false) {this.dynamic2DMoveX(x, ent, tileGrid);this.dynamic2DMoveY(y, ent, tileGrid); }}
,"dynamic2DMoveUp":
function(y, ent, tileGrid) {var amtMoveHeroTowardsCenter = (ent.pastCenterY() === false && ent.isCenteredY() === false) ? 0 : (ent.myCenterY() - viewportCenterY());if (amtMoveHeroTowardsCenter >= y) { ent.Y -= y; return; } else { ent.Y -= amtMoveHeroTowardsCenter; }var remainder = y - amtMoveHeroTowardsCenter;var tileGridSlack = 0 - tileGrid.Y;if (remainder <= Math.abs(tileGridSlack)) { this.quickMoveAll2DAround(0, remainder, ent); return; } else { this.quickMoveAll2DAround(0, Math.abs(tileGridSlack), ent); }remainder = remainder - Math.abs(tileGridSlack);ent.Y -= remainder;}
,"dynamic2DMoveDown":
function(y, ent, tileGrid) {var absY = Math.abs(y);var amtMoveHeroTowardsCenter = (ent.isCenteredY() || ent.pastCenterY()) ? 0 : viewportCenterY() - ent.myCenterY();if (amtMoveHeroTowardsCenter >= absY) { ent.Y -= y; return; } else { ent.Y += amtMoveHeroTowardsCenter; }var remainder = absY - amtMoveHeroTowardsCenter;var tileGridSlack = tileGrid.B() - getYDrawBounds2D();if (remainder <= tileGridSlack) { this.quickMoveAll2DAround(0, -remainder, ent); return; } else { this.quickMoveAll2DAround(0, tileGridSlack, ent); }remainder = remainder - tileGridSlack;ent.Y += remainder;}
,"dynamic2DMoveLeft":
function(x, ent, tileGrid) {var amtMoveHeroTowardsCenter = (ent.pastCenterX() === false && ent.isCenteredX() === false) ? 0 : (ent.myCenterX() - viewportCenterX());if (amtMoveHeroTowardsCenter >= x) { ent.X -= x; return; } else { ent.X -= amtMoveHeroTowardsCenter; }var remainder = x - amtMoveHeroTowardsCenter;var tileGridSlack = 0 - tileGrid.X;if (remainder <= Math.abs(tileGridSlack)) { this.quickMoveAll2DAround(remainder, 0, ent); return; } else { this.quickMoveAll2DAround(Math.abs(tileGridSlack), 0, ent); }remainder = remainder - Math.abs(tileGridSlack);ent.X -= remainder;}
,"dynamic2DMoveRight":
function(x, ent, tileGrid) {var absX = Math.abs(x);var amtMoveHeroTowardsCenter = (ent.isCenteredX() || ent.pastCenterX()) ? 0 : viewportCenterX() - ent.myCenterX();if (amtMoveHeroTowardsCenter >= absX) { ent.X -= x; return; } else { ent.X += amtMoveHeroTowardsCenter; }var remainder = absX - amtMoveHeroTowardsCenter;var tileGridSlack = tileGrid.R() - getXDrawBounds2D();if (remainder <= tileGridSlack) { this.quickMoveAll2DAround(-remainder, 0, ent); return; } else { this.quickMoveAll2DAround(tileGridSlack, 0, ent); }remainder = remainder - tileGridSlack;ent.X += remainder;}
,"dynamic2DMoveX":
function(x, ent, tileGrid) { var movingLeft = x > 0;if (movingLeft) { this.dynamic2DMoveLeft(x, ent, tileGrid); return; } else { this.dynamic2DMoveRight(x, ent, tileGrid); return; }var tileGridSlackX = x < 0 ? -1 * tileGrid.X : tileGrid.R() - getXDrawBounds2D(); if (ent.isCenteredX() !== true) { var centerSlackX = (x < 0 ? ((getXDrawBounds2D() / 2) - ent.X) : ent.X - (getXDrawBounds2D() / 2)); if (centerSlackX > Math.abs(x)) { ent.X -= x; }else if (centerSlackX < Math.abs(x) && centerSlackX > 0) { ent.X -= centerSlackX; }  }else if (tileGridSlackX > Math.abs(x)) { this.moveAll2DAround(x, 0, ent.Name); }else if (tileGridSlackX < Math.abs(x) && tileGridSlackX > 0) { this.moveAll2DAround(tileGridSlackX, 0, ent.Name); }}
,"dynamic2DMoveY":
function(y, ent, tileGrid) { var movingUp = y > 0;if (movingUp) { this.dynamic2DMoveUp(y, ent, tileGrid); return; } else { this.dynamic2DMoveDown(y, ent, tileGrid); return; }var tileGridSlackY = y < 0 ? -1 * tileGrid.Y : tileGrid.B() - getYDrawBounds2D();if (ent.isCenteredY() !== true) { var centerSlackY = (y < 0 ? ((getYDrawBounds2D() / 2) - ent.Y) : ent.Y - (getYDrawBounds2D() / 2)); if (centerSlackY > Math.abs(y)) { ent.Y -= y; }else if (centerSlackY < Math.abs(y) && centerSlackY > 0) { ent.Y -= centerSlackY; }  }else if (tileGridSlackY > Math.abs(y)) { this.moveAll2DAround(y, 0, ent.Name); }else if (tileGridSlackY < Math.abs(y) && tileGridSlackY > 0) { this.moveAll2DAround(tileGridSlackY, 0, ent.Name); }}
,"prepareForRenderer":
 function() {return {  };}
,"loadScene":
function() { loadThrentitiesIntoNewScene(this.allThrentities(), this.PointLights); }
,"allThrentities":
function() { return game.active().Omnipresent3D.concat(this.validLocalThrentities()); }
,"validLocalThrentities":
function() { return this.Threntities.filter(function(obj) { return Object.keys(obj).length > 0; }); }
,"getThrentity":
function (index) { var ent = game.active().getOmni3D(index); if (ent != null) { return ent; } var obj = this.Threntities[index]; if (obj == null || Object.keys(obj).length == 0) { return game.active().getOmni3D(index); } else { return this.Threntities[index]; } }
,"allEntities":
function() { return game.active().Omnipresent2D.concat(this.validLocalEntities()); }
,"validLocalEntities":
function() { return this.Entities.filter(function(obj) { return Object.keys(obj).length > 0; }); }
,"getEntity":
function (index) { var ent = game.active().getOmni2D(index); if (ent != null) { return ent; } var obj = this.Entities[index]; if (obj == null || Object.keys(obj).length == 0) { return game.active().getOmni2D(index); } else { return this.Entities[index]; } }
,"getMainTilegrid":
function() { for(var i in this.TileGrids) { if (this.TileGrids[i].MainGrid === true) { return this.TileGrids[i]; } } return -1; }
,"shiftToTop":
function() {  var main = this.getMainTilegrid(); if (main !== -1) { var moveY = main.Y; this.moveAll2D(0, moveY); return moveY; } }
,"shiftToBottom":
function() {  var main = this.getMainTilegrid(); if (main !== -1) { var moveY = -(main.B() - getYDrawBounds2D()); this.moveAll2D(0, moveY); return moveY; } }
,"shiftToRight":
function() { if (this.shiftedToRight == true) {  }  var main = this.getMainTilegrid(); if (main !== -1) {  var moveX = -(main.R() - getXDrawBounds2D()); this.moveAll2D(moveX, 0); this.shiftedToLeft = false; this.shiftedToRight = true; return moveX; } }
,"shiftToLeft":
function() { if (this.shiftedToLeft == true) {  } var main = this.getMainTilegrid(); if (main !== -1) {  var moveX = main.X; this.moveAll2D(moveX, 0);  this.shiftedToLeft = true; this.shiftedToRight = false; return moveX; } }
,"shiftedToLeft":
false
,"shiftedToRight":
false
,"shiftedToTop":
false
,"shiftedToBottom":
false
,"wouldCollide":
 function(entity) {var hasCollide = false;for (var i in this.TileGrids) { if (this.TileGrids[i].wouldCollide(entity) === true) { hasCollide = true; } }var all = this.allEntities(); for (var i in all) { if (all[i].NotWorldLevel !== true && all[i].NonCorporeal !== true && all[i].Disabled !== true && all[i].Name !== entity.name && all[i].wouldCollide(entity)) { hasCollide = true; } }return hasCollide;}
,"isSetup":
false
,"XResolution":640,"YResolution":400,"HasAmbientLight":false,"AmbientLightIntensity":75,"AmbientLightColor":"0xffffcf","Bounds2DX":0,"Bounds2DY":0,"TileGrids":[{"setup":
function(parent) { if (this.DelimitedGrid && this.DelimitedGrid.length > 0){ var rows = this.DelimitedGrid.split(';');for (var j in rows) { this.tiles.push([]); var cells = rows[j].split(',');  for (var i in cells) { var tile=this.getTile(parent, cells[i]); this.tiles[j].push(tile); } } } }
,"getTile":
function(parentScene, tileId) {  var eName = this.EntityNameCSVKey.split(',')[tileId]; var tile = find(parentScene.allEntities(), eName); /* tile.draw = function(x,y,w,h) { this.MyImage.active().render(x,y,w,h); }; */ return tile;  }
,"draw":
function() { if (this.SkipDraw==true) { return; } for(var j in this.tiles) { for(var i in this.tiles[j]) { if (this.tiles[j][i] != null && this.tiles[j][i].MyImage != null) { this.tiles[j][i].MyImage.active().render(this.X + (i * this.TW),this.Y + (j * this.TH),this.TW,this.TH); } } } }
,"update":
 function() {}
,"tiles":
 [] 
,"R":
 function() {return this.X + (this.getWidth() * this.TW);}
,"B":
 function() {return this.Y + (this.getHeight() * this.TH);}
,"wouldCollide":
 function(entity) {for(var j in this.tiles)      {       for (var i in this.tiles[j])       {        if (this.tiles[j][i] != null && this.tiles[j][i].ForceCollision===true)        {         var x = this.X + (i * this.TW);         var y = this.Y + (j * this.TH);         if (checkOverlap({X:x,Y:y,W:this.TW,H:this.TH}, entity) === true)         {          console.log('overlap found');         var events = this.tiles[j][i].collisionEvents;         if (events !== null)         {         }         if (this.tiles[j][i].LedgeCollision === true)         {          if (/*notideal*/downkey() && !leftkey() && !rightkey())          {           console.log('ledge collision detected');           /*arbitrary*/var speed = 4;           /* make entity.MyLogic have a non null ActionBlock? */           entity.Me.MyLogic.ActionBlock.MyActions.push({Depth:((this.TH/speed)*2)+1,SelfDestruct:true,Ct:0,Destroyed:false,update:function() { console.log('updating action');  if (this.BlockInput === true) { BlockInput(); } if (this.SelfDestruct === true && this.Ct + 1 == this.Depth) { this.Destroyed = true; } if (this.Destroyed !== true) { this.MyScript(); this.Ct++; } },MyTarget:entity,BlockInput:true,LocalData:speed,MyScript:function() { console.log('performing action...'); this.MyTarget.Me.Y += this.LocalData; }});          }         }         return true;         }        }       }      }       return false;}
,"getWidth":
function() { if (this.getHeight() > 0) { return this.tiles[0].length; } else { return 0; } }
,"getHeight":
function() { return this.tiles.length; }
,"EntityIndexCSVKey":"","EntityNameCSVKey":"tile1,tile2,tile3,tile4,tile5","DelimitedGrid":"0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0;0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0;0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0;0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0;0,0,0,0,0,0,1,1,1,1,4,4,4,4,4,4,4,1,1,1,0,0,0,0;0,0,0,0,0,0,1,1,1,1,4,4,4,4,4,4,4,1,1,1,0,0,0,0;0,0,0,0,0,0,1,1,1,1,4,4,4,4,4,4,4,1,1,1,0,0,0,0;0,0,0,0,0,0,1,1,1,1,4,4,4,4,4,4,4,1,1,1,0,0,0,0;0,0,0,0,0,0,1,1,1,1,4,4,4,4,4,4,4,1,1,1,0,0,0,0;0,0,0,0,0,0,1,1,1,1,4,4,4,4,4,4,4,1,1,1,0,0,0,0;0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0;0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0;0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0;0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0","SkipDraw":false,"MainGrid":true,"TW":32,"TH":32,"X":0,"Y":0,"Name":"","LocalData":"","TypeName":"TileGrid","Id":300}],"AdhocSceneRefs":[{"TargetName":"hero","update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":320,"Y":320,"W":32,"H":32,"TargetX":0,"TargetY":0,"SkipXMove":true,"SkipYMove":true,"TargetScene":16,"LocalScene":1,"Name":"","LocalData":"","TypeName":"AdhocSceneRef","Id":27}],"Entities":[{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2173}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2167},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2167},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'grass32');}
,"NameOfTarget":"grass32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5953}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2167},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile1","LocalData":"","TypeName":"Entity","Id":2167},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2174}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2168},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2168},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'stone32');}
,"NameOfTarget":"stone32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5954}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2168},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile2","LocalData":"","TypeName":"Entity","Id":2168},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2175}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2169},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2169},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":8,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water1');}
,"NameOfTarget":"water1","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5955},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water2');}
,"NameOfTarget":"water2","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5956},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water3');}
,"NameOfTarget":"water3","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5957},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water4');}
,"NameOfTarget":"water4","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5958},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water5');}
,"NameOfTarget":"water5","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5959},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water6');}
,"NameOfTarget":"water6","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5960},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water7');}
,"NameOfTarget":"water7","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5961},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water8');}
,"NameOfTarget":"water8","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5962},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water9');}
,"NameOfTarget":"water9","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5963},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water10');}
,"NameOfTarget":"water10","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5964},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water11');}
,"NameOfTarget":"water11","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5965},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water12');}
,"NameOfTarget":"water12","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5966},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water13');}
,"NameOfTarget":"water13","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5967},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water14');}
,"NameOfTarget":"water14","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5968},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water15');}
,"NameOfTarget":"water15","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5969}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2169},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile3","LocalData":"","TypeName":"Entity","Id":2169},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2176}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2170},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2170},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'stoneWall32');}
,"NameOfTarget":"stoneWall32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5970}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2170},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":true,"LedgeCollision":true,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile4","LocalData":"","TypeName":"Entity","Id":2170},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2177}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2171},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2171},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'dirt32');}
,"NameOfTarget":"dirt32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5971}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2171},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile5","LocalData":"","TypeName":"Entity","Id":2171},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2178}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2172},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2172},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return true;}
,"imageFilePath":"ivanGreatForest205_cc_tile60.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'ivanGreatForest205tile60');}
,"NameOfTarget":"","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5972}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2172},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":true,"LedgeCollision":true,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile6","LocalData":"","TypeName":"Entity","Id":2172},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2179}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2173},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2173},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return true;}
,"imageFilePath":"C:\\IISProj\\PlaceholderWebApp 10 Oct 2017 II\\PlaceholderWebApp\\PlaceholderWebApp\\Pages/TempImages/ivanGreatForest205_cc_testStairsDown0.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'ivanGreatForest205testStairsDown0');}
,"NameOfTarget":"","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5973}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2173},"MyColor":"","X":320,"Y":320,"W":32,"H":32,"MX":0,"MY":0,"Disabled":false,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":true,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"testStairsDown","LocalData":"","TypeName":"Entity","Id":2173}],"Threntities":[],"PointLights":[],"MyAudio":[],"MyLogic":{"update":
 function() {for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":null,"TypeName":"SceneProceduralStatement","Id":0},{"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"SceneProceduralStatement","Id":336}],"Name":"","LocalData":"","TypeName":"SceneLogicBox","Id":336},"Name":"","LocalData":"","TypeName":"Scene","Id":336},{"reloadThrentities":
function() { var allT = this.allThrentities(); for(var i in allT) { setupThrentity(allT[i]); } }
,"setup":
 function() {if (this.isSetup !== true) {for(var i in this.TileGrids) { this.TileGrids[i].setup(this); } for(var i in this.PointLights) { this.PointLights[i].setup(this); } if (this.MyAudio !== null) { for (var i = 0; i < this.MyAudio.length; i++) { this.MyAudio[i].setup(); } }if (game.active().Omnipresent2D.length > 0) { var indices = this.entityIndexArray(); var allE = this.allEntities();  for(var i in allE) { if (allE[i].MyIndex != '') { var ind = indices.indexOf(allE[i].MyIndex); if(ind != -1) { indices.splice(ind, 1); } } else { allE[i].setup(indices[i]); } }  } else { for(var i in this.Entities) { this.Entities[i].setup(i); } }if (game.active().Omnipresent3D.length > 0) { var indices = this.threntityIndexArray(); var allT = this.allThrentities(); for(var i in allT) { if (allT[i].MyIndex != '') { var ind = indices.indexOf(allT[i].MyIndex); if (ind != -1) { indices.splice(ind, 1); } } else { allT[i].setup(indices[i]); } }  } else { for(var i in this.Threntities) { this.Threntities[i].setup(i); } }if (this.HasAmbientLight == true) { addAmbientLightToCurrentScene(this.AmbientLightColor, this.AmbientLightIntensity / parseFloat(100)); }this.isSetup = true; }}
,"update":
 function() {this.MyLogic.update();for(var i in this.MyAudio) { this.MyAudio[i].update(); } var allE = this.allEntities(); for(var i in allE) { allE[i].update(); }var allT = this.allThrentities(); for(var i in allT) { allT[i].update(); }for(var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].update(this.AdhocSceneRefs[i].TargetName); } for(var i in this.TileGrids) { this.TileGrids[i].update(); } }
,"draw":
 function() {for(var i in this.TileGrids) { this.TileGrids[i].draw(); } var allE = this.allEntities(); for(var i in allE) { if (allE[i].Disabled !== true) { allE[i].draw(); } }var allT = this.allThrentities(); for(var i in allT) { allT[i].draw(); } }
,"entityIndexArray":
function() { var ray = []; for(var x in game.active().Omnipresent2D) { ray.push(game.active().Omnipresent2D[x].MyIndex); } var rayLen = ray.length; for(i=0;i<rayLen+this.Entities.length;i++) { if (ray.includes((i).toString())) {  } else {  ray.push(i); } } return ray; }
,"threntityIndexArray":
function() { var ray = []; for(var x in game.active().Omnipresent3D) { ray.push(game.active().Omnipresent3D[x].MyIndex); } var rayLen = ray.length; for(i=0;i<rayLen+this.Threntities.length;i++) { if (ray.includes((i).toString())) {  } else {  ray.push(i); } } return ray; }
,"checkMovePoint3d":
function(point3dBefore, point3dAfter) {  var all = this.allThrentities(); for(var i in all) { if (this.checkPointCollision(all[i], point3dBefore, point3dAfter)==true) { return false; } } return true;  }
,"checkPointCollision":
function(targetThrent, point3dBefore, point3dAfter) { var xBef = point3dBefore.X;var xAft = point3dAfter.X;var yBef = point3dBefore.Y;var yAft = point3dAfter.Y;var zBef = point3dBefore.Z;var zAft = point3dAfter.Z;var minX = targetThrent.L();var maxX = targetThrent.R();var minY = targetThrent.B();var maxY = targetThrent.T();var minZ = targetThrent.A();var maxZ = targetThrent.F();var xOverlap = false; var yOverlap = false; var zOverlap = false;if (xBef<xAft) { xOverlap = this.checkRangeOverlap(xBef, xAft, minX, maxX); } else { xOverlap = this.checkRangeOverlap(xAft, xBef, minX, maxX); }if (yBef<yAft) { yOverlap = this.checkRangeOverlap(yBef, yAft, minY, maxY); } else { yOverlap = this.checkRangeOverlap(yAft, yBef, minY, maxY); }if (zBef<zAft) { zOverlap = this.checkRangeOverlap(zBef, zAft, minZ, maxZ); } else { zOverlap = this.checkRangeOverlap(zAft, zBef, minZ, maxZ); }if (xOverlap==true && yOverlap==true && zOverlap==true) { return true; } return false;}
,"checkRangeOverlap":
function (inputOneMin, inputOneMax, inputTwoMin, inputTwoMax) {if (inputOneMin > inputTwoMax || inputOneMax < inputTwoMin) { return false; }return true;}
,"threnCollideContextual":
function(thren, before, after) { var hasCollide = false;var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name) { if (this.ZStraddle(before, after, all[i])===true && this.XStraddle(before, after, all[i])===true && this.YStraddle(before, after, all[i])===true) { hasCollide = true; } if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { hasCollide = true; } } }return hasCollide;}
,"ZStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.Z - before.Z;let secondDiff = target.Z - after.Z;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"XStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.X - before.X;let secondDiff = target.X - after.Y;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"YStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.Y - before.Y;let secondDiff = target.Y - after.Y;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"getFirstThrenCollide":
function(thren) { var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { return thren; } } }
,"threnCollide":
 function(thren) {var hasCollide = false;var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { hasCollide = true; } }return hasCollide;}
,"moveAll2D":
function(x, y) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } for (var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].X += x; this.AdhocSceneRefs[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } }
,"moveAll2DAround":
function(x, y, entName) { var ent = find(game.scene().Entities, entName); if (this.wouldCollide(ent.transpose(-x, -y)) === false) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } } }
,"quickMoveAll2DAround":
function(x, y, ent) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } for(var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].X += x; this.AdhocSceneRefs[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } }
,"tryMoveAll2DAround":
function(x, y, entName) {if (this.getMainTilegrid() === -1) { return this.moveAll2DAround(x, y, entName); } else { this.dynamic2DMove(x, y, entName, this.getMainTilegrid()); } }
,"dynamic2DMove":
function(x, y, entName, tileGrid) {var ent = game.findEntity(entName);if (this.wouldCollide(ent.transpose(-x, -y)) === false) {this.dynamic2DMoveX(x, ent, tileGrid);this.dynamic2DMoveY(y, ent, tileGrid); }}
,"dynamic2DMoveUp":
function(y, ent, tileGrid) {var amtMoveHeroTowardsCenter = (ent.pastCenterY() === false && ent.isCenteredY() === false) ? 0 : (ent.myCenterY() - viewportCenterY());if (amtMoveHeroTowardsCenter >= y) { ent.Y -= y; return; } else { ent.Y -= amtMoveHeroTowardsCenter; }var remainder = y - amtMoveHeroTowardsCenter;var tileGridSlack = 0 - tileGrid.Y;if (remainder <= Math.abs(tileGridSlack)) { this.quickMoveAll2DAround(0, remainder, ent); return; } else { this.quickMoveAll2DAround(0, Math.abs(tileGridSlack), ent); }remainder = remainder - Math.abs(tileGridSlack);ent.Y -= remainder;}
,"dynamic2DMoveDown":
function(y, ent, tileGrid) {var absY = Math.abs(y);var amtMoveHeroTowardsCenter = (ent.isCenteredY() || ent.pastCenterY()) ? 0 : viewportCenterY() - ent.myCenterY();if (amtMoveHeroTowardsCenter >= absY) { ent.Y -= y; return; } else { ent.Y += amtMoveHeroTowardsCenter; }var remainder = absY - amtMoveHeroTowardsCenter;var tileGridSlack = tileGrid.B() - getYDrawBounds2D();if (remainder <= tileGridSlack) { this.quickMoveAll2DAround(0, -remainder, ent); return; } else { this.quickMoveAll2DAround(0, tileGridSlack, ent); }remainder = remainder - tileGridSlack;ent.Y += remainder;}
,"dynamic2DMoveLeft":
function(x, ent, tileGrid) {var amtMoveHeroTowardsCenter = (ent.pastCenterX() === false && ent.isCenteredX() === false) ? 0 : (ent.myCenterX() - viewportCenterX());if (amtMoveHeroTowardsCenter >= x) { ent.X -= x; return; } else { ent.X -= amtMoveHeroTowardsCenter; }var remainder = x - amtMoveHeroTowardsCenter;var tileGridSlack = 0 - tileGrid.X;if (remainder <= Math.abs(tileGridSlack)) { this.quickMoveAll2DAround(remainder, 0, ent); return; } else { this.quickMoveAll2DAround(Math.abs(tileGridSlack), 0, ent); }remainder = remainder - Math.abs(tileGridSlack);ent.X -= remainder;}
,"dynamic2DMoveRight":
function(x, ent, tileGrid) {var absX = Math.abs(x);var amtMoveHeroTowardsCenter = (ent.isCenteredX() || ent.pastCenterX()) ? 0 : viewportCenterX() - ent.myCenterX();if (amtMoveHeroTowardsCenter >= absX) { ent.X -= x; return; } else { ent.X += amtMoveHeroTowardsCenter; }var remainder = absX - amtMoveHeroTowardsCenter;var tileGridSlack = tileGrid.R() - getXDrawBounds2D();if (remainder <= tileGridSlack) { this.quickMoveAll2DAround(-remainder, 0, ent); return; } else { this.quickMoveAll2DAround(tileGridSlack, 0, ent); }remainder = remainder - tileGridSlack;ent.X += remainder;}
,"dynamic2DMoveX":
function(x, ent, tileGrid) { var movingLeft = x > 0;if (movingLeft) { this.dynamic2DMoveLeft(x, ent, tileGrid); return; } else { this.dynamic2DMoveRight(x, ent, tileGrid); return; }var tileGridSlackX = x < 0 ? -1 * tileGrid.X : tileGrid.R() - getXDrawBounds2D(); if (ent.isCenteredX() !== true) { var centerSlackX = (x < 0 ? ((getXDrawBounds2D() / 2) - ent.X) : ent.X - (getXDrawBounds2D() / 2)); if (centerSlackX > Math.abs(x)) { ent.X -= x; }else if (centerSlackX < Math.abs(x) && centerSlackX > 0) { ent.X -= centerSlackX; }  }else if (tileGridSlackX > Math.abs(x)) { this.moveAll2DAround(x, 0, ent.Name); }else if (tileGridSlackX < Math.abs(x) && tileGridSlackX > 0) { this.moveAll2DAround(tileGridSlackX, 0, ent.Name); }}
,"dynamic2DMoveY":
function(y, ent, tileGrid) { var movingUp = y > 0;if (movingUp) { this.dynamic2DMoveUp(y, ent, tileGrid); return; } else { this.dynamic2DMoveDown(y, ent, tileGrid); return; }var tileGridSlackY = y < 0 ? -1 * tileGrid.Y : tileGrid.B() - getYDrawBounds2D();if (ent.isCenteredY() !== true) { var centerSlackY = (y < 0 ? ((getYDrawBounds2D() / 2) - ent.Y) : ent.Y - (getYDrawBounds2D() / 2)); if (centerSlackY > Math.abs(y)) { ent.Y -= y; }else if (centerSlackY < Math.abs(y) && centerSlackY > 0) { ent.Y -= centerSlackY; }  }else if (tileGridSlackY > Math.abs(y)) { this.moveAll2DAround(y, 0, ent.Name); }else if (tileGridSlackY < Math.abs(y) && tileGridSlackY > 0) { this.moveAll2DAround(tileGridSlackY, 0, ent.Name); }}
,"prepareForRenderer":
 function() {return {  };}
,"loadScene":
function() { loadThrentitiesIntoNewScene(this.allThrentities(), this.PointLights); }
,"allThrentities":
function() { return game.active().Omnipresent3D.concat(this.validLocalThrentities()); }
,"validLocalThrentities":
function() { return this.Threntities.filter(function(obj) { return Object.keys(obj).length > 0; }); }
,"getThrentity":
function (index) { var ent = game.active().getOmni3D(index); if (ent != null) { return ent; } var obj = this.Threntities[index]; if (obj == null || Object.keys(obj).length == 0) { return game.active().getOmni3D(index); } else { return this.Threntities[index]; } }
,"allEntities":
function() { return game.active().Omnipresent2D.concat(this.validLocalEntities()); }
,"validLocalEntities":
function() { return this.Entities.filter(function(obj) { return Object.keys(obj).length > 0; }); }
,"getEntity":
function (index) { var ent = game.active().getOmni2D(index); if (ent != null) { return ent; } var obj = this.Entities[index]; if (obj == null || Object.keys(obj).length == 0) { return game.active().getOmni2D(index); } else { return this.Entities[index]; } }
,"getMainTilegrid":
function() { for(var i in this.TileGrids) { if (this.TileGrids[i].MainGrid === true) { return this.TileGrids[i]; } } return -1; }
,"shiftToTop":
function() {  var main = this.getMainTilegrid(); if (main !== -1) { var moveY = main.Y; this.moveAll2D(0, moveY); return moveY; } }
,"shiftToBottom":
function() {  var main = this.getMainTilegrid(); if (main !== -1) { var moveY = -(main.B() - getYDrawBounds2D()); this.moveAll2D(0, moveY); return moveY; } }
,"shiftToRight":
function() { if (this.shiftedToRight == true) {  }  var main = this.getMainTilegrid(); if (main !== -1) {  var moveX = -(main.R() - getXDrawBounds2D()); this.moveAll2D(moveX, 0); this.shiftedToLeft = false; this.shiftedToRight = true; return moveX; } }
,"shiftToLeft":
function() { if (this.shiftedToLeft == true) {  } var main = this.getMainTilegrid(); if (main !== -1) {  var moveX = main.X; this.moveAll2D(moveX, 0);  this.shiftedToLeft = true; this.shiftedToRight = false; return moveX; } }
,"shiftedToLeft":
false
,"shiftedToRight":
false
,"shiftedToTop":
false
,"shiftedToBottom":
false
,"wouldCollide":
 function(entity) {var hasCollide = false;for (var i in this.TileGrids) { if (this.TileGrids[i].wouldCollide(entity) === true) { hasCollide = true; } }var all = this.allEntities(); for (var i in all) { if (all[i].NotWorldLevel !== true && all[i].NonCorporeal !== true && all[i].Disabled !== true && all[i].Name !== entity.name && all[i].wouldCollide(entity)) { hasCollide = true; } }return hasCollide;}
,"isSetup":
false
,"XResolution":640,"YResolution":400,"HasAmbientLight":false,"AmbientLightIntensity":75,"AmbientLightColor":"0xffffcf","Bounds2DX":0,"Bounds2DY":0,"TileGrids":[{"setup":
function(parent) { if (this.DelimitedGrid && this.DelimitedGrid.length > 0){ var rows = this.DelimitedGrid.split(';');for (var j in rows) { this.tiles.push([]); var cells = rows[j].split(',');  for (var i in cells) { var tile=this.getTile(parent, cells[i]); this.tiles[j].push(tile); } } } }
,"getTile":
function(parentScene, tileId) {  var eName = this.EntityNameCSVKey.split(',')[tileId]; var tile = find(parentScene.allEntities(), eName); /* tile.draw = function(x,y,w,h) { this.MyImage.active().render(x,y,w,h); }; */ return tile;  }
,"draw":
function() { if (this.SkipDraw==true) { return; } for(var j in this.tiles) { for(var i in this.tiles[j]) { if (this.tiles[j][i] != null && this.tiles[j][i].MyImage != null) { this.tiles[j][i].MyImage.active().render(this.X + (i * this.TW),this.Y + (j * this.TH),this.TW,this.TH); } } } }
,"update":
 function() {}
,"tiles":
 [] 
,"R":
 function() {return this.X + (this.getWidth() * this.TW);}
,"B":
 function() {return this.Y + (this.getHeight() * this.TH);}
,"wouldCollide":
 function(entity) {for(var j in this.tiles)      {       for (var i in this.tiles[j])       {        if (this.tiles[j][i] != null && this.tiles[j][i].ForceCollision===true)        {         var x = this.X + (i * this.TW);         var y = this.Y + (j * this.TH);         if (checkOverlap({X:x,Y:y,W:this.TW,H:this.TH}, entity) === true)         {          console.log('overlap found');         var events = this.tiles[j][i].collisionEvents;         if (events !== null)         {         }         if (this.tiles[j][i].LedgeCollision === true)         {          if (/*notideal*/downkey() && !leftkey() && !rightkey())          {           console.log('ledge collision detected');           /*arbitrary*/var speed = 4;           /* make entity.MyLogic have a non null ActionBlock? */           entity.Me.MyLogic.ActionBlock.MyActions.push({Depth:((this.TH/speed)*2)+1,SelfDestruct:true,Ct:0,Destroyed:false,update:function() { console.log('updating action');  if (this.BlockInput === true) { BlockInput(); } if (this.SelfDestruct === true && this.Ct + 1 == this.Depth) { this.Destroyed = true; } if (this.Destroyed !== true) { this.MyScript(); this.Ct++; } },MyTarget:entity,BlockInput:true,LocalData:speed,MyScript:function() { console.log('performing action...'); this.MyTarget.Me.Y += this.LocalData; }});          }         }         return true;         }        }       }      }       return false;}
,"getWidth":
function() { if (this.getHeight() > 0) { return this.tiles[0].length; } else { return 0; } }
,"getHeight":
function() { return this.tiles.length; }
,"EntityIndexCSVKey":"","EntityNameCSVKey":"tile1,tile2,tile3,tile4","DelimitedGrid":"0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0","SkipDraw":false,"MainGrid":true,"TW":32,"TH":32,"X":0,"Y":0,"Name":"","LocalData":"","TypeName":"TileGrid","Id":301}],"AdhocSceneRefs":[],"Entities":[{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2180}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2174},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2174},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'grass32');}
,"NameOfTarget":"grass32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5974}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2174},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile1","LocalData":"","TypeName":"Entity","Id":2174},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2181}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2175},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2175},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'stone32');}
,"NameOfTarget":"stone32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5975}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2175},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile2","LocalData":"","TypeName":"Entity","Id":2175},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2182}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2176},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2176},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":8,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water1');}
,"NameOfTarget":"water1","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5976},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water2');}
,"NameOfTarget":"water2","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5977},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water3');}
,"NameOfTarget":"water3","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5978},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water4');}
,"NameOfTarget":"water4","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5979},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water5');}
,"NameOfTarget":"water5","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5980},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water6');}
,"NameOfTarget":"water6","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5981},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water7');}
,"NameOfTarget":"water7","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5982},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water8');}
,"NameOfTarget":"water8","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5983},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water9');}
,"NameOfTarget":"water9","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5984},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water10');}
,"NameOfTarget":"water10","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5985},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water11');}
,"NameOfTarget":"water11","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5986},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water12');}
,"NameOfTarget":"water12","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5987},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water13');}
,"NameOfTarget":"water13","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5988},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water14');}
,"NameOfTarget":"water14","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5989},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water15');}
,"NameOfTarget":"water15","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5990}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2176},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile3","LocalData":"","TypeName":"Entity","Id":2176},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2183}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2177},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2177},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'stoneWall32');}
,"NameOfTarget":"stoneWall32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5991}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2177},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":true,"LedgeCollision":true,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile4","LocalData":"","TypeName":"Entity","Id":2177}],"Threntities":[],"PointLights":[],"MyAudio":[],"MyLogic":{"update":
 function() {for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":null,"TypeName":"SceneProceduralStatement","Id":0},{"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"SceneProceduralStatement","Id":337}],"Name":"","LocalData":"","TypeName":"SceneLogicBox","Id":337},"Name":"","LocalData":"","TypeName":"Scene","Id":337},{"reloadThrentities":
function() { var allT = this.allThrentities(); for(var i in allT) { setupThrentity(allT[i]); } }
,"setup":
 function() {if (this.isSetup !== true) {for(var i in this.TileGrids) { this.TileGrids[i].setup(this); } for(var i in this.PointLights) { this.PointLights[i].setup(this); } if (this.MyAudio !== null) { for (var i = 0; i < this.MyAudio.length; i++) { this.MyAudio[i].setup(); } }if (game.active().Omnipresent2D.length > 0) { var indices = this.entityIndexArray(); var allE = this.allEntities();  for(var i in allE) { if (allE[i].MyIndex != '') { var ind = indices.indexOf(allE[i].MyIndex); if(ind != -1) { indices.splice(ind, 1); } } else { allE[i].setup(indices[i]); } }  } else { for(var i in this.Entities) { this.Entities[i].setup(i); } }if (game.active().Omnipresent3D.length > 0) { var indices = this.threntityIndexArray(); var allT = this.allThrentities(); for(var i in allT) { if (allT[i].MyIndex != '') { var ind = indices.indexOf(allT[i].MyIndex); if (ind != -1) { indices.splice(ind, 1); } } else { allT[i].setup(indices[i]); } }  } else { for(var i in this.Threntities) { this.Threntities[i].setup(i); } }if (this.HasAmbientLight == true) { addAmbientLightToCurrentScene(this.AmbientLightColor, this.AmbientLightIntensity / parseFloat(100)); }this.isSetup = true; }}
,"update":
 function() {this.MyLogic.update();for(var i in this.MyAudio) { this.MyAudio[i].update(); } var allE = this.allEntities(); for(var i in allE) { allE[i].update(); }var allT = this.allThrentities(); for(var i in allT) { allT[i].update(); }for(var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].update(this.AdhocSceneRefs[i].TargetName); } for(var i in this.TileGrids) { this.TileGrids[i].update(); } }
,"draw":
 function() {for(var i in this.TileGrids) { this.TileGrids[i].draw(); } var allE = this.allEntities(); for(var i in allE) { if (allE[i].Disabled !== true) { allE[i].draw(); } }var allT = this.allThrentities(); for(var i in allT) { allT[i].draw(); } }
,"entityIndexArray":
function() { var ray = []; for(var x in game.active().Omnipresent2D) { ray.push(game.active().Omnipresent2D[x].MyIndex); } var rayLen = ray.length; for(i=0;i<rayLen+this.Entities.length;i++) { if (ray.includes((i).toString())) {  } else {  ray.push(i); } } return ray; }
,"threntityIndexArray":
function() { var ray = []; for(var x in game.active().Omnipresent3D) { ray.push(game.active().Omnipresent3D[x].MyIndex); } var rayLen = ray.length; for(i=0;i<rayLen+this.Threntities.length;i++) { if (ray.includes((i).toString())) {  } else {  ray.push(i); } } return ray; }
,"checkMovePoint3d":
function(point3dBefore, point3dAfter) {  var all = this.allThrentities(); for(var i in all) { if (this.checkPointCollision(all[i], point3dBefore, point3dAfter)==true) { return false; } } return true;  }
,"checkPointCollision":
function(targetThrent, point3dBefore, point3dAfter) { var xBef = point3dBefore.X;var xAft = point3dAfter.X;var yBef = point3dBefore.Y;var yAft = point3dAfter.Y;var zBef = point3dBefore.Z;var zAft = point3dAfter.Z;var minX = targetThrent.L();var maxX = targetThrent.R();var minY = targetThrent.B();var maxY = targetThrent.T();var minZ = targetThrent.A();var maxZ = targetThrent.F();var xOverlap = false; var yOverlap = false; var zOverlap = false;if (xBef<xAft) { xOverlap = this.checkRangeOverlap(xBef, xAft, minX, maxX); } else { xOverlap = this.checkRangeOverlap(xAft, xBef, minX, maxX); }if (yBef<yAft) { yOverlap = this.checkRangeOverlap(yBef, yAft, minY, maxY); } else { yOverlap = this.checkRangeOverlap(yAft, yBef, minY, maxY); }if (zBef<zAft) { zOverlap = this.checkRangeOverlap(zBef, zAft, minZ, maxZ); } else { zOverlap = this.checkRangeOverlap(zAft, zBef, minZ, maxZ); }if (xOverlap==true && yOverlap==true && zOverlap==true) { return true; } return false;}
,"checkRangeOverlap":
function (inputOneMin, inputOneMax, inputTwoMin, inputTwoMax) {if (inputOneMin > inputTwoMax || inputOneMax < inputTwoMin) { return false; }return true;}
,"threnCollideContextual":
function(thren, before, after) { var hasCollide = false;var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name) { if (this.ZStraddle(before, after, all[i])===true && this.XStraddle(before, after, all[i])===true && this.YStraddle(before, after, all[i])===true) { hasCollide = true; } if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { hasCollide = true; } } }return hasCollide;}
,"ZStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.Z - before.Z;let secondDiff = target.Z - after.Z;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"XStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.X - before.X;let secondDiff = target.X - after.Y;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"YStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.Y - before.Y;let secondDiff = target.Y - after.Y;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"getFirstThrenCollide":
function(thren) { var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { return thren; } } }
,"threnCollide":
 function(thren) {var hasCollide = false;var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { hasCollide = true; } }return hasCollide;}
,"moveAll2D":
function(x, y) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } for (var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].X += x; this.AdhocSceneRefs[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } }
,"moveAll2DAround":
function(x, y, entName) { var ent = find(game.scene().Entities, entName); if (this.wouldCollide(ent.transpose(-x, -y)) === false) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } } }
,"quickMoveAll2DAround":
function(x, y, ent) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } for(var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].X += x; this.AdhocSceneRefs[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } }
,"tryMoveAll2DAround":
function(x, y, entName) {if (this.getMainTilegrid() === -1) { return this.moveAll2DAround(x, y, entName); } else { this.dynamic2DMove(x, y, entName, this.getMainTilegrid()); } }
,"dynamic2DMove":
function(x, y, entName, tileGrid) {var ent = game.findEntity(entName);if (this.wouldCollide(ent.transpose(-x, -y)) === false) {this.dynamic2DMoveX(x, ent, tileGrid);this.dynamic2DMoveY(y, ent, tileGrid); }}
,"dynamic2DMoveUp":
function(y, ent, tileGrid) {var amtMoveHeroTowardsCenter = (ent.pastCenterY() === false && ent.isCenteredY() === false) ? 0 : (ent.myCenterY() - viewportCenterY());if (amtMoveHeroTowardsCenter >= y) { ent.Y -= y; return; } else { ent.Y -= amtMoveHeroTowardsCenter; }var remainder = y - amtMoveHeroTowardsCenter;var tileGridSlack = 0 - tileGrid.Y;if (remainder <= Math.abs(tileGridSlack)) { this.quickMoveAll2DAround(0, remainder, ent); return; } else { this.quickMoveAll2DAround(0, Math.abs(tileGridSlack), ent); }remainder = remainder - Math.abs(tileGridSlack);ent.Y -= remainder;}
,"dynamic2DMoveDown":
function(y, ent, tileGrid) {var absY = Math.abs(y);var amtMoveHeroTowardsCenter = (ent.isCenteredY() || ent.pastCenterY()) ? 0 : viewportCenterY() - ent.myCenterY();if (amtMoveHeroTowardsCenter >= absY) { ent.Y -= y; return; } else { ent.Y += amtMoveHeroTowardsCenter; }var remainder = absY - amtMoveHeroTowardsCenter;var tileGridSlack = tileGrid.B() - getYDrawBounds2D();if (remainder <= tileGridSlack) { this.quickMoveAll2DAround(0, -remainder, ent); return; } else { this.quickMoveAll2DAround(0, tileGridSlack, ent); }remainder = remainder - tileGridSlack;ent.Y += remainder;}
,"dynamic2DMoveLeft":
function(x, ent, tileGrid) {var amtMoveHeroTowardsCenter = (ent.pastCenterX() === false && ent.isCenteredX() === false) ? 0 : (ent.myCenterX() - viewportCenterX());if (amtMoveHeroTowardsCenter >= x) { ent.X -= x; return; } else { ent.X -= amtMoveHeroTowardsCenter; }var remainder = x - amtMoveHeroTowardsCenter;var tileGridSlack = 0 - tileGrid.X;if (remainder <= Math.abs(tileGridSlack)) { this.quickMoveAll2DAround(remainder, 0, ent); return; } else { this.quickMoveAll2DAround(Math.abs(tileGridSlack), 0, ent); }remainder = remainder - Math.abs(tileGridSlack);ent.X -= remainder;}
,"dynamic2DMoveRight":
function(x, ent, tileGrid) {var absX = Math.abs(x);var amtMoveHeroTowardsCenter = (ent.isCenteredX() || ent.pastCenterX()) ? 0 : viewportCenterX() - ent.myCenterX();if (amtMoveHeroTowardsCenter >= absX) { ent.X -= x; return; } else { ent.X += amtMoveHeroTowardsCenter; }var remainder = absX - amtMoveHeroTowardsCenter;var tileGridSlack = tileGrid.R() - getXDrawBounds2D();if (remainder <= tileGridSlack) { this.quickMoveAll2DAround(-remainder, 0, ent); return; } else { this.quickMoveAll2DAround(tileGridSlack, 0, ent); }remainder = remainder - tileGridSlack;ent.X += remainder;}
,"dynamic2DMoveX":
function(x, ent, tileGrid) { var movingLeft = x > 0;if (movingLeft) { this.dynamic2DMoveLeft(x, ent, tileGrid); return; } else { this.dynamic2DMoveRight(x, ent, tileGrid); return; }var tileGridSlackX = x < 0 ? -1 * tileGrid.X : tileGrid.R() - getXDrawBounds2D(); if (ent.isCenteredX() !== true) { var centerSlackX = (x < 0 ? ((getXDrawBounds2D() / 2) - ent.X) : ent.X - (getXDrawBounds2D() / 2)); if (centerSlackX > Math.abs(x)) { ent.X -= x; }else if (centerSlackX < Math.abs(x) && centerSlackX > 0) { ent.X -= centerSlackX; }  }else if (tileGridSlackX > Math.abs(x)) { this.moveAll2DAround(x, 0, ent.Name); }else if (tileGridSlackX < Math.abs(x) && tileGridSlackX > 0) { this.moveAll2DAround(tileGridSlackX, 0, ent.Name); }}
,"dynamic2DMoveY":
function(y, ent, tileGrid) { var movingUp = y > 0;if (movingUp) { this.dynamic2DMoveUp(y, ent, tileGrid); return; } else { this.dynamic2DMoveDown(y, ent, tileGrid); return; }var tileGridSlackY = y < 0 ? -1 * tileGrid.Y : tileGrid.B() - getYDrawBounds2D();if (ent.isCenteredY() !== true) { var centerSlackY = (y < 0 ? ((getYDrawBounds2D() / 2) - ent.Y) : ent.Y - (getYDrawBounds2D() / 2)); if (centerSlackY > Math.abs(y)) { ent.Y -= y; }else if (centerSlackY < Math.abs(y) && centerSlackY > 0) { ent.Y -= centerSlackY; }  }else if (tileGridSlackY > Math.abs(y)) { this.moveAll2DAround(y, 0, ent.Name); }else if (tileGridSlackY < Math.abs(y) && tileGridSlackY > 0) { this.moveAll2DAround(tileGridSlackY, 0, ent.Name); }}
,"prepareForRenderer":
 function() {return {  };}
,"loadScene":
function() { loadThrentitiesIntoNewScene(this.allThrentities(), this.PointLights); }
,"allThrentities":
function() { return game.active().Omnipresent3D.concat(this.validLocalThrentities()); }
,"validLocalThrentities":
function() { return this.Threntities.filter(function(obj) { return Object.keys(obj).length > 0; }); }
,"getThrentity":
function (index) { var ent = game.active().getOmni3D(index); if (ent != null) { return ent; } var obj = this.Threntities[index]; if (obj == null || Object.keys(obj).length == 0) { return game.active().getOmni3D(index); } else { return this.Threntities[index]; } }
,"allEntities":
function() { return game.active().Omnipresent2D.concat(this.validLocalEntities()); }
,"validLocalEntities":
function() { return this.Entities.filter(function(obj) { return Object.keys(obj).length > 0; }); }
,"getEntity":
function (index) { var ent = game.active().getOmni2D(index); if (ent != null) { return ent; } var obj = this.Entities[index]; if (obj == null || Object.keys(obj).length == 0) { return game.active().getOmni2D(index); } else { return this.Entities[index]; } }
,"getMainTilegrid":
function() { for(var i in this.TileGrids) { if (this.TileGrids[i].MainGrid === true) { return this.TileGrids[i]; } } return -1; }
,"shiftToTop":
function() {  var main = this.getMainTilegrid(); if (main !== -1) { var moveY = main.Y; this.moveAll2D(0, moveY); return moveY; } }
,"shiftToBottom":
function() {  var main = this.getMainTilegrid(); if (main !== -1) { var moveY = -(main.B() - getYDrawBounds2D()); this.moveAll2D(0, moveY); return moveY; } }
,"shiftToRight":
function() { if (this.shiftedToRight == true) {  }  var main = this.getMainTilegrid(); if (main !== -1) {  var moveX = -(main.R() - getXDrawBounds2D()); this.moveAll2D(moveX, 0); this.shiftedToLeft = false; this.shiftedToRight = true; return moveX; } }
,"shiftToLeft":
function() { if (this.shiftedToLeft == true) {  } var main = this.getMainTilegrid(); if (main !== -1) {  var moveX = main.X; this.moveAll2D(moveX, 0);  this.shiftedToLeft = true; this.shiftedToRight = false; return moveX; } }
,"shiftedToLeft":
false
,"shiftedToRight":
false
,"shiftedToTop":
false
,"shiftedToBottom":
false
,"wouldCollide":
 function(entity) {var hasCollide = false;for (var i in this.TileGrids) { if (this.TileGrids[i].wouldCollide(entity) === true) { hasCollide = true; } }var all = this.allEntities(); for (var i in all) { if (all[i].NotWorldLevel !== true && all[i].NonCorporeal !== true && all[i].Disabled !== true && all[i].Name !== entity.name && all[i].wouldCollide(entity)) { hasCollide = true; } }return hasCollide;}
,"isSetup":
false
,"XResolution":640,"YResolution":400,"HasAmbientLight":false,"AmbientLightIntensity":75,"AmbientLightColor":"0xffffcf","Bounds2DX":0,"Bounds2DY":0,"TileGrids":[{"setup":
function(parent) { if (this.DelimitedGrid && this.DelimitedGrid.length > 0){ var rows = this.DelimitedGrid.split(';');for (var j in rows) { this.tiles.push([]); var cells = rows[j].split(',');  for (var i in cells) { var tile=this.getTile(parent, cells[i]); this.tiles[j].push(tile); } } } }
,"getTile":
function(parentScene, tileId) {  var eName = this.EntityNameCSVKey.split(',')[tileId]; var tile = find(parentScene.allEntities(), eName); /* tile.draw = function(x,y,w,h) { this.MyImage.active().render(x,y,w,h); }; */ return tile;  }
,"draw":
function() { if (this.SkipDraw==true) { return; } for(var j in this.tiles) { for(var i in this.tiles[j]) { if (this.tiles[j][i] != null && this.tiles[j][i].MyImage != null) { this.tiles[j][i].MyImage.active().render(this.X + (i * this.TW),this.Y + (j * this.TH),this.TW,this.TH); } } } }
,"update":
 function() {}
,"tiles":
 [] 
,"R":
 function() {return this.X + (this.getWidth() * this.TW);}
,"B":
 function() {return this.Y + (this.getHeight() * this.TH);}
,"wouldCollide":
 function(entity) {for(var j in this.tiles)      {       for (var i in this.tiles[j])       {        if (this.tiles[j][i] != null && this.tiles[j][i].ForceCollision===true)        {         var x = this.X + (i * this.TW);         var y = this.Y + (j * this.TH);         if (checkOverlap({X:x,Y:y,W:this.TW,H:this.TH}, entity) === true)         {          console.log('overlap found');         var events = this.tiles[j][i].collisionEvents;         if (events !== null)         {         }         if (this.tiles[j][i].LedgeCollision === true)         {          if (/*notideal*/downkey() && !leftkey() && !rightkey())          {           console.log('ledge collision detected');           /*arbitrary*/var speed = 4;           /* make entity.MyLogic have a non null ActionBlock? */           entity.Me.MyLogic.ActionBlock.MyActions.push({Depth:((this.TH/speed)*2)+1,SelfDestruct:true,Ct:0,Destroyed:false,update:function() { console.log('updating action');  if (this.BlockInput === true) { BlockInput(); } if (this.SelfDestruct === true && this.Ct + 1 == this.Depth) { this.Destroyed = true; } if (this.Destroyed !== true) { this.MyScript(); this.Ct++; } },MyTarget:entity,BlockInput:true,LocalData:speed,MyScript:function() { console.log('performing action...'); this.MyTarget.Me.Y += this.LocalData; }});          }         }         return true;         }        }       }      }       return false;}
,"getWidth":
function() { if (this.getHeight() > 0) { return this.tiles[0].length; } else { return 0; } }
,"getHeight":
function() { return this.tiles.length; }
,"EntityIndexCSVKey":"","EntityNameCSVKey":"tile1,tile2,tile3,tile4","DelimitedGrid":"0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0","SkipDraw":false,"MainGrid":true,"TW":32,"TH":32,"X":0,"Y":0,"Name":"","LocalData":"","TypeName":"TileGrid","Id":302}],"AdhocSceneRefs":[],"Entities":[{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2184}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2178},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2178},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return true;}
,"imageFilePath":"grass32.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'grass32');}
,"NameOfTarget":"grass32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5992}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2178},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile1","LocalData":"","TypeName":"Entity","Id":2178},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2185}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2179},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2179},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return true;}
,"imageFilePath":"stone32.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'stone32');}
,"NameOfTarget":"stone32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5993}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2179},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile2","LocalData":"","TypeName":"Entity","Id":2179},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2186}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2180},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2180},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":8,"ImageFrames":[{"hasImagePath":
 function() {return true;}
,"imageFilePath":"water1.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water1');}
,"NameOfTarget":"water1","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5994},{"hasImagePath":
 function() {return true;}
,"imageFilePath":"water2.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water2');}
,"NameOfTarget":"water2","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5995},{"hasImagePath":
 function() {return true;}
,"imageFilePath":"water3.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water3');}
,"NameOfTarget":"water3","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5996},{"hasImagePath":
 function() {return true;}
,"imageFilePath":"water4.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water4');}
,"NameOfTarget":"water4","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5997},{"hasImagePath":
 function() {return true;}
,"imageFilePath":"water5.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water5');}
,"NameOfTarget":"water5","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5998},{"hasImagePath":
 function() {return true;}
,"imageFilePath":"water6.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water6');}
,"NameOfTarget":"water6","Name":"","LocalData":"","TypeName":"ImageFrame","Id":5999},{"hasImagePath":
 function() {return true;}
,"imageFilePath":"water7.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water7');}
,"NameOfTarget":"water7","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6000},{"hasImagePath":
 function() {return true;}
,"imageFilePath":"water8.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water8');}
,"NameOfTarget":"water8","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6001},{"hasImagePath":
 function() {return true;}
,"imageFilePath":"water9.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water9');}
,"NameOfTarget":"water9","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6002},{"hasImagePath":
 function() {return true;}
,"imageFilePath":"water10.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water10');}
,"NameOfTarget":"water10","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6003},{"hasImagePath":
 function() {return true;}
,"imageFilePath":"water11.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water11');}
,"NameOfTarget":"water11","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6004},{"hasImagePath":
 function() {return true;}
,"imageFilePath":"water12.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water12');}
,"NameOfTarget":"water12","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6005},{"hasImagePath":
 function() {return true;}
,"imageFilePath":"water13.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water13');}
,"NameOfTarget":"water13","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6006},{"hasImagePath":
 function() {return true;}
,"imageFilePath":"water14.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water14');}
,"NameOfTarget":"water14","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6007},{"hasImagePath":
 function() {return true;}
,"imageFilePath":"water15.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water15');}
,"NameOfTarget":"water15","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6008}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2180},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile3","LocalData":"","TypeName":"Entity","Id":2180},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2187}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2181},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2181},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return true;}
,"imageFilePath":"stoneWall32.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'stoneWall32');}
,"NameOfTarget":"stoneWall32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6009}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2181},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":true,"LedgeCollision":true,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile4","LocalData":"","TypeName":"Entity","Id":2181}],"Threntities":[],"PointLights":[],"MyAudio":[],"MyLogic":{"update":
 function() {for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":null,"TypeName":"SceneProceduralStatement","Id":0},{"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"SceneProceduralStatement","Id":338}],"Name":"","LocalData":"","TypeName":"SceneLogicBox","Id":338},"Name":"","LocalData":"","TypeName":"Scene","Id":338},{"reloadThrentities":
function() { var allT = this.allThrentities(); for(var i in allT) { setupThrentity(allT[i]); } }
,"setup":
 function() {if (this.isSetup !== true) {for(var i in this.TileGrids) { this.TileGrids[i].setup(this); } for(var i in this.PointLights) { this.PointLights[i].setup(this); } if (this.MyAudio !== null) { for (var i = 0; i < this.MyAudio.length; i++) { this.MyAudio[i].setup(); } }if (game.active().Omnipresent2D.length > 0) { var indices = this.entityIndexArray(); var allE = this.allEntities();  for(var i in allE) { if (allE[i].MyIndex != '') { var ind = indices.indexOf(allE[i].MyIndex); if(ind != -1) { indices.splice(ind, 1); } } else { allE[i].setup(indices[i]); } }  } else { for(var i in this.Entities) { this.Entities[i].setup(i); } }if (game.active().Omnipresent3D.length > 0) { var indices = this.threntityIndexArray(); var allT = this.allThrentities(); for(var i in allT) { if (allT[i].MyIndex != '') { var ind = indices.indexOf(allT[i].MyIndex); if (ind != -1) { indices.splice(ind, 1); } } else { allT[i].setup(indices[i]); } }  } else { for(var i in this.Threntities) { this.Threntities[i].setup(i); } }if (this.HasAmbientLight == true) { addAmbientLightToCurrentScene(this.AmbientLightColor, this.AmbientLightIntensity / parseFloat(100)); }this.isSetup = true; }}
,"update":
 function() {this.MyLogic.update();for(var i in this.MyAudio) { this.MyAudio[i].update(); } var allE = this.allEntities(); for(var i in allE) { allE[i].update(); }var allT = this.allThrentities(); for(var i in allT) { allT[i].update(); }for(var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].update(this.AdhocSceneRefs[i].TargetName); } for(var i in this.TileGrids) { this.TileGrids[i].update(); } }
,"draw":
 function() {for(var i in this.TileGrids) { this.TileGrids[i].draw(); } var allE = this.allEntities(); for(var i in allE) { if (allE[i].Disabled !== true) { allE[i].draw(); } }var allT = this.allThrentities(); for(var i in allT) { allT[i].draw(); } }
,"entityIndexArray":
function() { var ray = []; for(var x in game.active().Omnipresent2D) { ray.push(game.active().Omnipresent2D[x].MyIndex); } var rayLen = ray.length; for(i=0;i<rayLen+this.Entities.length;i++) { if (ray.includes((i).toString())) {  } else {  ray.push(i); } } return ray; }
,"threntityIndexArray":
function() { var ray = []; for(var x in game.active().Omnipresent3D) { ray.push(game.active().Omnipresent3D[x].MyIndex); } var rayLen = ray.length; for(i=0;i<rayLen+this.Threntities.length;i++) { if (ray.includes((i).toString())) {  } else {  ray.push(i); } } return ray; }
,"checkMovePoint3d":
function(point3dBefore, point3dAfter) {  var all = this.allThrentities(); for(var i in all) { if (this.checkPointCollision(all[i], point3dBefore, point3dAfter)==true) { return false; } } return true;  }
,"checkPointCollision":
function(targetThrent, point3dBefore, point3dAfter) { var xBef = point3dBefore.X;var xAft = point3dAfter.X;var yBef = point3dBefore.Y;var yAft = point3dAfter.Y;var zBef = point3dBefore.Z;var zAft = point3dAfter.Z;var minX = targetThrent.L();var maxX = targetThrent.R();var minY = targetThrent.B();var maxY = targetThrent.T();var minZ = targetThrent.A();var maxZ = targetThrent.F();var xOverlap = false; var yOverlap = false; var zOverlap = false;if (xBef<xAft) { xOverlap = this.checkRangeOverlap(xBef, xAft, minX, maxX); } else { xOverlap = this.checkRangeOverlap(xAft, xBef, minX, maxX); }if (yBef<yAft) { yOverlap = this.checkRangeOverlap(yBef, yAft, minY, maxY); } else { yOverlap = this.checkRangeOverlap(yAft, yBef, minY, maxY); }if (zBef<zAft) { zOverlap = this.checkRangeOverlap(zBef, zAft, minZ, maxZ); } else { zOverlap = this.checkRangeOverlap(zAft, zBef, minZ, maxZ); }if (xOverlap==true && yOverlap==true && zOverlap==true) { return true; } return false;}
,"checkRangeOverlap":
function (inputOneMin, inputOneMax, inputTwoMin, inputTwoMax) {if (inputOneMin > inputTwoMax || inputOneMax < inputTwoMin) { return false; }return true;}
,"threnCollideContextual":
function(thren, before, after) { var hasCollide = false;var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name) { if (this.ZStraddle(before, after, all[i])===true && this.XStraddle(before, after, all[i])===true && this.YStraddle(before, after, all[i])===true) { hasCollide = true; } if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { hasCollide = true; } } }return hasCollide;}
,"ZStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.Z - before.Z;let secondDiff = target.Z - after.Z;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"XStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.X - before.X;let secondDiff = target.X - after.Y;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"YStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.Y - before.Y;let secondDiff = target.Y - after.Y;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"getFirstThrenCollide":
function(thren) { var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { return thren; } } }
,"threnCollide":
 function(thren) {var hasCollide = false;var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { hasCollide = true; } }return hasCollide;}
,"moveAll2D":
function(x, y) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } for (var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].X += x; this.AdhocSceneRefs[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } }
,"moveAll2DAround":
function(x, y, entName) { var ent = find(game.scene().Entities, entName); if (this.wouldCollide(ent.transpose(-x, -y)) === false) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } } }
,"quickMoveAll2DAround":
function(x, y, ent) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } for(var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].X += x; this.AdhocSceneRefs[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } }
,"tryMoveAll2DAround":
function(x, y, entName) {if (this.getMainTilegrid() === -1) { return this.moveAll2DAround(x, y, entName); } else { this.dynamic2DMove(x, y, entName, this.getMainTilegrid()); } }
,"dynamic2DMove":
function(x, y, entName, tileGrid) {var ent = game.findEntity(entName);if (this.wouldCollide(ent.transpose(-x, -y)) === false) {this.dynamic2DMoveX(x, ent, tileGrid);this.dynamic2DMoveY(y, ent, tileGrid); }}
,"dynamic2DMoveUp":
function(y, ent, tileGrid) {var amtMoveHeroTowardsCenter = (ent.pastCenterY() === false && ent.isCenteredY() === false) ? 0 : (ent.myCenterY() - viewportCenterY());if (amtMoveHeroTowardsCenter >= y) { ent.Y -= y; return; } else { ent.Y -= amtMoveHeroTowardsCenter; }var remainder = y - amtMoveHeroTowardsCenter;var tileGridSlack = 0 - tileGrid.Y;if (remainder <= Math.abs(tileGridSlack)) { this.quickMoveAll2DAround(0, remainder, ent); return; } else { this.quickMoveAll2DAround(0, Math.abs(tileGridSlack), ent); }remainder = remainder - Math.abs(tileGridSlack);ent.Y -= remainder;}
,"dynamic2DMoveDown":
function(y, ent, tileGrid) {var absY = Math.abs(y);var amtMoveHeroTowardsCenter = (ent.isCenteredY() || ent.pastCenterY()) ? 0 : viewportCenterY() - ent.myCenterY();if (amtMoveHeroTowardsCenter >= absY) { ent.Y -= y; return; } else { ent.Y += amtMoveHeroTowardsCenter; }var remainder = absY - amtMoveHeroTowardsCenter;var tileGridSlack = tileGrid.B() - getYDrawBounds2D();if (remainder <= tileGridSlack) { this.quickMoveAll2DAround(0, -remainder, ent); return; } else { this.quickMoveAll2DAround(0, tileGridSlack, ent); }remainder = remainder - tileGridSlack;ent.Y += remainder;}
,"dynamic2DMoveLeft":
function(x, ent, tileGrid) {var amtMoveHeroTowardsCenter = (ent.pastCenterX() === false && ent.isCenteredX() === false) ? 0 : (ent.myCenterX() - viewportCenterX());if (amtMoveHeroTowardsCenter >= x) { ent.X -= x; return; } else { ent.X -= amtMoveHeroTowardsCenter; }var remainder = x - amtMoveHeroTowardsCenter;var tileGridSlack = 0 - tileGrid.X;if (remainder <= Math.abs(tileGridSlack)) { this.quickMoveAll2DAround(remainder, 0, ent); return; } else { this.quickMoveAll2DAround(Math.abs(tileGridSlack), 0, ent); }remainder = remainder - Math.abs(tileGridSlack);ent.X -= remainder;}
,"dynamic2DMoveRight":
function(x, ent, tileGrid) {var absX = Math.abs(x);var amtMoveHeroTowardsCenter = (ent.isCenteredX() || ent.pastCenterX()) ? 0 : viewportCenterX() - ent.myCenterX();if (amtMoveHeroTowardsCenter >= absX) { ent.X -= x; return; } else { ent.X += amtMoveHeroTowardsCenter; }var remainder = absX - amtMoveHeroTowardsCenter;var tileGridSlack = tileGrid.R() - getXDrawBounds2D();if (remainder <= tileGridSlack) { this.quickMoveAll2DAround(-remainder, 0, ent); return; } else { this.quickMoveAll2DAround(tileGridSlack, 0, ent); }remainder = remainder - tileGridSlack;ent.X += remainder;}
,"dynamic2DMoveX":
function(x, ent, tileGrid) { var movingLeft = x > 0;if (movingLeft) { this.dynamic2DMoveLeft(x, ent, tileGrid); return; } else { this.dynamic2DMoveRight(x, ent, tileGrid); return; }var tileGridSlackX = x < 0 ? -1 * tileGrid.X : tileGrid.R() - getXDrawBounds2D(); if (ent.isCenteredX() !== true) { var centerSlackX = (x < 0 ? ((getXDrawBounds2D() / 2) - ent.X) : ent.X - (getXDrawBounds2D() / 2)); if (centerSlackX > Math.abs(x)) { ent.X -= x; }else if (centerSlackX < Math.abs(x) && centerSlackX > 0) { ent.X -= centerSlackX; }  }else if (tileGridSlackX > Math.abs(x)) { this.moveAll2DAround(x, 0, ent.Name); }else if (tileGridSlackX < Math.abs(x) && tileGridSlackX > 0) { this.moveAll2DAround(tileGridSlackX, 0, ent.Name); }}
,"dynamic2DMoveY":
function(y, ent, tileGrid) { var movingUp = y > 0;if (movingUp) { this.dynamic2DMoveUp(y, ent, tileGrid); return; } else { this.dynamic2DMoveDown(y, ent, tileGrid); return; }var tileGridSlackY = y < 0 ? -1 * tileGrid.Y : tileGrid.B() - getYDrawBounds2D();if (ent.isCenteredY() !== true) { var centerSlackY = (y < 0 ? ((getYDrawBounds2D() / 2) - ent.Y) : ent.Y - (getYDrawBounds2D() / 2)); if (centerSlackY > Math.abs(y)) { ent.Y -= y; }else if (centerSlackY < Math.abs(y) && centerSlackY > 0) { ent.Y -= centerSlackY; }  }else if (tileGridSlackY > Math.abs(y)) { this.moveAll2DAround(y, 0, ent.Name); }else if (tileGridSlackY < Math.abs(y) && tileGridSlackY > 0) { this.moveAll2DAround(tileGridSlackY, 0, ent.Name); }}
,"prepareForRenderer":
 function() {return {  };}
,"loadScene":
function() { loadThrentitiesIntoNewScene(this.allThrentities(), this.PointLights); }
,"allThrentities":
function() { return game.active().Omnipresent3D.concat(this.validLocalThrentities()); }
,"validLocalThrentities":
function() { return this.Threntities.filter(function(obj) { return Object.keys(obj).length > 0; }); }
,"getThrentity":
function (index) { var ent = game.active().getOmni3D(index); if (ent != null) { return ent; } var obj = this.Threntities[index]; if (obj == null || Object.keys(obj).length == 0) { return game.active().getOmni3D(index); } else { return this.Threntities[index]; } }
,"allEntities":
function() { return game.active().Omnipresent2D.concat(this.validLocalEntities()); }
,"validLocalEntities":
function() { return this.Entities.filter(function(obj) { return Object.keys(obj).length > 0; }); }
,"getEntity":
function (index) { var ent = game.active().getOmni2D(index); if (ent != null) { return ent; } var obj = this.Entities[index]; if (obj == null || Object.keys(obj).length == 0) { return game.active().getOmni2D(index); } else { return this.Entities[index]; } }
,"getMainTilegrid":
function() { for(var i in this.TileGrids) { if (this.TileGrids[i].MainGrid === true) { return this.TileGrids[i]; } } return -1; }
,"shiftToTop":
function() {  var main = this.getMainTilegrid(); if (main !== -1) { var moveY = main.Y; this.moveAll2D(0, moveY); return moveY; } }
,"shiftToBottom":
function() {  var main = this.getMainTilegrid(); if (main !== -1) { var moveY = -(main.B() - getYDrawBounds2D()); this.moveAll2D(0, moveY); return moveY; } }
,"shiftToRight":
function() { if (this.shiftedToRight == true) {  }  var main = this.getMainTilegrid(); if (main !== -1) {  var moveX = -(main.R() - getXDrawBounds2D()); this.moveAll2D(moveX, 0); this.shiftedToLeft = false; this.shiftedToRight = true; return moveX; } }
,"shiftToLeft":
function() { if (this.shiftedToLeft == true) {  } var main = this.getMainTilegrid(); if (main !== -1) {  var moveX = main.X; this.moveAll2D(moveX, 0);  this.shiftedToLeft = true; this.shiftedToRight = false; return moveX; } }
,"shiftedToLeft":
false
,"shiftedToRight":
false
,"shiftedToTop":
false
,"shiftedToBottom":
false
,"wouldCollide":
 function(entity) {var hasCollide = false;for (var i in this.TileGrids) { if (this.TileGrids[i].wouldCollide(entity) === true) { hasCollide = true; } }var all = this.allEntities(); for (var i in all) { if (all[i].NotWorldLevel !== true && all[i].NonCorporeal !== true && all[i].Disabled !== true && all[i].Name !== entity.name && all[i].wouldCollide(entity)) { hasCollide = true; } }return hasCollide;}
,"isSetup":
false
,"XResolution":640,"YResolution":400,"HasAmbientLight":false,"AmbientLightIntensity":75,"AmbientLightColor":"0xffffcf","Bounds2DX":0,"Bounds2DY":0,"TileGrids":[{"setup":
function(parent) { if (this.DelimitedGrid && this.DelimitedGrid.length > 0){ var rows = this.DelimitedGrid.split(';');for (var j in rows) { this.tiles.push([]); var cells = rows[j].split(',');  for (var i in cells) { var tile=this.getTile(parent, cells[i]); this.tiles[j].push(tile); } } } }
,"getTile":
function(parentScene, tileId) {  var eName = this.EntityNameCSVKey.split(',')[tileId]; var tile = find(parentScene.allEntities(), eName); /* tile.draw = function(x,y,w,h) { this.MyImage.active().render(x,y,w,h); }; */ return tile;  }
,"draw":
function() { if (this.SkipDraw==true) { return; } for(var j in this.tiles) { for(var i in this.tiles[j]) { if (this.tiles[j][i] != null && this.tiles[j][i].MyImage != null) { this.tiles[j][i].MyImage.active().render(this.X + (i * this.TW),this.Y + (j * this.TH),this.TW,this.TH); } } } }
,"update":
 function() {}
,"tiles":
 [] 
,"R":
 function() {return this.X + (this.getWidth() * this.TW);}
,"B":
 function() {return this.Y + (this.getHeight() * this.TH);}
,"wouldCollide":
 function(entity) {for(var j in this.tiles)      {       for (var i in this.tiles[j])       {        if (this.tiles[j][i] != null && this.tiles[j][i].ForceCollision===true)        {         var x = this.X + (i * this.TW);         var y = this.Y + (j * this.TH);         if (checkOverlap({X:x,Y:y,W:this.TW,H:this.TH}, entity) === true)         {          console.log('overlap found');         var events = this.tiles[j][i].collisionEvents;         if (events !== null)         {         }         if (this.tiles[j][i].LedgeCollision === true)         {          if (/*notideal*/downkey() && !leftkey() && !rightkey())          {           console.log('ledge collision detected');           /*arbitrary*/var speed = 4;           /* make entity.MyLogic have a non null ActionBlock? */           entity.Me.MyLogic.ActionBlock.MyActions.push({Depth:((this.TH/speed)*2)+1,SelfDestruct:true,Ct:0,Destroyed:false,update:function() { console.log('updating action');  if (this.BlockInput === true) { BlockInput(); } if (this.SelfDestruct === true && this.Ct + 1 == this.Depth) { this.Destroyed = true; } if (this.Destroyed !== true) { this.MyScript(); this.Ct++; } },MyTarget:entity,BlockInput:true,LocalData:speed,MyScript:function() { console.log('performing action...'); this.MyTarget.Me.Y += this.LocalData; }});          }         }         return true;         }        }       }      }       return false;}
,"getWidth":
function() { if (this.getHeight() > 0) { return this.tiles[0].length; } else { return 0; } }
,"getHeight":
function() { return this.tiles.length; }
,"EntityIndexCSVKey":"","EntityNameCSVKey":"tile1,tile2,tile3,tile4","DelimitedGrid":"0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0","SkipDraw":false,"MainGrid":true,"TW":32,"TH":32,"X":0,"Y":0,"Name":"","LocalData":"","TypeName":"TileGrid","Id":303}],"AdhocSceneRefs":[],"Entities":[{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2188}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2182},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2182},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'grass32');}
,"NameOfTarget":"grass32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6010}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2182},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile1","LocalData":"","TypeName":"Entity","Id":2182},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2189}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2183},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2183},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'stone32');}
,"NameOfTarget":"stone32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6011}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2183},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile2","LocalData":"","TypeName":"Entity","Id":2183},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2190}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2184},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2184},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":8,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water1');}
,"NameOfTarget":"water1","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6012},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water2');}
,"NameOfTarget":"water2","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6013},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water3');}
,"NameOfTarget":"water3","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6014},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water4');}
,"NameOfTarget":"water4","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6015},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water5');}
,"NameOfTarget":"water5","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6016},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water6');}
,"NameOfTarget":"water6","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6017},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water7');}
,"NameOfTarget":"water7","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6018},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water8');}
,"NameOfTarget":"water8","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6019},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water9');}
,"NameOfTarget":"water9","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6020},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water10');}
,"NameOfTarget":"water10","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6021},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water11');}
,"NameOfTarget":"water11","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6022},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water12');}
,"NameOfTarget":"water12","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6023},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water13');}
,"NameOfTarget":"water13","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6024},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water14');}
,"NameOfTarget":"water14","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6025},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water15');}
,"NameOfTarget":"water15","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6026}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2184},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile3","LocalData":"","TypeName":"Entity","Id":2184},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2191}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2185},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2185},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'stoneWall32');}
,"NameOfTarget":"stoneWall32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6027}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2185},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":true,"LedgeCollision":true,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile4","LocalData":"","TypeName":"Entity","Id":2185}],"Threntities":[],"PointLights":[],"MyAudio":[],"MyLogic":{"update":
 function() {for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":null,"TypeName":"SceneProceduralStatement","Id":0},{"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"SceneProceduralStatement","Id":339}],"Name":"","LocalData":"","TypeName":"SceneLogicBox","Id":339},"Name":"","LocalData":"","TypeName":"Scene","Id":339},{"reloadThrentities":
function() { var allT = this.allThrentities(); for(var i in allT) { setupThrentity(allT[i]); } }
,"setup":
 function() {if (this.isSetup !== true) {for(var i in this.TileGrids) { this.TileGrids[i].setup(this); } for(var i in this.PointLights) { this.PointLights[i].setup(this); } if (this.MyAudio !== null) { for (var i = 0; i < this.MyAudio.length; i++) { this.MyAudio[i].setup(); } }if (game.active().Omnipresent2D.length > 0) { var indices = this.entityIndexArray(); var allE = this.allEntities();  for(var i in allE) { if (allE[i].MyIndex != '') { var ind = indices.indexOf(allE[i].MyIndex); if(ind != -1) { indices.splice(ind, 1); } } else { allE[i].setup(indices[i]); } }  } else { for(var i in this.Entities) { this.Entities[i].setup(i); } }if (game.active().Omnipresent3D.length > 0) { var indices = this.threntityIndexArray(); var allT = this.allThrentities(); for(var i in allT) { if (allT[i].MyIndex != '') { var ind = indices.indexOf(allT[i].MyIndex); if (ind != -1) { indices.splice(ind, 1); } } else { allT[i].setup(indices[i]); } }  } else { for(var i in this.Threntities) { this.Threntities[i].setup(i); } }if (this.HasAmbientLight == true) { addAmbientLightToCurrentScene(this.AmbientLightColor, this.AmbientLightIntensity / parseFloat(100)); }this.isSetup = true; }}
,"update":
 function() {this.MyLogic.update();for(var i in this.MyAudio) { this.MyAudio[i].update(); } var allE = this.allEntities(); for(var i in allE) { allE[i].update(); }var allT = this.allThrentities(); for(var i in allT) { allT[i].update(); }for(var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].update(this.AdhocSceneRefs[i].TargetName); } for(var i in this.TileGrids) { this.TileGrids[i].update(); } }
,"draw":
 function() {for(var i in this.TileGrids) { this.TileGrids[i].draw(); } var allE = this.allEntities(); for(var i in allE) { if (allE[i].Disabled !== true) { allE[i].draw(); } }var allT = this.allThrentities(); for(var i in allT) { allT[i].draw(); } }
,"entityIndexArray":
function() { var ray = []; for(var x in game.active().Omnipresent2D) { ray.push(game.active().Omnipresent2D[x].MyIndex); } var rayLen = ray.length; for(i=0;i<rayLen+this.Entities.length;i++) { if (ray.includes((i).toString())) {  } else {  ray.push(i); } } return ray; }
,"threntityIndexArray":
function() { var ray = []; for(var x in game.active().Omnipresent3D) { ray.push(game.active().Omnipresent3D[x].MyIndex); } var rayLen = ray.length; for(i=0;i<rayLen+this.Threntities.length;i++) { if (ray.includes((i).toString())) {  } else {  ray.push(i); } } return ray; }
,"checkMovePoint3d":
function(point3dBefore, point3dAfter) {  var all = this.allThrentities(); for(var i in all) { if (this.checkPointCollision(all[i], point3dBefore, point3dAfter)==true) { return false; } } return true;  }
,"checkPointCollision":
function(targetThrent, point3dBefore, point3dAfter) { var xBef = point3dBefore.X;var xAft = point3dAfter.X;var yBef = point3dBefore.Y;var yAft = point3dAfter.Y;var zBef = point3dBefore.Z;var zAft = point3dAfter.Z;var minX = targetThrent.L();var maxX = targetThrent.R();var minY = targetThrent.B();var maxY = targetThrent.T();var minZ = targetThrent.A();var maxZ = targetThrent.F();var xOverlap = false; var yOverlap = false; var zOverlap = false;if (xBef<xAft) { xOverlap = this.checkRangeOverlap(xBef, xAft, minX, maxX); } else { xOverlap = this.checkRangeOverlap(xAft, xBef, minX, maxX); }if (yBef<yAft) { yOverlap = this.checkRangeOverlap(yBef, yAft, minY, maxY); } else { yOverlap = this.checkRangeOverlap(yAft, yBef, minY, maxY); }if (zBef<zAft) { zOverlap = this.checkRangeOverlap(zBef, zAft, minZ, maxZ); } else { zOverlap = this.checkRangeOverlap(zAft, zBef, minZ, maxZ); }if (xOverlap==true && yOverlap==true && zOverlap==true) { return true; } return false;}
,"checkRangeOverlap":
function (inputOneMin, inputOneMax, inputTwoMin, inputTwoMax) {if (inputOneMin > inputTwoMax || inputOneMax < inputTwoMin) { return false; }return true;}
,"threnCollideContextual":
function(thren, before, after) { var hasCollide = false;var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name) { if (this.ZStraddle(before, after, all[i])===true && this.XStraddle(before, after, all[i])===true && this.YStraddle(before, after, all[i])===true) { hasCollide = true; } if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { hasCollide = true; } } }return hasCollide;}
,"ZStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.Z - before.Z;let secondDiff = target.Z - after.Z;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"XStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.X - before.X;let secondDiff = target.X - after.Y;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"YStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.Y - before.Y;let secondDiff = target.Y - after.Y;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"getFirstThrenCollide":
function(thren) { var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { return thren; } } }
,"threnCollide":
 function(thren) {var hasCollide = false;var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { hasCollide = true; } }return hasCollide;}
,"moveAll2D":
function(x, y) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } for (var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].X += x; this.AdhocSceneRefs[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } }
,"moveAll2DAround":
function(x, y, entName) { var ent = find(game.scene().Entities, entName); if (this.wouldCollide(ent.transpose(-x, -y)) === false) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } } }
,"quickMoveAll2DAround":
function(x, y, ent) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } for(var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].X += x; this.AdhocSceneRefs[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } }
,"tryMoveAll2DAround":
function(x, y, entName) {if (this.getMainTilegrid() === -1) { return this.moveAll2DAround(x, y, entName); } else { this.dynamic2DMove(x, y, entName, this.getMainTilegrid()); } }
,"dynamic2DMove":
function(x, y, entName, tileGrid) {var ent = game.findEntity(entName);if (this.wouldCollide(ent.transpose(-x, -y)) === false) {this.dynamic2DMoveX(x, ent, tileGrid);this.dynamic2DMoveY(y, ent, tileGrid); }}
,"dynamic2DMoveUp":
function(y, ent, tileGrid) {var amtMoveHeroTowardsCenter = (ent.pastCenterY() === false && ent.isCenteredY() === false) ? 0 : (ent.myCenterY() - viewportCenterY());if (amtMoveHeroTowardsCenter >= y) { ent.Y -= y; return; } else { ent.Y -= amtMoveHeroTowardsCenter; }var remainder = y - amtMoveHeroTowardsCenter;var tileGridSlack = 0 - tileGrid.Y;if (remainder <= Math.abs(tileGridSlack)) { this.quickMoveAll2DAround(0, remainder, ent); return; } else { this.quickMoveAll2DAround(0, Math.abs(tileGridSlack), ent); }remainder = remainder - Math.abs(tileGridSlack);ent.Y -= remainder;}
,"dynamic2DMoveDown":
function(y, ent, tileGrid) {var absY = Math.abs(y);var amtMoveHeroTowardsCenter = (ent.isCenteredY() || ent.pastCenterY()) ? 0 : viewportCenterY() - ent.myCenterY();if (amtMoveHeroTowardsCenter >= absY) { ent.Y -= y; return; } else { ent.Y += amtMoveHeroTowardsCenter; }var remainder = absY - amtMoveHeroTowardsCenter;var tileGridSlack = tileGrid.B() - getYDrawBounds2D();if (remainder <= tileGridSlack) { this.quickMoveAll2DAround(0, -remainder, ent); return; } else { this.quickMoveAll2DAround(0, tileGridSlack, ent); }remainder = remainder - tileGridSlack;ent.Y += remainder;}
,"dynamic2DMoveLeft":
function(x, ent, tileGrid) {var amtMoveHeroTowardsCenter = (ent.pastCenterX() === false && ent.isCenteredX() === false) ? 0 : (ent.myCenterX() - viewportCenterX());if (amtMoveHeroTowardsCenter >= x) { ent.X -= x; return; } else { ent.X -= amtMoveHeroTowardsCenter; }var remainder = x - amtMoveHeroTowardsCenter;var tileGridSlack = 0 - tileGrid.X;if (remainder <= Math.abs(tileGridSlack)) { this.quickMoveAll2DAround(remainder, 0, ent); return; } else { this.quickMoveAll2DAround(Math.abs(tileGridSlack), 0, ent); }remainder = remainder - Math.abs(tileGridSlack);ent.X -= remainder;}
,"dynamic2DMoveRight":
function(x, ent, tileGrid) {var absX = Math.abs(x);var amtMoveHeroTowardsCenter = (ent.isCenteredX() || ent.pastCenterX()) ? 0 : viewportCenterX() - ent.myCenterX();if (amtMoveHeroTowardsCenter >= absX) { ent.X -= x; return; } else { ent.X += amtMoveHeroTowardsCenter; }var remainder = absX - amtMoveHeroTowardsCenter;var tileGridSlack = tileGrid.R() - getXDrawBounds2D();if (remainder <= tileGridSlack) { this.quickMoveAll2DAround(-remainder, 0, ent); return; } else { this.quickMoveAll2DAround(tileGridSlack, 0, ent); }remainder = remainder - tileGridSlack;ent.X += remainder;}
,"dynamic2DMoveX":
function(x, ent, tileGrid) { var movingLeft = x > 0;if (movingLeft) { this.dynamic2DMoveLeft(x, ent, tileGrid); return; } else { this.dynamic2DMoveRight(x, ent, tileGrid); return; }var tileGridSlackX = x < 0 ? -1 * tileGrid.X : tileGrid.R() - getXDrawBounds2D(); if (ent.isCenteredX() !== true) { var centerSlackX = (x < 0 ? ((getXDrawBounds2D() / 2) - ent.X) : ent.X - (getXDrawBounds2D() / 2)); if (centerSlackX > Math.abs(x)) { ent.X -= x; }else if (centerSlackX < Math.abs(x) && centerSlackX > 0) { ent.X -= centerSlackX; }  }else if (tileGridSlackX > Math.abs(x)) { this.moveAll2DAround(x, 0, ent.Name); }else if (tileGridSlackX < Math.abs(x) && tileGridSlackX > 0) { this.moveAll2DAround(tileGridSlackX, 0, ent.Name); }}
,"dynamic2DMoveY":
function(y, ent, tileGrid) { var movingUp = y > 0;if (movingUp) { this.dynamic2DMoveUp(y, ent, tileGrid); return; } else { this.dynamic2DMoveDown(y, ent, tileGrid); return; }var tileGridSlackY = y < 0 ? -1 * tileGrid.Y : tileGrid.B() - getYDrawBounds2D();if (ent.isCenteredY() !== true) { var centerSlackY = (y < 0 ? ((getYDrawBounds2D() / 2) - ent.Y) : ent.Y - (getYDrawBounds2D() / 2)); if (centerSlackY > Math.abs(y)) { ent.Y -= y; }else if (centerSlackY < Math.abs(y) && centerSlackY > 0) { ent.Y -= centerSlackY; }  }else if (tileGridSlackY > Math.abs(y)) { this.moveAll2DAround(y, 0, ent.Name); }else if (tileGridSlackY < Math.abs(y) && tileGridSlackY > 0) { this.moveAll2DAround(tileGridSlackY, 0, ent.Name); }}
,"prepareForRenderer":
 function() {return {  };}
,"loadScene":
function() { loadThrentitiesIntoNewScene(this.allThrentities(), this.PointLights); }
,"allThrentities":
function() { return game.active().Omnipresent3D.concat(this.validLocalThrentities()); }
,"validLocalThrentities":
function() { return this.Threntities.filter(function(obj) { return Object.keys(obj).length > 0; }); }
,"getThrentity":
function (index) { var ent = game.active().getOmni3D(index); if (ent != null) { return ent; } var obj = this.Threntities[index]; if (obj == null || Object.keys(obj).length == 0) { return game.active().getOmni3D(index); } else { return this.Threntities[index]; } }
,"allEntities":
function() { return game.active().Omnipresent2D.concat(this.validLocalEntities()); }
,"validLocalEntities":
function() { return this.Entities.filter(function(obj) { return Object.keys(obj).length > 0; }); }
,"getEntity":
function (index) { var ent = game.active().getOmni2D(index); if (ent != null) { return ent; } var obj = this.Entities[index]; if (obj == null || Object.keys(obj).length == 0) { return game.active().getOmni2D(index); } else { return this.Entities[index]; } }
,"getMainTilegrid":
function() { for(var i in this.TileGrids) { if (this.TileGrids[i].MainGrid === true) { return this.TileGrids[i]; } } return -1; }
,"shiftToTop":
function() {  var main = this.getMainTilegrid(); if (main !== -1) { var moveY = main.Y; this.moveAll2D(0, moveY); return moveY; } }
,"shiftToBottom":
function() {  var main = this.getMainTilegrid(); if (main !== -1) { var moveY = -(main.B() - getYDrawBounds2D()); this.moveAll2D(0, moveY); return moveY; } }
,"shiftToRight":
function() { if (this.shiftedToRight == true) {  }  var main = this.getMainTilegrid(); if (main !== -1) {  var moveX = -(main.R() - getXDrawBounds2D()); this.moveAll2D(moveX, 0); this.shiftedToLeft = false; this.shiftedToRight = true; return moveX; } }
,"shiftToLeft":
function() { if (this.shiftedToLeft == true) {  } var main = this.getMainTilegrid(); if (main !== -1) {  var moveX = main.X; this.moveAll2D(moveX, 0);  this.shiftedToLeft = true; this.shiftedToRight = false; return moveX; } }
,"shiftedToLeft":
false
,"shiftedToRight":
false
,"shiftedToTop":
false
,"shiftedToBottom":
false
,"wouldCollide":
 function(entity) {var hasCollide = false;for (var i in this.TileGrids) { if (this.TileGrids[i].wouldCollide(entity) === true) { hasCollide = true; } }var all = this.allEntities(); for (var i in all) { if (all[i].NotWorldLevel !== true && all[i].NonCorporeal !== true && all[i].Disabled !== true && all[i].Name !== entity.name && all[i].wouldCollide(entity)) { hasCollide = true; } }return hasCollide;}
,"isSetup":
false
,"XResolution":640,"YResolution":400,"HasAmbientLight":false,"AmbientLightIntensity":75,"AmbientLightColor":"0xffffcf","Bounds2DX":0,"Bounds2DY":0,"TileGrids":[{"setup":
function(parent) { if (this.DelimitedGrid && this.DelimitedGrid.length > 0){ var rows = this.DelimitedGrid.split(';');for (var j in rows) { this.tiles.push([]); var cells = rows[j].split(',');  for (var i in cells) { var tile=this.getTile(parent, cells[i]); this.tiles[j].push(tile); } } } }
,"getTile":
function(parentScene, tileId) {  var eName = this.EntityNameCSVKey.split(',')[tileId]; var tile = find(parentScene.allEntities(), eName); /* tile.draw = function(x,y,w,h) { this.MyImage.active().render(x,y,w,h); }; */ return tile;  }
,"draw":
function() { if (this.SkipDraw==true) { return; } for(var j in this.tiles) { for(var i in this.tiles[j]) { if (this.tiles[j][i] != null && this.tiles[j][i].MyImage != null) { this.tiles[j][i].MyImage.active().render(this.X + (i * this.TW),this.Y + (j * this.TH),this.TW,this.TH); } } } }
,"update":
 function() {}
,"tiles":
 [] 
,"R":
 function() {return this.X + (this.getWidth() * this.TW);}
,"B":
 function() {return this.Y + (this.getHeight() * this.TH);}
,"wouldCollide":
 function(entity) {for(var j in this.tiles)      {       for (var i in this.tiles[j])       {        if (this.tiles[j][i] != null && this.tiles[j][i].ForceCollision===true)        {         var x = this.X + (i * this.TW);         var y = this.Y + (j * this.TH);         if (checkOverlap({X:x,Y:y,W:this.TW,H:this.TH}, entity) === true)         {          console.log('overlap found');         var events = this.tiles[j][i].collisionEvents;         if (events !== null)         {         }         if (this.tiles[j][i].LedgeCollision === true)         {          if (/*notideal*/downkey() && !leftkey() && !rightkey())          {           console.log('ledge collision detected');           /*arbitrary*/var speed = 4;           /* make entity.MyLogic have a non null ActionBlock? */           entity.Me.MyLogic.ActionBlock.MyActions.push({Depth:((this.TH/speed)*2)+1,SelfDestruct:true,Ct:0,Destroyed:false,update:function() { console.log('updating action');  if (this.BlockInput === true) { BlockInput(); } if (this.SelfDestruct === true && this.Ct + 1 == this.Depth) { this.Destroyed = true; } if (this.Destroyed !== true) { this.MyScript(); this.Ct++; } },MyTarget:entity,BlockInput:true,LocalData:speed,MyScript:function() { console.log('performing action...'); this.MyTarget.Me.Y += this.LocalData; }});          }         }         return true;         }        }       }      }       return false;}
,"getWidth":
function() { if (this.getHeight() > 0) { return this.tiles[0].length; } else { return 0; } }
,"getHeight":
function() { return this.tiles.length; }
,"EntityIndexCSVKey":"","EntityNameCSVKey":"tile1,tile2,tile3,tile4","DelimitedGrid":"0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0","SkipDraw":false,"MainGrid":true,"TW":32,"TH":32,"X":0,"Y":0,"Name":"","LocalData":"","TypeName":"TileGrid","Id":304}],"AdhocSceneRefs":[],"Entities":[{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2192}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2186},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2186},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'grass32');}
,"NameOfTarget":"grass32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6028}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2186},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile1","LocalData":"","TypeName":"Entity","Id":2186},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2193}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2187},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2187},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'stone32');}
,"NameOfTarget":"stone32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6029}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2187},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile2","LocalData":"","TypeName":"Entity","Id":2187},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2194}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2188},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2188},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":8,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water3');}
,"NameOfTarget":"water3","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6032},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water4');}
,"NameOfTarget":"water4","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6033},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water5');}
,"NameOfTarget":"water5","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6034},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water6');}
,"NameOfTarget":"water6","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6035},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water7');}
,"NameOfTarget":"water7","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6036},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water8');}
,"NameOfTarget":"water8","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6037},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water9');}
,"NameOfTarget":"water9","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6038},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water10');}
,"NameOfTarget":"water10","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6039},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water11');}
,"NameOfTarget":"water11","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6040},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water12');}
,"NameOfTarget":"water12","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6041},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water13');}
,"NameOfTarget":"water13","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6042},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water14');}
,"NameOfTarget":"water14","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6043},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water15');}
,"NameOfTarget":"water15","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6044},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water1');}
,"NameOfTarget":"water1","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6030},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water2');}
,"NameOfTarget":"water2","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6031}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2188},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile3","LocalData":"","TypeName":"Entity","Id":2188},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2195}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2189},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2189},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'stoneWall32');}
,"NameOfTarget":"stoneWall32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6045}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2189},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":true,"LedgeCollision":true,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile4","LocalData":"","TypeName":"Entity","Id":2189}],"Threntities":[],"PointLights":[],"MyAudio":[],"MyLogic":{"update":
 function() {for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":null,"TypeName":"SceneProceduralStatement","Id":0},{"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"SceneProceduralStatement","Id":340}],"Name":"","LocalData":"","TypeName":"SceneLogicBox","Id":340},"Name":"","LocalData":"","TypeName":"Scene","Id":340},{"reloadThrentities":
function() { var allT = this.allThrentities(); for(var i in allT) { setupThrentity(allT[i]); } }
,"setup":
 function() {if (this.isSetup !== true) {for(var i in this.TileGrids) { this.TileGrids[i].setup(this); } for(var i in this.PointLights) { this.PointLights[i].setup(this); } if (this.MyAudio !== null) { for (var i = 0; i < this.MyAudio.length; i++) { this.MyAudio[i].setup(); } }if (game.active().Omnipresent2D.length > 0) { var indices = this.entityIndexArray(); var allE = this.allEntities();  for(var i in allE) { if (allE[i].MyIndex != '') { var ind = indices.indexOf(allE[i].MyIndex); if(ind != -1) { indices.splice(ind, 1); } } else { allE[i].setup(indices[i]); } }  } else { for(var i in this.Entities) { this.Entities[i].setup(i); } }if (game.active().Omnipresent3D.length > 0) { var indices = this.threntityIndexArray(); var allT = this.allThrentities(); for(var i in allT) { if (allT[i].MyIndex != '') { var ind = indices.indexOf(allT[i].MyIndex); if (ind != -1) { indices.splice(ind, 1); } } else { allT[i].setup(indices[i]); } }  } else { for(var i in this.Threntities) { this.Threntities[i].setup(i); } }if (this.HasAmbientLight == true) { addAmbientLightToCurrentScene(this.AmbientLightColor, this.AmbientLightIntensity / parseFloat(100)); }this.isSetup = true; }}
,"update":
 function() {this.MyLogic.update();for(var i in this.MyAudio) { this.MyAudio[i].update(); } var allE = this.allEntities(); for(var i in allE) { allE[i].update(); }var allT = this.allThrentities(); for(var i in allT) { allT[i].update(); }for(var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].update(this.AdhocSceneRefs[i].TargetName); } for(var i in this.TileGrids) { this.TileGrids[i].update(); } }
,"draw":
 function() {for(var i in this.TileGrids) { this.TileGrids[i].draw(); } var allE = this.allEntities(); for(var i in allE) { if (allE[i].Disabled !== true) { allE[i].draw(); } }var allT = this.allThrentities(); for(var i in allT) { allT[i].draw(); } }
,"entityIndexArray":
function() { var ray = []; for(var x in game.active().Omnipresent2D) { ray.push(game.active().Omnipresent2D[x].MyIndex); } var rayLen = ray.length; for(i=0;i<rayLen+this.Entities.length;i++) { if (ray.includes((i).toString())) {  } else {  ray.push(i); } } return ray; }
,"threntityIndexArray":
function() { var ray = []; for(var x in game.active().Omnipresent3D) { ray.push(game.active().Omnipresent3D[x].MyIndex); } var rayLen = ray.length; for(i=0;i<rayLen+this.Threntities.length;i++) { if (ray.includes((i).toString())) {  } else {  ray.push(i); } } return ray; }
,"checkMovePoint3d":
function(point3dBefore, point3dAfter) {  var all = this.allThrentities(); for(var i in all) { if (this.checkPointCollision(all[i], point3dBefore, point3dAfter)==true) { return false; } } return true;  }
,"checkPointCollision":
function(targetThrent, point3dBefore, point3dAfter) { var xBef = point3dBefore.X;var xAft = point3dAfter.X;var yBef = point3dBefore.Y;var yAft = point3dAfter.Y;var zBef = point3dBefore.Z;var zAft = point3dAfter.Z;var minX = targetThrent.L();var maxX = targetThrent.R();var minY = targetThrent.B();var maxY = targetThrent.T();var minZ = targetThrent.A();var maxZ = targetThrent.F();var xOverlap = false; var yOverlap = false; var zOverlap = false;if (xBef<xAft) { xOverlap = this.checkRangeOverlap(xBef, xAft, minX, maxX); } else { xOverlap = this.checkRangeOverlap(xAft, xBef, minX, maxX); }if (yBef<yAft) { yOverlap = this.checkRangeOverlap(yBef, yAft, minY, maxY); } else { yOverlap = this.checkRangeOverlap(yAft, yBef, minY, maxY); }if (zBef<zAft) { zOverlap = this.checkRangeOverlap(zBef, zAft, minZ, maxZ); } else { zOverlap = this.checkRangeOverlap(zAft, zBef, minZ, maxZ); }if (xOverlap==true && yOverlap==true && zOverlap==true) { return true; } return false;}
,"checkRangeOverlap":
function (inputOneMin, inputOneMax, inputTwoMin, inputTwoMax) {if (inputOneMin > inputTwoMax || inputOneMax < inputTwoMin) { return false; }return true;}
,"threnCollideContextual":
function(thren, before, after) { var hasCollide = false;var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name) { if (this.ZStraddle(before, after, all[i])===true && this.XStraddle(before, after, all[i])===true && this.YStraddle(before, after, all[i])===true) { hasCollide = true; } if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { hasCollide = true; } } }return hasCollide;}
,"ZStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.Z - before.Z;let secondDiff = target.Z - after.Z;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"XStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.X - before.X;let secondDiff = target.X - after.Y;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"YStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.Y - before.Y;let secondDiff = target.Y - after.Y;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"getFirstThrenCollide":
function(thren) { var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { return thren; } } }
,"threnCollide":
 function(thren) {var hasCollide = false;var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { hasCollide = true; } }return hasCollide;}
,"moveAll2D":
function(x, y) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } for (var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].X += x; this.AdhocSceneRefs[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } }
,"moveAll2DAround":
function(x, y, entName) { var ent = find(game.scene().Entities, entName); if (this.wouldCollide(ent.transpose(-x, -y)) === false) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } } }
,"quickMoveAll2DAround":
function(x, y, ent) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } for(var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].X += x; this.AdhocSceneRefs[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } }
,"tryMoveAll2DAround":
function(x, y, entName) {if (this.getMainTilegrid() === -1) { return this.moveAll2DAround(x, y, entName); } else { this.dynamic2DMove(x, y, entName, this.getMainTilegrid()); } }
,"dynamic2DMove":
function(x, y, entName, tileGrid) {var ent = game.findEntity(entName);if (this.wouldCollide(ent.transpose(-x, -y)) === false) {this.dynamic2DMoveX(x, ent, tileGrid);this.dynamic2DMoveY(y, ent, tileGrid); }}
,"dynamic2DMoveUp":
function(y, ent, tileGrid) {var amtMoveHeroTowardsCenter = (ent.pastCenterY() === false && ent.isCenteredY() === false) ? 0 : (ent.myCenterY() - viewportCenterY());if (amtMoveHeroTowardsCenter >= y) { ent.Y -= y; return; } else { ent.Y -= amtMoveHeroTowardsCenter; }var remainder = y - amtMoveHeroTowardsCenter;var tileGridSlack = 0 - tileGrid.Y;if (remainder <= Math.abs(tileGridSlack)) { this.quickMoveAll2DAround(0, remainder, ent); return; } else { this.quickMoveAll2DAround(0, Math.abs(tileGridSlack), ent); }remainder = remainder - Math.abs(tileGridSlack);ent.Y -= remainder;}
,"dynamic2DMoveDown":
function(y, ent, tileGrid) {var absY = Math.abs(y);var amtMoveHeroTowardsCenter = (ent.isCenteredY() || ent.pastCenterY()) ? 0 : viewportCenterY() - ent.myCenterY();if (amtMoveHeroTowardsCenter >= absY) { ent.Y -= y; return; } else { ent.Y += amtMoveHeroTowardsCenter; }var remainder = absY - amtMoveHeroTowardsCenter;var tileGridSlack = tileGrid.B() - getYDrawBounds2D();if (remainder <= tileGridSlack) { this.quickMoveAll2DAround(0, -remainder, ent); return; } else { this.quickMoveAll2DAround(0, tileGridSlack, ent); }remainder = remainder - tileGridSlack;ent.Y += remainder;}
,"dynamic2DMoveLeft":
function(x, ent, tileGrid) {var amtMoveHeroTowardsCenter = (ent.pastCenterX() === false && ent.isCenteredX() === false) ? 0 : (ent.myCenterX() - viewportCenterX());if (amtMoveHeroTowardsCenter >= x) { ent.X -= x; return; } else { ent.X -= amtMoveHeroTowardsCenter; }var remainder = x - amtMoveHeroTowardsCenter;var tileGridSlack = 0 - tileGrid.X;if (remainder <= Math.abs(tileGridSlack)) { this.quickMoveAll2DAround(remainder, 0, ent); return; } else { this.quickMoveAll2DAround(Math.abs(tileGridSlack), 0, ent); }remainder = remainder - Math.abs(tileGridSlack);ent.X -= remainder;}
,"dynamic2DMoveRight":
function(x, ent, tileGrid) {var absX = Math.abs(x);var amtMoveHeroTowardsCenter = (ent.isCenteredX() || ent.pastCenterX()) ? 0 : viewportCenterX() - ent.myCenterX();if (amtMoveHeroTowardsCenter >= absX) { ent.X -= x; return; } else { ent.X += amtMoveHeroTowardsCenter; }var remainder = absX - amtMoveHeroTowardsCenter;var tileGridSlack = tileGrid.R() - getXDrawBounds2D();if (remainder <= tileGridSlack) { this.quickMoveAll2DAround(-remainder, 0, ent); return; } else { this.quickMoveAll2DAround(tileGridSlack, 0, ent); }remainder = remainder - tileGridSlack;ent.X += remainder;}
,"dynamic2DMoveX":
function(x, ent, tileGrid) { var movingLeft = x > 0;if (movingLeft) { this.dynamic2DMoveLeft(x, ent, tileGrid); return; } else { this.dynamic2DMoveRight(x, ent, tileGrid); return; }var tileGridSlackX = x < 0 ? -1 * tileGrid.X : tileGrid.R() - getXDrawBounds2D(); if (ent.isCenteredX() !== true) { var centerSlackX = (x < 0 ? ((getXDrawBounds2D() / 2) - ent.X) : ent.X - (getXDrawBounds2D() / 2)); if (centerSlackX > Math.abs(x)) { ent.X -= x; }else if (centerSlackX < Math.abs(x) && centerSlackX > 0) { ent.X -= centerSlackX; }  }else if (tileGridSlackX > Math.abs(x)) { this.moveAll2DAround(x, 0, ent.Name); }else if (tileGridSlackX < Math.abs(x) && tileGridSlackX > 0) { this.moveAll2DAround(tileGridSlackX, 0, ent.Name); }}
,"dynamic2DMoveY":
function(y, ent, tileGrid) { var movingUp = y > 0;if (movingUp) { this.dynamic2DMoveUp(y, ent, tileGrid); return; } else { this.dynamic2DMoveDown(y, ent, tileGrid); return; }var tileGridSlackY = y < 0 ? -1 * tileGrid.Y : tileGrid.B() - getYDrawBounds2D();if (ent.isCenteredY() !== true) { var centerSlackY = (y < 0 ? ((getYDrawBounds2D() / 2) - ent.Y) : ent.Y - (getYDrawBounds2D() / 2)); if (centerSlackY > Math.abs(y)) { ent.Y -= y; }else if (centerSlackY < Math.abs(y) && centerSlackY > 0) { ent.Y -= centerSlackY; }  }else if (tileGridSlackY > Math.abs(y)) { this.moveAll2DAround(y, 0, ent.Name); }else if (tileGridSlackY < Math.abs(y) && tileGridSlackY > 0) { this.moveAll2DAround(tileGridSlackY, 0, ent.Name); }}
,"prepareForRenderer":
 function() {return {  };}
,"loadScene":
function() { loadThrentitiesIntoNewScene(this.allThrentities(), this.PointLights); }
,"allThrentities":
function() { return game.active().Omnipresent3D.concat(this.validLocalThrentities()); }
,"validLocalThrentities":
function() { return this.Threntities.filter(function(obj) { return Object.keys(obj).length > 0; }); }
,"getThrentity":
function (index) { var ent = game.active().getOmni3D(index); if (ent != null) { return ent; } var obj = this.Threntities[index]; if (obj == null || Object.keys(obj).length == 0) { return game.active().getOmni3D(index); } else { return this.Threntities[index]; } }
,"allEntities":
function() { return game.active().Omnipresent2D.concat(this.validLocalEntities()); }
,"validLocalEntities":
function() { return this.Entities.filter(function(obj) { return Object.keys(obj).length > 0; }); }
,"getEntity":
function (index) { var ent = game.active().getOmni2D(index); if (ent != null) { return ent; } var obj = this.Entities[index]; if (obj == null || Object.keys(obj).length == 0) { return game.active().getOmni2D(index); } else { return this.Entities[index]; } }
,"getMainTilegrid":
function() { for(var i in this.TileGrids) { if (this.TileGrids[i].MainGrid === true) { return this.TileGrids[i]; } } return -1; }
,"shiftToTop":
function() {  var main = this.getMainTilegrid(); if (main !== -1) { var moveY = main.Y; this.moveAll2D(0, moveY); return moveY; } }
,"shiftToBottom":
function() {  var main = this.getMainTilegrid(); if (main !== -1) { var moveY = -(main.B() - getYDrawBounds2D()); this.moveAll2D(0, moveY); return moveY; } }
,"shiftToRight":
function() { if (this.shiftedToRight == true) {  }  var main = this.getMainTilegrid(); if (main !== -1) {  var moveX = -(main.R() - getXDrawBounds2D()); this.moveAll2D(moveX, 0); this.shiftedToLeft = false; this.shiftedToRight = true; return moveX; } }
,"shiftToLeft":
function() { if (this.shiftedToLeft == true) {  } var main = this.getMainTilegrid(); if (main !== -1) {  var moveX = main.X; this.moveAll2D(moveX, 0);  this.shiftedToLeft = true; this.shiftedToRight = false; return moveX; } }
,"shiftedToLeft":
false
,"shiftedToRight":
false
,"shiftedToTop":
false
,"shiftedToBottom":
false
,"wouldCollide":
 function(entity) {var hasCollide = false;for (var i in this.TileGrids) { if (this.TileGrids[i].wouldCollide(entity) === true) { hasCollide = true; } }var all = this.allEntities(); for (var i in all) { if (all[i].NotWorldLevel !== true && all[i].NonCorporeal !== true && all[i].Disabled !== true && all[i].Name !== entity.name && all[i].wouldCollide(entity)) { hasCollide = true; } }return hasCollide;}
,"isSetup":
false
,"XResolution":640,"YResolution":400,"HasAmbientLight":false,"AmbientLightIntensity":75,"AmbientLightColor":"0xffffcf","Bounds2DX":0,"Bounds2DY":0,"TileGrids":[{"setup":
function(parent) { if (this.DelimitedGrid && this.DelimitedGrid.length > 0){ var rows = this.DelimitedGrid.split(';');for (var j in rows) { this.tiles.push([]); var cells = rows[j].split(',');  for (var i in cells) { var tile=this.getTile(parent, cells[i]); this.tiles[j].push(tile); } } } }
,"getTile":
function(parentScene, tileId) {  var eName = this.EntityNameCSVKey.split(',')[tileId]; var tile = find(parentScene.allEntities(), eName); /* tile.draw = function(x,y,w,h) { this.MyImage.active().render(x,y,w,h); }; */ return tile;  }
,"draw":
function() { if (this.SkipDraw==true) { return; } for(var j in this.tiles) { for(var i in this.tiles[j]) { if (this.tiles[j][i] != null && this.tiles[j][i].MyImage != null) { this.tiles[j][i].MyImage.active().render(this.X + (i * this.TW),this.Y + (j * this.TH),this.TW,this.TH); } } } }
,"update":
 function() {}
,"tiles":
 [] 
,"R":
 function() {return this.X + (this.getWidth() * this.TW);}
,"B":
 function() {return this.Y + (this.getHeight() * this.TH);}
,"wouldCollide":
 function(entity) {for(var j in this.tiles)      {       for (var i in this.tiles[j])       {        if (this.tiles[j][i] != null && this.tiles[j][i].ForceCollision===true)        {         var x = this.X + (i * this.TW);         var y = this.Y + (j * this.TH);         if (checkOverlap({X:x,Y:y,W:this.TW,H:this.TH}, entity) === true)         {          console.log('overlap found');         var events = this.tiles[j][i].collisionEvents;         if (events !== null)         {         }         if (this.tiles[j][i].LedgeCollision === true)         {          if (/*notideal*/downkey() && !leftkey() && !rightkey())          {           console.log('ledge collision detected');           /*arbitrary*/var speed = 4;           /* make entity.MyLogic have a non null ActionBlock? */           entity.Me.MyLogic.ActionBlock.MyActions.push({Depth:((this.TH/speed)*2)+1,SelfDestruct:true,Ct:0,Destroyed:false,update:function() { console.log('updating action');  if (this.BlockInput === true) { BlockInput(); } if (this.SelfDestruct === true && this.Ct + 1 == this.Depth) { this.Destroyed = true; } if (this.Destroyed !== true) { this.MyScript(); this.Ct++; } },MyTarget:entity,BlockInput:true,LocalData:speed,MyScript:function() { console.log('performing action...'); this.MyTarget.Me.Y += this.LocalData; }});          }         }         return true;         }        }       }      }       return false;}
,"getWidth":
function() { if (this.getHeight() > 0) { return this.tiles[0].length; } else { return 0; } }
,"getHeight":
function() { return this.tiles.length; }
,"EntityIndexCSVKey":"","EntityNameCSVKey":"tile1,tile2,tile3,tile4","DelimitedGrid":"0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0","SkipDraw":false,"MainGrid":true,"TW":32,"TH":32,"X":0,"Y":0,"Name":"","LocalData":"","TypeName":"TileGrid","Id":305}],"AdhocSceneRefs":[],"Entities":[{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2196}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2190},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2190},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'grass32');}
,"NameOfTarget":"grass32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6046}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2190},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile1","LocalData":"","TypeName":"Entity","Id":2190},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2197}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2191},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2191},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'stone32');}
,"NameOfTarget":"stone32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6047}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2191},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile2","LocalData":"","TypeName":"Entity","Id":2191},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2198}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2192},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2192},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":8,"ImageFrames":[{"hasImagePath":
 function() {return true;}
,"imageFilePath":"water1.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water1');}
,"NameOfTarget":"water1","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6048},{"hasImagePath":
 function() {return true;}
,"imageFilePath":"water2.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water2');}
,"NameOfTarget":"water2","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6049},{"hasImagePath":
 function() {return true;}
,"imageFilePath":"water3.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water3');}
,"NameOfTarget":"water3","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6050},{"hasImagePath":
 function() {return true;}
,"imageFilePath":"water4.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water4');}
,"NameOfTarget":"water4","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6051},{"hasImagePath":
 function() {return true;}
,"imageFilePath":"water5.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water5');}
,"NameOfTarget":"water5","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6052},{"hasImagePath":
 function() {return true;}
,"imageFilePath":"water6.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water6');}
,"NameOfTarget":"water6","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6053},{"hasImagePath":
 function() {return true;}
,"imageFilePath":"water7.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water7');}
,"NameOfTarget":"water7","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6054},{"hasImagePath":
 function() {return true;}
,"imageFilePath":"water8.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water8');}
,"NameOfTarget":"water8","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6055},{"hasImagePath":
 function() {return true;}
,"imageFilePath":"water9.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water9');}
,"NameOfTarget":"water9","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6056},{"hasImagePath":
 function() {return true;}
,"imageFilePath":"water10.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water10');}
,"NameOfTarget":"water10","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6057},{"hasImagePath":
 function() {return true;}
,"imageFilePath":"water11.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water11');}
,"NameOfTarget":"water11","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6058},{"hasImagePath":
 function() {return true;}
,"imageFilePath":"water12.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water12');}
,"NameOfTarget":"water12","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6059},{"hasImagePath":
 function() {return true;}
,"imageFilePath":"water13.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water13');}
,"NameOfTarget":"water13","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6060},{"hasImagePath":
 function() {return true;}
,"imageFilePath":"water14.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water14');}
,"NameOfTarget":"water14","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6061},{"hasImagePath":
 function() {return true;}
,"imageFilePath":"water15.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water15');}
,"NameOfTarget":"water15","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6062}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2192},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile3","LocalData":"","TypeName":"Entity","Id":2192},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2199}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2193},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2193},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'stoneWall32');}
,"NameOfTarget":"stoneWall32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6063}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2193},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":true,"LedgeCollision":true,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile4","LocalData":"","TypeName":"Entity","Id":2193}],"Threntities":[],"PointLights":[],"MyAudio":[],"MyLogic":{"update":
 function() {for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":null,"TypeName":"SceneProceduralStatement","Id":0},{"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"SceneProceduralStatement","Id":341}],"Name":"","LocalData":"","TypeName":"SceneLogicBox","Id":341},"Name":"","LocalData":"","TypeName":"Scene","Id":341},{"reloadThrentities":
function() { var allT = this.allThrentities(); for(var i in allT) { setupThrentity(allT[i]); } }
,"setup":
 function() {if (this.isSetup !== true) {for(var i in this.TileGrids) { this.TileGrids[i].setup(this); } for(var i in this.PointLights) { this.PointLights[i].setup(this); } if (this.MyAudio !== null) { for (var i = 0; i < this.MyAudio.length; i++) { this.MyAudio[i].setup(); } }if (game.active().Omnipresent2D.length > 0) { var indices = this.entityIndexArray(); var allE = this.allEntities();  for(var i in allE) { if (allE[i].MyIndex != '') { var ind = indices.indexOf(allE[i].MyIndex); if(ind != -1) { indices.splice(ind, 1); } } else { allE[i].setup(indices[i]); } }  } else { for(var i in this.Entities) { this.Entities[i].setup(i); } }if (game.active().Omnipresent3D.length > 0) { var indices = this.threntityIndexArray(); var allT = this.allThrentities(); for(var i in allT) { if (allT[i].MyIndex != '') { var ind = indices.indexOf(allT[i].MyIndex); if (ind != -1) { indices.splice(ind, 1); } } else { allT[i].setup(indices[i]); } }  } else { for(var i in this.Threntities) { this.Threntities[i].setup(i); } }if (this.HasAmbientLight == true) { addAmbientLightToCurrentScene(this.AmbientLightColor, this.AmbientLightIntensity / parseFloat(100)); }this.isSetup = true; }}
,"update":
 function() {this.MyLogic.update();for(var i in this.MyAudio) { this.MyAudio[i].update(); } var allE = this.allEntities(); for(var i in allE) { allE[i].update(); }var allT = this.allThrentities(); for(var i in allT) { allT[i].update(); }for(var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].update(this.AdhocSceneRefs[i].TargetName); } for(var i in this.TileGrids) { this.TileGrids[i].update(); } }
,"draw":
 function() {for(var i in this.TileGrids) { this.TileGrids[i].draw(); } var allE = this.allEntities(); for(var i in allE) { if (allE[i].Disabled !== true) { allE[i].draw(); } }var allT = this.allThrentities(); for(var i in allT) { allT[i].draw(); } }
,"entityIndexArray":
function() { var ray = []; for(var x in game.active().Omnipresent2D) { ray.push(game.active().Omnipresent2D[x].MyIndex); } var rayLen = ray.length; for(i=0;i<rayLen+this.Entities.length;i++) { if (ray.includes((i).toString())) {  } else {  ray.push(i); } } return ray; }
,"threntityIndexArray":
function() { var ray = []; for(var x in game.active().Omnipresent3D) { ray.push(game.active().Omnipresent3D[x].MyIndex); } var rayLen = ray.length; for(i=0;i<rayLen+this.Threntities.length;i++) { if (ray.includes((i).toString())) {  } else {  ray.push(i); } } return ray; }
,"checkMovePoint3d":
function(point3dBefore, point3dAfter) {  var all = this.allThrentities(); for(var i in all) { if (this.checkPointCollision(all[i], point3dBefore, point3dAfter)==true) { return false; } } return true;  }
,"checkPointCollision":
function(targetThrent, point3dBefore, point3dAfter) { var xBef = point3dBefore.X;var xAft = point3dAfter.X;var yBef = point3dBefore.Y;var yAft = point3dAfter.Y;var zBef = point3dBefore.Z;var zAft = point3dAfter.Z;var minX = targetThrent.L();var maxX = targetThrent.R();var minY = targetThrent.B();var maxY = targetThrent.T();var minZ = targetThrent.A();var maxZ = targetThrent.F();var xOverlap = false; var yOverlap = false; var zOverlap = false;if (xBef<xAft) { xOverlap = this.checkRangeOverlap(xBef, xAft, minX, maxX); } else { xOverlap = this.checkRangeOverlap(xAft, xBef, minX, maxX); }if (yBef<yAft) { yOverlap = this.checkRangeOverlap(yBef, yAft, minY, maxY); } else { yOverlap = this.checkRangeOverlap(yAft, yBef, minY, maxY); }if (zBef<zAft) { zOverlap = this.checkRangeOverlap(zBef, zAft, minZ, maxZ); } else { zOverlap = this.checkRangeOverlap(zAft, zBef, minZ, maxZ); }if (xOverlap==true && yOverlap==true && zOverlap==true) { return true; } return false;}
,"checkRangeOverlap":
function (inputOneMin, inputOneMax, inputTwoMin, inputTwoMax) {if (inputOneMin > inputTwoMax || inputOneMax < inputTwoMin) { return false; }return true;}
,"threnCollideContextual":
function(thren, before, after) { var hasCollide = false;var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name) { if (this.ZStraddle(before, after, all[i])===true && this.XStraddle(before, after, all[i])===true && this.YStraddle(before, after, all[i])===true) { hasCollide = true; } if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { hasCollide = true; } } }return hasCollide;}
,"ZStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.Z - before.Z;let secondDiff = target.Z - after.Z;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"XStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.X - before.X;let secondDiff = target.X - after.Y;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"YStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.Y - before.Y;let secondDiff = target.Y - after.Y;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"getFirstThrenCollide":
function(thren) { var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { return thren; } } }
,"threnCollide":
 function(thren) {var hasCollide = false;var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { hasCollide = true; } }return hasCollide;}
,"moveAll2D":
function(x, y) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } for (var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].X += x; this.AdhocSceneRefs[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } }
,"moveAll2DAround":
function(x, y, entName) { var ent = find(game.scene().Entities, entName); if (this.wouldCollide(ent.transpose(-x, -y)) === false) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } } }
,"quickMoveAll2DAround":
function(x, y, ent) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } for(var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].X += x; this.AdhocSceneRefs[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } }
,"tryMoveAll2DAround":
function(x, y, entName) {if (this.getMainTilegrid() === -1) { return this.moveAll2DAround(x, y, entName); } else { this.dynamic2DMove(x, y, entName, this.getMainTilegrid()); } }
,"dynamic2DMove":
function(x, y, entName, tileGrid) {var ent = game.findEntity(entName);if (this.wouldCollide(ent.transpose(-x, -y)) === false) {this.dynamic2DMoveX(x, ent, tileGrid);this.dynamic2DMoveY(y, ent, tileGrid); }}
,"dynamic2DMoveUp":
function(y, ent, tileGrid) {var amtMoveHeroTowardsCenter = (ent.pastCenterY() === false && ent.isCenteredY() === false) ? 0 : (ent.myCenterY() - viewportCenterY());if (amtMoveHeroTowardsCenter >= y) { ent.Y -= y; return; } else { ent.Y -= amtMoveHeroTowardsCenter; }var remainder = y - amtMoveHeroTowardsCenter;var tileGridSlack = 0 - tileGrid.Y;if (remainder <= Math.abs(tileGridSlack)) { this.quickMoveAll2DAround(0, remainder, ent); return; } else { this.quickMoveAll2DAround(0, Math.abs(tileGridSlack), ent); }remainder = remainder - Math.abs(tileGridSlack);ent.Y -= remainder;}
,"dynamic2DMoveDown":
function(y, ent, tileGrid) {var absY = Math.abs(y);var amtMoveHeroTowardsCenter = (ent.isCenteredY() || ent.pastCenterY()) ? 0 : viewportCenterY() - ent.myCenterY();if (amtMoveHeroTowardsCenter >= absY) { ent.Y -= y; return; } else { ent.Y += amtMoveHeroTowardsCenter; }var remainder = absY - amtMoveHeroTowardsCenter;var tileGridSlack = tileGrid.B() - getYDrawBounds2D();if (remainder <= tileGridSlack) { this.quickMoveAll2DAround(0, -remainder, ent); return; } else { this.quickMoveAll2DAround(0, tileGridSlack, ent); }remainder = remainder - tileGridSlack;ent.Y += remainder;}
,"dynamic2DMoveLeft":
function(x, ent, tileGrid) {var amtMoveHeroTowardsCenter = (ent.pastCenterX() === false && ent.isCenteredX() === false) ? 0 : (ent.myCenterX() - viewportCenterX());if (amtMoveHeroTowardsCenter >= x) { ent.X -= x; return; } else { ent.X -= amtMoveHeroTowardsCenter; }var remainder = x - amtMoveHeroTowardsCenter;var tileGridSlack = 0 - tileGrid.X;if (remainder <= Math.abs(tileGridSlack)) { this.quickMoveAll2DAround(remainder, 0, ent); return; } else { this.quickMoveAll2DAround(Math.abs(tileGridSlack), 0, ent); }remainder = remainder - Math.abs(tileGridSlack);ent.X -= remainder;}
,"dynamic2DMoveRight":
function(x, ent, tileGrid) {var absX = Math.abs(x);var amtMoveHeroTowardsCenter = (ent.isCenteredX() || ent.pastCenterX()) ? 0 : viewportCenterX() - ent.myCenterX();if (amtMoveHeroTowardsCenter >= absX) { ent.X -= x; return; } else { ent.X += amtMoveHeroTowardsCenter; }var remainder = absX - amtMoveHeroTowardsCenter;var tileGridSlack = tileGrid.R() - getXDrawBounds2D();if (remainder <= tileGridSlack) { this.quickMoveAll2DAround(-remainder, 0, ent); return; } else { this.quickMoveAll2DAround(tileGridSlack, 0, ent); }remainder = remainder - tileGridSlack;ent.X += remainder;}
,"dynamic2DMoveX":
function(x, ent, tileGrid) { var movingLeft = x > 0;if (movingLeft) { this.dynamic2DMoveLeft(x, ent, tileGrid); return; } else { this.dynamic2DMoveRight(x, ent, tileGrid); return; }var tileGridSlackX = x < 0 ? -1 * tileGrid.X : tileGrid.R() - getXDrawBounds2D(); if (ent.isCenteredX() !== true) { var centerSlackX = (x < 0 ? ((getXDrawBounds2D() / 2) - ent.X) : ent.X - (getXDrawBounds2D() / 2)); if (centerSlackX > Math.abs(x)) { ent.X -= x; }else if (centerSlackX < Math.abs(x) && centerSlackX > 0) { ent.X -= centerSlackX; }  }else if (tileGridSlackX > Math.abs(x)) { this.moveAll2DAround(x, 0, ent.Name); }else if (tileGridSlackX < Math.abs(x) && tileGridSlackX > 0) { this.moveAll2DAround(tileGridSlackX, 0, ent.Name); }}
,"dynamic2DMoveY":
function(y, ent, tileGrid) { var movingUp = y > 0;if (movingUp) { this.dynamic2DMoveUp(y, ent, tileGrid); return; } else { this.dynamic2DMoveDown(y, ent, tileGrid); return; }var tileGridSlackY = y < 0 ? -1 * tileGrid.Y : tileGrid.B() - getYDrawBounds2D();if (ent.isCenteredY() !== true) { var centerSlackY = (y < 0 ? ((getYDrawBounds2D() / 2) - ent.Y) : ent.Y - (getYDrawBounds2D() / 2)); if (centerSlackY > Math.abs(y)) { ent.Y -= y; }else if (centerSlackY < Math.abs(y) && centerSlackY > 0) { ent.Y -= centerSlackY; }  }else if (tileGridSlackY > Math.abs(y)) { this.moveAll2DAround(y, 0, ent.Name); }else if (tileGridSlackY < Math.abs(y) && tileGridSlackY > 0) { this.moveAll2DAround(tileGridSlackY, 0, ent.Name); }}
,"prepareForRenderer":
 function() {return {  };}
,"loadScene":
function() { loadThrentitiesIntoNewScene(this.allThrentities(), this.PointLights); }
,"allThrentities":
function() { return game.active().Omnipresent3D.concat(this.validLocalThrentities()); }
,"validLocalThrentities":
function() { return this.Threntities.filter(function(obj) { return Object.keys(obj).length > 0; }); }
,"getThrentity":
function (index) { var ent = game.active().getOmni3D(index); if (ent != null) { return ent; } var obj = this.Threntities[index]; if (obj == null || Object.keys(obj).length == 0) { return game.active().getOmni3D(index); } else { return this.Threntities[index]; } }
,"allEntities":
function() { return game.active().Omnipresent2D.concat(this.validLocalEntities()); }
,"validLocalEntities":
function() { return this.Entities.filter(function(obj) { return Object.keys(obj).length > 0; }); }
,"getEntity":
function (index) { var ent = game.active().getOmni2D(index); if (ent != null) { return ent; } var obj = this.Entities[index]; if (obj == null || Object.keys(obj).length == 0) { return game.active().getOmni2D(index); } else { return this.Entities[index]; } }
,"getMainTilegrid":
function() { for(var i in this.TileGrids) { if (this.TileGrids[i].MainGrid === true) { return this.TileGrids[i]; } } return -1; }
,"shiftToTop":
function() {  var main = this.getMainTilegrid(); if (main !== -1) { var moveY = main.Y; this.moveAll2D(0, moveY); return moveY; } }
,"shiftToBottom":
function() {  var main = this.getMainTilegrid(); if (main !== -1) { var moveY = -(main.B() - getYDrawBounds2D()); this.moveAll2D(0, moveY); return moveY; } }
,"shiftToRight":
function() { if (this.shiftedToRight == true) {  }  var main = this.getMainTilegrid(); if (main !== -1) {  var moveX = -(main.R() - getXDrawBounds2D()); this.moveAll2D(moveX, 0); this.shiftedToLeft = false; this.shiftedToRight = true; return moveX; } }
,"shiftToLeft":
function() { if (this.shiftedToLeft == true) {  } var main = this.getMainTilegrid(); if (main !== -1) {  var moveX = main.X; this.moveAll2D(moveX, 0);  this.shiftedToLeft = true; this.shiftedToRight = false; return moveX; } }
,"shiftedToLeft":
false
,"shiftedToRight":
false
,"shiftedToTop":
false
,"shiftedToBottom":
false
,"wouldCollide":
 function(entity) {var hasCollide = false;for (var i in this.TileGrids) { if (this.TileGrids[i].wouldCollide(entity) === true) { hasCollide = true; } }var all = this.allEntities(); for (var i in all) { if (all[i].NotWorldLevel !== true && all[i].NonCorporeal !== true && all[i].Disabled !== true && all[i].Name !== entity.name && all[i].wouldCollide(entity)) { hasCollide = true; } }return hasCollide;}
,"isSetup":
false
,"XResolution":640,"YResolution":400,"HasAmbientLight":false,"AmbientLightIntensity":75,"AmbientLightColor":"0xffffcf","Bounds2DX":0,"Bounds2DY":0,"TileGrids":[{"setup":
function(parent) { if (this.DelimitedGrid && this.DelimitedGrid.length > 0){ var rows = this.DelimitedGrid.split(';');for (var j in rows) { this.tiles.push([]); var cells = rows[j].split(',');  for (var i in cells) { var tile=this.getTile(parent, cells[i]); this.tiles[j].push(tile); } } } }
,"getTile":
function(parentScene, tileId) {  var eName = this.EntityNameCSVKey.split(',')[tileId]; var tile = find(parentScene.allEntities(), eName); /* tile.draw = function(x,y,w,h) { this.MyImage.active().render(x,y,w,h); }; */ return tile;  }
,"draw":
function() { if (this.SkipDraw==true) { return; } for(var j in this.tiles) { for(var i in this.tiles[j]) { if (this.tiles[j][i] != null && this.tiles[j][i].MyImage != null) { this.tiles[j][i].MyImage.active().render(this.X + (i * this.TW),this.Y + (j * this.TH),this.TW,this.TH); } } } }
,"update":
 function() {}
,"tiles":
 [] 
,"R":
 function() {return this.X + (this.getWidth() * this.TW);}
,"B":
 function() {return this.Y + (this.getHeight() * this.TH);}
,"wouldCollide":
 function(entity) {for(var j in this.tiles)      {       for (var i in this.tiles[j])       {        if (this.tiles[j][i] != null && this.tiles[j][i].ForceCollision===true)        {         var x = this.X + (i * this.TW);         var y = this.Y + (j * this.TH);         if (checkOverlap({X:x,Y:y,W:this.TW,H:this.TH}, entity) === true)         {          console.log('overlap found');         var events = this.tiles[j][i].collisionEvents;         if (events !== null)         {         }         if (this.tiles[j][i].LedgeCollision === true)         {          if (/*notideal*/downkey() && !leftkey() && !rightkey())          {           console.log('ledge collision detected');           /*arbitrary*/var speed = 4;           /* make entity.MyLogic have a non null ActionBlock? */           entity.Me.MyLogic.ActionBlock.MyActions.push({Depth:((this.TH/speed)*2)+1,SelfDestruct:true,Ct:0,Destroyed:false,update:function() { console.log('updating action');  if (this.BlockInput === true) { BlockInput(); } if (this.SelfDestruct === true && this.Ct + 1 == this.Depth) { this.Destroyed = true; } if (this.Destroyed !== true) { this.MyScript(); this.Ct++; } },MyTarget:entity,BlockInput:true,LocalData:speed,MyScript:function() { console.log('performing action...'); this.MyTarget.Me.Y += this.LocalData; }});          }         }         return true;         }        }       }      }       return false;}
,"getWidth":
function() { if (this.getHeight() > 0) { return this.tiles[0].length; } else { return 0; } }
,"getHeight":
function() { return this.tiles.length; }
,"EntityIndexCSVKey":"","EntityNameCSVKey":"tile1,tile2,tile3,tile4","DelimitedGrid":"0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0","SkipDraw":false,"MainGrid":true,"TW":32,"TH":32,"X":0,"Y":0,"Name":"","LocalData":"","TypeName":"TileGrid","Id":306}],"AdhocSceneRefs":[],"Entities":[{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2200}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2194},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2194},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'grass32');}
,"NameOfTarget":"grass32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6064}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2194},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile1","LocalData":"","TypeName":"Entity","Id":2194},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2201}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2195},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2195},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'stone32');}
,"NameOfTarget":"stone32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6065}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2195},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile2","LocalData":"","TypeName":"Entity","Id":2195},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2202}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2196},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2196},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":8,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water1');}
,"NameOfTarget":"water1","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6066},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water2');}
,"NameOfTarget":"water2","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6067},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water3');}
,"NameOfTarget":"water3","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6068},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water4');}
,"NameOfTarget":"water4","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6069},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water5');}
,"NameOfTarget":"water5","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6070},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water6');}
,"NameOfTarget":"water6","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6071},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water7');}
,"NameOfTarget":"water7","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6072},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water8');}
,"NameOfTarget":"water8","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6073},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water9');}
,"NameOfTarget":"water9","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6074},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water10');}
,"NameOfTarget":"water10","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6075},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water11');}
,"NameOfTarget":"water11","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6076},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water12');}
,"NameOfTarget":"water12","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6077},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water13');}
,"NameOfTarget":"water13","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6078},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water14');}
,"NameOfTarget":"water14","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6079},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water15');}
,"NameOfTarget":"water15","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6080}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2196},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile3","LocalData":"","TypeName":"Entity","Id":2196},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2203}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2197},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2197},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'stoneWall32');}
,"NameOfTarget":"stoneWall32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6081}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2197},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":true,"LedgeCollision":true,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile4","LocalData":"","TypeName":"Entity","Id":2197}],"Threntities":[],"PointLights":[],"MyAudio":[],"MyLogic":{"update":
 function() {for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":null,"TypeName":"SceneProceduralStatement","Id":0},{"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"SceneProceduralStatement","Id":342}],"Name":"","LocalData":"","TypeName":"SceneLogicBox","Id":342},"Name":"","LocalData":"","TypeName":"Scene","Id":342},{"reloadThrentities":
function() { var allT = this.allThrentities(); for(var i in allT) { setupThrentity(allT[i]); } }
,"setup":
 function() {if (this.isSetup !== true) {for(var i in this.TileGrids) { this.TileGrids[i].setup(this); } for(var i in this.PointLights) { this.PointLights[i].setup(this); } if (this.MyAudio !== null) { for (var i = 0; i < this.MyAudio.length; i++) { this.MyAudio[i].setup(); } }if (game.active().Omnipresent2D.length > 0) { var indices = this.entityIndexArray(); var allE = this.allEntities();  for(var i in allE) { if (allE[i].MyIndex != '') { var ind = indices.indexOf(allE[i].MyIndex); if(ind != -1) { indices.splice(ind, 1); } } else { allE[i].setup(indices[i]); } }  } else { for(var i in this.Entities) { this.Entities[i].setup(i); } }if (game.active().Omnipresent3D.length > 0) { var indices = this.threntityIndexArray(); var allT = this.allThrentities(); for(var i in allT) { if (allT[i].MyIndex != '') { var ind = indices.indexOf(allT[i].MyIndex); if (ind != -1) { indices.splice(ind, 1); } } else { allT[i].setup(indices[i]); } }  } else { for(var i in this.Threntities) { this.Threntities[i].setup(i); } }if (this.HasAmbientLight == true) { addAmbientLightToCurrentScene(this.AmbientLightColor, this.AmbientLightIntensity / parseFloat(100)); }this.isSetup = true; }}
,"update":
 function() {this.MyLogic.update();for(var i in this.MyAudio) { this.MyAudio[i].update(); } var allE = this.allEntities(); for(var i in allE) { allE[i].update(); }var allT = this.allThrentities(); for(var i in allT) { allT[i].update(); }for(var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].update(this.AdhocSceneRefs[i].TargetName); } for(var i in this.TileGrids) { this.TileGrids[i].update(); } }
,"draw":
 function() {for(var i in this.TileGrids) { this.TileGrids[i].draw(); } var allE = this.allEntities(); for(var i in allE) { if (allE[i].Disabled !== true) { allE[i].draw(); } }var allT = this.allThrentities(); for(var i in allT) { allT[i].draw(); } }
,"entityIndexArray":
function() { var ray = []; for(var x in game.active().Omnipresent2D) { ray.push(game.active().Omnipresent2D[x].MyIndex); } var rayLen = ray.length; for(i=0;i<rayLen+this.Entities.length;i++) { if (ray.includes((i).toString())) {  } else {  ray.push(i); } } return ray; }
,"threntityIndexArray":
function() { var ray = []; for(var x in game.active().Omnipresent3D) { ray.push(game.active().Omnipresent3D[x].MyIndex); } var rayLen = ray.length; for(i=0;i<rayLen+this.Threntities.length;i++) { if (ray.includes((i).toString())) {  } else {  ray.push(i); } } return ray; }
,"checkMovePoint3d":
function(point3dBefore, point3dAfter) {  var all = this.allThrentities(); for(var i in all) { if (this.checkPointCollision(all[i], point3dBefore, point3dAfter)==true) { return false; } } return true;  }
,"checkPointCollision":
function(targetThrent, point3dBefore, point3dAfter) { var xBef = point3dBefore.X;var xAft = point3dAfter.X;var yBef = point3dBefore.Y;var yAft = point3dAfter.Y;var zBef = point3dBefore.Z;var zAft = point3dAfter.Z;var minX = targetThrent.L();var maxX = targetThrent.R();var minY = targetThrent.B();var maxY = targetThrent.T();var minZ = targetThrent.A();var maxZ = targetThrent.F();var xOverlap = false; var yOverlap = false; var zOverlap = false;if (xBef<xAft) { xOverlap = this.checkRangeOverlap(xBef, xAft, minX, maxX); } else { xOverlap = this.checkRangeOverlap(xAft, xBef, minX, maxX); }if (yBef<yAft) { yOverlap = this.checkRangeOverlap(yBef, yAft, minY, maxY); } else { yOverlap = this.checkRangeOverlap(yAft, yBef, minY, maxY); }if (zBef<zAft) { zOverlap = this.checkRangeOverlap(zBef, zAft, minZ, maxZ); } else { zOverlap = this.checkRangeOverlap(zAft, zBef, minZ, maxZ); }if (xOverlap==true && yOverlap==true && zOverlap==true) { return true; } return false;}
,"checkRangeOverlap":
function (inputOneMin, inputOneMax, inputTwoMin, inputTwoMax) {if (inputOneMin > inputTwoMax || inputOneMax < inputTwoMin) { return false; }return true;}
,"threnCollideContextual":
function(thren, before, after) { var hasCollide = false;var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name) { if (this.ZStraddle(before, after, all[i])===true && this.XStraddle(before, after, all[i])===true && this.YStraddle(before, after, all[i])===true) { hasCollide = true; } if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { hasCollide = true; } } }return hasCollide;}
,"ZStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.Z - before.Z;let secondDiff = target.Z - after.Z;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"XStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.X - before.X;let secondDiff = target.X - after.Y;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"YStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.Y - before.Y;let secondDiff = target.Y - after.Y;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"getFirstThrenCollide":
function(thren) { var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { return thren; } } }
,"threnCollide":
 function(thren) {var hasCollide = false;var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { hasCollide = true; } }return hasCollide;}
,"moveAll2D":
function(x, y) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } for (var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].X += x; this.AdhocSceneRefs[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } }
,"moveAll2DAround":
function(x, y, entName) { var ent = find(game.scene().Entities, entName); if (this.wouldCollide(ent.transpose(-x, -y)) === false) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } } }
,"quickMoveAll2DAround":
function(x, y, ent) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } for(var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].X += x; this.AdhocSceneRefs[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } }
,"tryMoveAll2DAround":
function(x, y, entName) {if (this.getMainTilegrid() === -1) { return this.moveAll2DAround(x, y, entName); } else { this.dynamic2DMove(x, y, entName, this.getMainTilegrid()); } }
,"dynamic2DMove":
function(x, y, entName, tileGrid) {var ent = game.findEntity(entName);if (this.wouldCollide(ent.transpose(-x, -y)) === false) {this.dynamic2DMoveX(x, ent, tileGrid);this.dynamic2DMoveY(y, ent, tileGrid); }}
,"dynamic2DMoveUp":
function(y, ent, tileGrid) {var amtMoveHeroTowardsCenter = (ent.pastCenterY() === false && ent.isCenteredY() === false) ? 0 : (ent.myCenterY() - viewportCenterY());if (amtMoveHeroTowardsCenter >= y) { ent.Y -= y; return; } else { ent.Y -= amtMoveHeroTowardsCenter; }var remainder = y - amtMoveHeroTowardsCenter;var tileGridSlack = 0 - tileGrid.Y;if (remainder <= Math.abs(tileGridSlack)) { this.quickMoveAll2DAround(0, remainder, ent); return; } else { this.quickMoveAll2DAround(0, Math.abs(tileGridSlack), ent); }remainder = remainder - Math.abs(tileGridSlack);ent.Y -= remainder;}
,"dynamic2DMoveDown":
function(y, ent, tileGrid) {var absY = Math.abs(y);var amtMoveHeroTowardsCenter = (ent.isCenteredY() || ent.pastCenterY()) ? 0 : viewportCenterY() - ent.myCenterY();if (amtMoveHeroTowardsCenter >= absY) { ent.Y -= y; return; } else { ent.Y += amtMoveHeroTowardsCenter; }var remainder = absY - amtMoveHeroTowardsCenter;var tileGridSlack = tileGrid.B() - getYDrawBounds2D();if (remainder <= tileGridSlack) { this.quickMoveAll2DAround(0, -remainder, ent); return; } else { this.quickMoveAll2DAround(0, tileGridSlack, ent); }remainder = remainder - tileGridSlack;ent.Y += remainder;}
,"dynamic2DMoveLeft":
function(x, ent, tileGrid) {var amtMoveHeroTowardsCenter = (ent.pastCenterX() === false && ent.isCenteredX() === false) ? 0 : (ent.myCenterX() - viewportCenterX());if (amtMoveHeroTowardsCenter >= x) { ent.X -= x; return; } else { ent.X -= amtMoveHeroTowardsCenter; }var remainder = x - amtMoveHeroTowardsCenter;var tileGridSlack = 0 - tileGrid.X;if (remainder <= Math.abs(tileGridSlack)) { this.quickMoveAll2DAround(remainder, 0, ent); return; } else { this.quickMoveAll2DAround(Math.abs(tileGridSlack), 0, ent); }remainder = remainder - Math.abs(tileGridSlack);ent.X -= remainder;}
,"dynamic2DMoveRight":
function(x, ent, tileGrid) {var absX = Math.abs(x);var amtMoveHeroTowardsCenter = (ent.isCenteredX() || ent.pastCenterX()) ? 0 : viewportCenterX() - ent.myCenterX();if (amtMoveHeroTowardsCenter >= absX) { ent.X -= x; return; } else { ent.X += amtMoveHeroTowardsCenter; }var remainder = absX - amtMoveHeroTowardsCenter;var tileGridSlack = tileGrid.R() - getXDrawBounds2D();if (remainder <= tileGridSlack) { this.quickMoveAll2DAround(-remainder, 0, ent); return; } else { this.quickMoveAll2DAround(tileGridSlack, 0, ent); }remainder = remainder - tileGridSlack;ent.X += remainder;}
,"dynamic2DMoveX":
function(x, ent, tileGrid) { var movingLeft = x > 0;if (movingLeft) { this.dynamic2DMoveLeft(x, ent, tileGrid); return; } else { this.dynamic2DMoveRight(x, ent, tileGrid); return; }var tileGridSlackX = x < 0 ? -1 * tileGrid.X : tileGrid.R() - getXDrawBounds2D(); if (ent.isCenteredX() !== true) { var centerSlackX = (x < 0 ? ((getXDrawBounds2D() / 2) - ent.X) : ent.X - (getXDrawBounds2D() / 2)); if (centerSlackX > Math.abs(x)) { ent.X -= x; }else if (centerSlackX < Math.abs(x) && centerSlackX > 0) { ent.X -= centerSlackX; }  }else if (tileGridSlackX > Math.abs(x)) { this.moveAll2DAround(x, 0, ent.Name); }else if (tileGridSlackX < Math.abs(x) && tileGridSlackX > 0) { this.moveAll2DAround(tileGridSlackX, 0, ent.Name); }}
,"dynamic2DMoveY":
function(y, ent, tileGrid) { var movingUp = y > 0;if (movingUp) { this.dynamic2DMoveUp(y, ent, tileGrid); return; } else { this.dynamic2DMoveDown(y, ent, tileGrid); return; }var tileGridSlackY = y < 0 ? -1 * tileGrid.Y : tileGrid.B() - getYDrawBounds2D();if (ent.isCenteredY() !== true) { var centerSlackY = (y < 0 ? ((getYDrawBounds2D() / 2) - ent.Y) : ent.Y - (getYDrawBounds2D() / 2)); if (centerSlackY > Math.abs(y)) { ent.Y -= y; }else if (centerSlackY < Math.abs(y) && centerSlackY > 0) { ent.Y -= centerSlackY; }  }else if (tileGridSlackY > Math.abs(y)) { this.moveAll2DAround(y, 0, ent.Name); }else if (tileGridSlackY < Math.abs(y) && tileGridSlackY > 0) { this.moveAll2DAround(tileGridSlackY, 0, ent.Name); }}
,"prepareForRenderer":
 function() {return {  };}
,"loadScene":
function() { loadThrentitiesIntoNewScene(this.allThrentities(), this.PointLights); }
,"allThrentities":
function() { return game.active().Omnipresent3D.concat(this.validLocalThrentities()); }
,"validLocalThrentities":
function() { return this.Threntities.filter(function(obj) { return Object.keys(obj).length > 0; }); }
,"getThrentity":
function (index) { var ent = game.active().getOmni3D(index); if (ent != null) { return ent; } var obj = this.Threntities[index]; if (obj == null || Object.keys(obj).length == 0) { return game.active().getOmni3D(index); } else { return this.Threntities[index]; } }
,"allEntities":
function() { return game.active().Omnipresent2D.concat(this.validLocalEntities()); }
,"validLocalEntities":
function() { return this.Entities.filter(function(obj) { return Object.keys(obj).length > 0; }); }
,"getEntity":
function (index) { var ent = game.active().getOmni2D(index); if (ent != null) { return ent; } var obj = this.Entities[index]; if (obj == null || Object.keys(obj).length == 0) { return game.active().getOmni2D(index); } else { return this.Entities[index]; } }
,"getMainTilegrid":
function() { for(var i in this.TileGrids) { if (this.TileGrids[i].MainGrid === true) { return this.TileGrids[i]; } } return -1; }
,"shiftToTop":
function() {  var main = this.getMainTilegrid(); if (main !== -1) { var moveY = main.Y; this.moveAll2D(0, moveY); return moveY; } }
,"shiftToBottom":
function() {  var main = this.getMainTilegrid(); if (main !== -1) { var moveY = -(main.B() - getYDrawBounds2D()); this.moveAll2D(0, moveY); return moveY; } }
,"shiftToRight":
function() { if (this.shiftedToRight == true) {  }  var main = this.getMainTilegrid(); if (main !== -1) {  var moveX = -(main.R() - getXDrawBounds2D()); this.moveAll2D(moveX, 0); this.shiftedToLeft = false; this.shiftedToRight = true; return moveX; } }
,"shiftToLeft":
function() { if (this.shiftedToLeft == true) {  } var main = this.getMainTilegrid(); if (main !== -1) {  var moveX = main.X; this.moveAll2D(moveX, 0);  this.shiftedToLeft = true; this.shiftedToRight = false; return moveX; } }
,"shiftedToLeft":
false
,"shiftedToRight":
false
,"shiftedToTop":
false
,"shiftedToBottom":
false
,"wouldCollide":
 function(entity) {var hasCollide = false;for (var i in this.TileGrids) { if (this.TileGrids[i].wouldCollide(entity) === true) { hasCollide = true; } }var all = this.allEntities(); for (var i in all) { if (all[i].NotWorldLevel !== true && all[i].NonCorporeal !== true && all[i].Disabled !== true && all[i].Name !== entity.name && all[i].wouldCollide(entity)) { hasCollide = true; } }return hasCollide;}
,"isSetup":
false
,"XResolution":640,"YResolution":400,"HasAmbientLight":false,"AmbientLightIntensity":75,"AmbientLightColor":"0xffffcf","Bounds2DX":0,"Bounds2DY":0,"TileGrids":[{"setup":
function(parent) { if (this.DelimitedGrid && this.DelimitedGrid.length > 0){ var rows = this.DelimitedGrid.split(';');for (var j in rows) { this.tiles.push([]); var cells = rows[j].split(',');  for (var i in cells) { var tile=this.getTile(parent, cells[i]); this.tiles[j].push(tile); } } } }
,"getTile":
function(parentScene, tileId) {  var eName = this.EntityNameCSVKey.split(',')[tileId]; var tile = find(parentScene.allEntities(), eName); /* tile.draw = function(x,y,w,h) { this.MyImage.active().render(x,y,w,h); }; */ return tile;  }
,"draw":
function() { if (this.SkipDraw==true) { return; } for(var j in this.tiles) { for(var i in this.tiles[j]) { if (this.tiles[j][i] != null && this.tiles[j][i].MyImage != null) { this.tiles[j][i].MyImage.active().render(this.X + (i * this.TW),this.Y + (j * this.TH),this.TW,this.TH); } } } }
,"update":
 function() {}
,"tiles":
 [] 
,"R":
 function() {return this.X + (this.getWidth() * this.TW);}
,"B":
 function() {return this.Y + (this.getHeight() * this.TH);}
,"wouldCollide":
 function(entity) {for(var j in this.tiles)      {       for (var i in this.tiles[j])       {        if (this.tiles[j][i] != null && this.tiles[j][i].ForceCollision===true)        {         var x = this.X + (i * this.TW);         var y = this.Y + (j * this.TH);         if (checkOverlap({X:x,Y:y,W:this.TW,H:this.TH}, entity) === true)         {          console.log('overlap found');         var events = this.tiles[j][i].collisionEvents;         if (events !== null)         {         }         if (this.tiles[j][i].LedgeCollision === true)         {          if (/*notideal*/downkey() && !leftkey() && !rightkey())          {           console.log('ledge collision detected');           /*arbitrary*/var speed = 4;           /* make entity.MyLogic have a non null ActionBlock? */           entity.Me.MyLogic.ActionBlock.MyActions.push({Depth:((this.TH/speed)*2)+1,SelfDestruct:true,Ct:0,Destroyed:false,update:function() { console.log('updating action');  if (this.BlockInput === true) { BlockInput(); } if (this.SelfDestruct === true && this.Ct + 1 == this.Depth) { this.Destroyed = true; } if (this.Destroyed !== true) { this.MyScript(); this.Ct++; } },MyTarget:entity,BlockInput:true,LocalData:speed,MyScript:function() { console.log('performing action...'); this.MyTarget.Me.Y += this.LocalData; }});          }         }         return true;         }        }       }      }       return false;}
,"getWidth":
function() { if (this.getHeight() > 0) { return this.tiles[0].length; } else { return 0; } }
,"getHeight":
function() { return this.tiles.length; }
,"EntityIndexCSVKey":"","EntityNameCSVKey":"tile1,tile2,tile3,tile4","DelimitedGrid":"0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0","SkipDraw":false,"MainGrid":true,"TW":32,"TH":32,"X":0,"Y":0,"Name":"","LocalData":"","TypeName":"TileGrid","Id":307}],"AdhocSceneRefs":[],"Entities":[{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2204}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2198},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2198},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'grass32');}
,"NameOfTarget":"grass32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6082}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2198},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile1","LocalData":"","TypeName":"Entity","Id":2198},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2205}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2199},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2199},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'stone32');}
,"NameOfTarget":"stone32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6083}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2199},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile2","LocalData":"","TypeName":"Entity","Id":2199},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2206}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2200},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2200},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":8,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water2');}
,"NameOfTarget":"water2","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6085},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water3');}
,"NameOfTarget":"water3","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6086},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water4');}
,"NameOfTarget":"water4","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6087},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water5');}
,"NameOfTarget":"water5","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6088},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water6');}
,"NameOfTarget":"water6","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6089},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water7');}
,"NameOfTarget":"water7","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6090},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water8');}
,"NameOfTarget":"water8","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6091},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water9');}
,"NameOfTarget":"water9","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6092},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water10');}
,"NameOfTarget":"water10","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6093},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water11');}
,"NameOfTarget":"water11","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6094},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water12');}
,"NameOfTarget":"water12","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6095},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water13');}
,"NameOfTarget":"water13","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6096},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water14');}
,"NameOfTarget":"water14","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6097},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water15');}
,"NameOfTarget":"water15","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6098},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water1');}
,"NameOfTarget":"water1","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6084}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2200},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile3","LocalData":"","TypeName":"Entity","Id":2200},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2207}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2201},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2201},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'stoneWall32');}
,"NameOfTarget":"stoneWall32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6099}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2201},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":true,"LedgeCollision":true,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile4","LocalData":"","TypeName":"Entity","Id":2201}],"Threntities":[],"PointLights":[],"MyAudio":[],"MyLogic":{"update":
 function() {for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":null,"TypeName":"SceneProceduralStatement","Id":0},{"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"SceneProceduralStatement","Id":343}],"Name":"","LocalData":"","TypeName":"SceneLogicBox","Id":343},"Name":"","LocalData":"","TypeName":"Scene","Id":343},{"reloadThrentities":
function() { var allT = this.allThrentities(); for(var i in allT) { setupThrentity(allT[i]); } }
,"setup":
 function() {if (this.isSetup !== true) {for(var i in this.TileGrids) { this.TileGrids[i].setup(this); } for(var i in this.PointLights) { this.PointLights[i].setup(this); } if (this.MyAudio !== null) { for (var i = 0; i < this.MyAudio.length; i++) { this.MyAudio[i].setup(); } }if (game.active().Omnipresent2D.length > 0) { var indices = this.entityIndexArray(); var allE = this.allEntities();  for(var i in allE) { if (allE[i].MyIndex != '') { var ind = indices.indexOf(allE[i].MyIndex); if(ind != -1) { indices.splice(ind, 1); } } else { allE[i].setup(indices[i]); } }  } else { for(var i in this.Entities) { this.Entities[i].setup(i); } }if (game.active().Omnipresent3D.length > 0) { var indices = this.threntityIndexArray(); var allT = this.allThrentities(); for(var i in allT) { if (allT[i].MyIndex != '') { var ind = indices.indexOf(allT[i].MyIndex); if (ind != -1) { indices.splice(ind, 1); } } else { allT[i].setup(indices[i]); } }  } else { for(var i in this.Threntities) { this.Threntities[i].setup(i); } }if (this.HasAmbientLight == true) { addAmbientLightToCurrentScene(this.AmbientLightColor, this.AmbientLightIntensity / parseFloat(100)); }this.isSetup = true; }}
,"update":
 function() {this.MyLogic.update();for(var i in this.MyAudio) { this.MyAudio[i].update(); } var allE = this.allEntities(); for(var i in allE) { allE[i].update(); }var allT = this.allThrentities(); for(var i in allT) { allT[i].update(); }for(var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].update(this.AdhocSceneRefs[i].TargetName); } for(var i in this.TileGrids) { this.TileGrids[i].update(); } }
,"draw":
 function() {for(var i in this.TileGrids) { this.TileGrids[i].draw(); } var allE = this.allEntities(); for(var i in allE) { if (allE[i].Disabled !== true) { allE[i].draw(); } }var allT = this.allThrentities(); for(var i in allT) { allT[i].draw(); } }
,"entityIndexArray":
function() { var ray = []; for(var x in game.active().Omnipresent2D) { ray.push(game.active().Omnipresent2D[x].MyIndex); } var rayLen = ray.length; for(i=0;i<rayLen+this.Entities.length;i++) { if (ray.includes((i).toString())) {  } else {  ray.push(i); } } return ray; }
,"threntityIndexArray":
function() { var ray = []; for(var x in game.active().Omnipresent3D) { ray.push(game.active().Omnipresent3D[x].MyIndex); } var rayLen = ray.length; for(i=0;i<rayLen+this.Threntities.length;i++) { if (ray.includes((i).toString())) {  } else {  ray.push(i); } } return ray; }
,"checkMovePoint3d":
function(point3dBefore, point3dAfter) {  var all = this.allThrentities(); for(var i in all) { if (this.checkPointCollision(all[i], point3dBefore, point3dAfter)==true) { return false; } } return true;  }
,"checkPointCollision":
function(targetThrent, point3dBefore, point3dAfter) { var xBef = point3dBefore.X;var xAft = point3dAfter.X;var yBef = point3dBefore.Y;var yAft = point3dAfter.Y;var zBef = point3dBefore.Z;var zAft = point3dAfter.Z;var minX = targetThrent.L();var maxX = targetThrent.R();var minY = targetThrent.B();var maxY = targetThrent.T();var minZ = targetThrent.A();var maxZ = targetThrent.F();var xOverlap = false; var yOverlap = false; var zOverlap = false;if (xBef<xAft) { xOverlap = this.checkRangeOverlap(xBef, xAft, minX, maxX); } else { xOverlap = this.checkRangeOverlap(xAft, xBef, minX, maxX); }if (yBef<yAft) { yOverlap = this.checkRangeOverlap(yBef, yAft, minY, maxY); } else { yOverlap = this.checkRangeOverlap(yAft, yBef, minY, maxY); }if (zBef<zAft) { zOverlap = this.checkRangeOverlap(zBef, zAft, minZ, maxZ); } else { zOverlap = this.checkRangeOverlap(zAft, zBef, minZ, maxZ); }if (xOverlap==true && yOverlap==true && zOverlap==true) { return true; } return false;}
,"checkRangeOverlap":
function (inputOneMin, inputOneMax, inputTwoMin, inputTwoMax) {if (inputOneMin > inputTwoMax || inputOneMax < inputTwoMin) { return false; }return true;}
,"threnCollideContextual":
function(thren, before, after) { var hasCollide = false;var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name) { if (this.ZStraddle(before, after, all[i])===true && this.XStraddle(before, after, all[i])===true && this.YStraddle(before, after, all[i])===true) { hasCollide = true; } if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { hasCollide = true; } } }return hasCollide;}
,"ZStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.Z - before.Z;let secondDiff = target.Z - after.Z;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"XStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.X - before.X;let secondDiff = target.X - after.Y;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"YStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.Y - before.Y;let secondDiff = target.Y - after.Y;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"getFirstThrenCollide":
function(thren) { var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { return thren; } } }
,"threnCollide":
 function(thren) {var hasCollide = false;var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { hasCollide = true; } }return hasCollide;}
,"moveAll2D":
function(x, y) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } for (var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].X += x; this.AdhocSceneRefs[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } }
,"moveAll2DAround":
function(x, y, entName) { var ent = find(game.scene().Entities, entName); if (this.wouldCollide(ent.transpose(-x, -y)) === false) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } } }
,"quickMoveAll2DAround":
function(x, y, ent) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } for(var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].X += x; this.AdhocSceneRefs[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } }
,"tryMoveAll2DAround":
function(x, y, entName) {if (this.getMainTilegrid() === -1) { return this.moveAll2DAround(x, y, entName); } else { this.dynamic2DMove(x, y, entName, this.getMainTilegrid()); } }
,"dynamic2DMove":
function(x, y, entName, tileGrid) {var ent = game.findEntity(entName);if (this.wouldCollide(ent.transpose(-x, -y)) === false) {this.dynamic2DMoveX(x, ent, tileGrid);this.dynamic2DMoveY(y, ent, tileGrid); }}
,"dynamic2DMoveUp":
function(y, ent, tileGrid) {var amtMoveHeroTowardsCenter = (ent.pastCenterY() === false && ent.isCenteredY() === false) ? 0 : (ent.myCenterY() - viewportCenterY());if (amtMoveHeroTowardsCenter >= y) { ent.Y -= y; return; } else { ent.Y -= amtMoveHeroTowardsCenter; }var remainder = y - amtMoveHeroTowardsCenter;var tileGridSlack = 0 - tileGrid.Y;if (remainder <= Math.abs(tileGridSlack)) { this.quickMoveAll2DAround(0, remainder, ent); return; } else { this.quickMoveAll2DAround(0, Math.abs(tileGridSlack), ent); }remainder = remainder - Math.abs(tileGridSlack);ent.Y -= remainder;}
,"dynamic2DMoveDown":
function(y, ent, tileGrid) {var absY = Math.abs(y);var amtMoveHeroTowardsCenter = (ent.isCenteredY() || ent.pastCenterY()) ? 0 : viewportCenterY() - ent.myCenterY();if (amtMoveHeroTowardsCenter >= absY) { ent.Y -= y; return; } else { ent.Y += amtMoveHeroTowardsCenter; }var remainder = absY - amtMoveHeroTowardsCenter;var tileGridSlack = tileGrid.B() - getYDrawBounds2D();if (remainder <= tileGridSlack) { this.quickMoveAll2DAround(0, -remainder, ent); return; } else { this.quickMoveAll2DAround(0, tileGridSlack, ent); }remainder = remainder - tileGridSlack;ent.Y += remainder;}
,"dynamic2DMoveLeft":
function(x, ent, tileGrid) {var amtMoveHeroTowardsCenter = (ent.pastCenterX() === false && ent.isCenteredX() === false) ? 0 : (ent.myCenterX() - viewportCenterX());if (amtMoveHeroTowardsCenter >= x) { ent.X -= x; return; } else { ent.X -= amtMoveHeroTowardsCenter; }var remainder = x - amtMoveHeroTowardsCenter;var tileGridSlack = 0 - tileGrid.X;if (remainder <= Math.abs(tileGridSlack)) { this.quickMoveAll2DAround(remainder, 0, ent); return; } else { this.quickMoveAll2DAround(Math.abs(tileGridSlack), 0, ent); }remainder = remainder - Math.abs(tileGridSlack);ent.X -= remainder;}
,"dynamic2DMoveRight":
function(x, ent, tileGrid) {var absX = Math.abs(x);var amtMoveHeroTowardsCenter = (ent.isCenteredX() || ent.pastCenterX()) ? 0 : viewportCenterX() - ent.myCenterX();if (amtMoveHeroTowardsCenter >= absX) { ent.X -= x; return; } else { ent.X += amtMoveHeroTowardsCenter; }var remainder = absX - amtMoveHeroTowardsCenter;var tileGridSlack = tileGrid.R() - getXDrawBounds2D();if (remainder <= tileGridSlack) { this.quickMoveAll2DAround(-remainder, 0, ent); return; } else { this.quickMoveAll2DAround(tileGridSlack, 0, ent); }remainder = remainder - tileGridSlack;ent.X += remainder;}
,"dynamic2DMoveX":
function(x, ent, tileGrid) { var movingLeft = x > 0;if (movingLeft) { this.dynamic2DMoveLeft(x, ent, tileGrid); return; } else { this.dynamic2DMoveRight(x, ent, tileGrid); return; }var tileGridSlackX = x < 0 ? -1 * tileGrid.X : tileGrid.R() - getXDrawBounds2D(); if (ent.isCenteredX() !== true) { var centerSlackX = (x < 0 ? ((getXDrawBounds2D() / 2) - ent.X) : ent.X - (getXDrawBounds2D() / 2)); if (centerSlackX > Math.abs(x)) { ent.X -= x; }else if (centerSlackX < Math.abs(x) && centerSlackX > 0) { ent.X -= centerSlackX; }  }else if (tileGridSlackX > Math.abs(x)) { this.moveAll2DAround(x, 0, ent.Name); }else if (tileGridSlackX < Math.abs(x) && tileGridSlackX > 0) { this.moveAll2DAround(tileGridSlackX, 0, ent.Name); }}
,"dynamic2DMoveY":
function(y, ent, tileGrid) { var movingUp = y > 0;if (movingUp) { this.dynamic2DMoveUp(y, ent, tileGrid); return; } else { this.dynamic2DMoveDown(y, ent, tileGrid); return; }var tileGridSlackY = y < 0 ? -1 * tileGrid.Y : tileGrid.B() - getYDrawBounds2D();if (ent.isCenteredY() !== true) { var centerSlackY = (y < 0 ? ((getYDrawBounds2D() / 2) - ent.Y) : ent.Y - (getYDrawBounds2D() / 2)); if (centerSlackY > Math.abs(y)) { ent.Y -= y; }else if (centerSlackY < Math.abs(y) && centerSlackY > 0) { ent.Y -= centerSlackY; }  }else if (tileGridSlackY > Math.abs(y)) { this.moveAll2DAround(y, 0, ent.Name); }else if (tileGridSlackY < Math.abs(y) && tileGridSlackY > 0) { this.moveAll2DAround(tileGridSlackY, 0, ent.Name); }}
,"prepareForRenderer":
 function() {return {  };}
,"loadScene":
function() { loadThrentitiesIntoNewScene(this.allThrentities(), this.PointLights); }
,"allThrentities":
function() { return game.active().Omnipresent3D.concat(this.validLocalThrentities()); }
,"validLocalThrentities":
function() { return this.Threntities.filter(function(obj) { return Object.keys(obj).length > 0; }); }
,"getThrentity":
function (index) { var ent = game.active().getOmni3D(index); if (ent != null) { return ent; } var obj = this.Threntities[index]; if (obj == null || Object.keys(obj).length == 0) { return game.active().getOmni3D(index); } else { return this.Threntities[index]; } }
,"allEntities":
function() { return game.active().Omnipresent2D.concat(this.validLocalEntities()); }
,"validLocalEntities":
function() { return this.Entities.filter(function(obj) { return Object.keys(obj).length > 0; }); }
,"getEntity":
function (index) { var ent = game.active().getOmni2D(index); if (ent != null) { return ent; } var obj = this.Entities[index]; if (obj == null || Object.keys(obj).length == 0) { return game.active().getOmni2D(index); } else { return this.Entities[index]; } }
,"getMainTilegrid":
function() { for(var i in this.TileGrids) { if (this.TileGrids[i].MainGrid === true) { return this.TileGrids[i]; } } return -1; }
,"shiftToTop":
function() {  var main = this.getMainTilegrid(); if (main !== -1) { var moveY = main.Y; this.moveAll2D(0, moveY); return moveY; } }
,"shiftToBottom":
function() {  var main = this.getMainTilegrid(); if (main !== -1) { var moveY = -(main.B() - getYDrawBounds2D()); this.moveAll2D(0, moveY); return moveY; } }
,"shiftToRight":
function() { if (this.shiftedToRight == true) {  }  var main = this.getMainTilegrid(); if (main !== -1) {  var moveX = -(main.R() - getXDrawBounds2D()); this.moveAll2D(moveX, 0); this.shiftedToLeft = false; this.shiftedToRight = true; return moveX; } }
,"shiftToLeft":
function() { if (this.shiftedToLeft == true) {  } var main = this.getMainTilegrid(); if (main !== -1) {  var moveX = main.X; this.moveAll2D(moveX, 0);  this.shiftedToLeft = true; this.shiftedToRight = false; return moveX; } }
,"shiftedToLeft":
false
,"shiftedToRight":
false
,"shiftedToTop":
false
,"shiftedToBottom":
false
,"wouldCollide":
 function(entity) {var hasCollide = false;for (var i in this.TileGrids) { if (this.TileGrids[i].wouldCollide(entity) === true) { hasCollide = true; } }var all = this.allEntities(); for (var i in all) { if (all[i].NotWorldLevel !== true && all[i].NonCorporeal !== true && all[i].Disabled !== true && all[i].Name !== entity.name && all[i].wouldCollide(entity)) { hasCollide = true; } }return hasCollide;}
,"isSetup":
false
,"XResolution":640,"YResolution":400,"HasAmbientLight":false,"AmbientLightIntensity":75,"AmbientLightColor":"0xffffcf","Bounds2DX":0,"Bounds2DY":0,"TileGrids":[{"setup":
function(parent) { if (this.DelimitedGrid && this.DelimitedGrid.length > 0){ var rows = this.DelimitedGrid.split(';');for (var j in rows) { this.tiles.push([]); var cells = rows[j].split(',');  for (var i in cells) { var tile=this.getTile(parent, cells[i]); this.tiles[j].push(tile); } } } }
,"getTile":
function(parentScene, tileId) {  var eName = this.EntityNameCSVKey.split(',')[tileId]; var tile = find(parentScene.allEntities(), eName); /* tile.draw = function(x,y,w,h) { this.MyImage.active().render(x,y,w,h); }; */ return tile;  }
,"draw":
function() { if (this.SkipDraw==true) { return; } for(var j in this.tiles) { for(var i in this.tiles[j]) { if (this.tiles[j][i] != null && this.tiles[j][i].MyImage != null) { this.tiles[j][i].MyImage.active().render(this.X + (i * this.TW),this.Y + (j * this.TH),this.TW,this.TH); } } } }
,"update":
 function() {}
,"tiles":
 [] 
,"R":
 function() {return this.X + (this.getWidth() * this.TW);}
,"B":
 function() {return this.Y + (this.getHeight() * this.TH);}
,"wouldCollide":
 function(entity) {for(var j in this.tiles)      {       for (var i in this.tiles[j])       {        if (this.tiles[j][i] != null && this.tiles[j][i].ForceCollision===true)        {         var x = this.X + (i * this.TW);         var y = this.Y + (j * this.TH);         if (checkOverlap({X:x,Y:y,W:this.TW,H:this.TH}, entity) === true)         {          console.log('overlap found');         var events = this.tiles[j][i].collisionEvents;         if (events !== null)         {         }         if (this.tiles[j][i].LedgeCollision === true)         {          if (/*notideal*/downkey() && !leftkey() && !rightkey())          {           console.log('ledge collision detected');           /*arbitrary*/var speed = 4;           /* make entity.MyLogic have a non null ActionBlock? */           entity.Me.MyLogic.ActionBlock.MyActions.push({Depth:((this.TH/speed)*2)+1,SelfDestruct:true,Ct:0,Destroyed:false,update:function() { console.log('updating action');  if (this.BlockInput === true) { BlockInput(); } if (this.SelfDestruct === true && this.Ct + 1 == this.Depth) { this.Destroyed = true; } if (this.Destroyed !== true) { this.MyScript(); this.Ct++; } },MyTarget:entity,BlockInput:true,LocalData:speed,MyScript:function() { console.log('performing action...'); this.MyTarget.Me.Y += this.LocalData; }});          }         }         return true;         }        }       }      }       return false;}
,"getWidth":
function() { if (this.getHeight() > 0) { return this.tiles[0].length; } else { return 0; } }
,"getHeight":
function() { return this.tiles.length; }
,"EntityIndexCSVKey":"","EntityNameCSVKey":"tile1,tile2,tile3,tile4","DelimitedGrid":"0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0","SkipDraw":false,"MainGrid":true,"TW":32,"TH":32,"X":0,"Y":0,"Name":"","LocalData":"","TypeName":"TileGrid","Id":308}],"AdhocSceneRefs":[],"Entities":[{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2208}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2202},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2202},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'grass32');}
,"NameOfTarget":"grass32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6100}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2202},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile1","LocalData":"","TypeName":"Entity","Id":2202},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2209}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2203},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2203},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'stone32');}
,"NameOfTarget":"stone32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6101}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2203},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile2","LocalData":"","TypeName":"Entity","Id":2203},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2210}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2204},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2204},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":8,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water1');}
,"NameOfTarget":"water1","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6102},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water2');}
,"NameOfTarget":"water2","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6103},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water3');}
,"NameOfTarget":"water3","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6104},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water4');}
,"NameOfTarget":"water4","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6105},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water5');}
,"NameOfTarget":"water5","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6106},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water6');}
,"NameOfTarget":"water6","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6107},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water7');}
,"NameOfTarget":"water7","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6108},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water8');}
,"NameOfTarget":"water8","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6109},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water9');}
,"NameOfTarget":"water9","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6110},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water10');}
,"NameOfTarget":"water10","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6111},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water11');}
,"NameOfTarget":"water11","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6112},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water12');}
,"NameOfTarget":"water12","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6113},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water13');}
,"NameOfTarget":"water13","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6114},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water14');}
,"NameOfTarget":"water14","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6115},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water15');}
,"NameOfTarget":"water15","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6116}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2204},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile3","LocalData":"","TypeName":"Entity","Id":2204},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2211}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2205},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2205},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'stoneWall32');}
,"NameOfTarget":"stoneWall32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6117}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2205},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":true,"LedgeCollision":true,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile4","LocalData":"","TypeName":"Entity","Id":2205}],"Threntities":[],"PointLights":[],"MyAudio":[],"MyLogic":{"update":
 function() {for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":null,"TypeName":"SceneProceduralStatement","Id":0},{"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"SceneProceduralStatement","Id":344}],"Name":"","LocalData":"","TypeName":"SceneLogicBox","Id":344},"Name":"","LocalData":"","TypeName":"Scene","Id":344},{"reloadThrentities":
function() { var allT = this.allThrentities(); for(var i in allT) { setupThrentity(allT[i]); } }
,"setup":
 function() {if (this.isSetup !== true) {for(var i in this.TileGrids) { this.TileGrids[i].setup(this); } for(var i in this.PointLights) { this.PointLights[i].setup(this); } if (this.MyAudio !== null) { for (var i = 0; i < this.MyAudio.length; i++) { this.MyAudio[i].setup(); } }if (game.active().Omnipresent2D.length > 0) { var indices = this.entityIndexArray(); var allE = this.allEntities();  for(var i in allE) { if (allE[i].MyIndex != '') { var ind = indices.indexOf(allE[i].MyIndex); if(ind != -1) { indices.splice(ind, 1); } } else { allE[i].setup(indices[i]); } }  } else { for(var i in this.Entities) { this.Entities[i].setup(i); } }if (game.active().Omnipresent3D.length > 0) { var indices = this.threntityIndexArray(); var allT = this.allThrentities(); for(var i in allT) { if (allT[i].MyIndex != '') { var ind = indices.indexOf(allT[i].MyIndex); if (ind != -1) { indices.splice(ind, 1); } } else { allT[i].setup(indices[i]); } }  } else { for(var i in this.Threntities) { this.Threntities[i].setup(i); } }if (this.HasAmbientLight == true) { addAmbientLightToCurrentScene(this.AmbientLightColor, this.AmbientLightIntensity / parseFloat(100)); }this.isSetup = true; }}
,"update":
 function() {this.MyLogic.update();for(var i in this.MyAudio) { this.MyAudio[i].update(); } var allE = this.allEntities(); for(var i in allE) { allE[i].update(); }var allT = this.allThrentities(); for(var i in allT) { allT[i].update(); }for(var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].update(this.AdhocSceneRefs[i].TargetName); } for(var i in this.TileGrids) { this.TileGrids[i].update(); } }
,"draw":
 function() {for(var i in this.TileGrids) { this.TileGrids[i].draw(); } var allE = this.allEntities(); for(var i in allE) { if (allE[i].Disabled !== true) { allE[i].draw(); } }var allT = this.allThrentities(); for(var i in allT) { allT[i].draw(); } }
,"entityIndexArray":
function() { var ray = []; for(var x in game.active().Omnipresent2D) { ray.push(game.active().Omnipresent2D[x].MyIndex); } var rayLen = ray.length; for(i=0;i<rayLen+this.Entities.length;i++) { if (ray.includes((i).toString())) {  } else {  ray.push(i); } } return ray; }
,"threntityIndexArray":
function() { var ray = []; for(var x in game.active().Omnipresent3D) { ray.push(game.active().Omnipresent3D[x].MyIndex); } var rayLen = ray.length; for(i=0;i<rayLen+this.Threntities.length;i++) { if (ray.includes((i).toString())) {  } else {  ray.push(i); } } return ray; }
,"checkMovePoint3d":
function(point3dBefore, point3dAfter) {  var all = this.allThrentities(); for(var i in all) { if (this.checkPointCollision(all[i], point3dBefore, point3dAfter)==true) { return false; } } return true;  }
,"checkPointCollision":
function(targetThrent, point3dBefore, point3dAfter) { var xBef = point3dBefore.X;var xAft = point3dAfter.X;var yBef = point3dBefore.Y;var yAft = point3dAfter.Y;var zBef = point3dBefore.Z;var zAft = point3dAfter.Z;var minX = targetThrent.L();var maxX = targetThrent.R();var minY = targetThrent.B();var maxY = targetThrent.T();var minZ = targetThrent.A();var maxZ = targetThrent.F();var xOverlap = false; var yOverlap = false; var zOverlap = false;if (xBef<xAft) { xOverlap = this.checkRangeOverlap(xBef, xAft, minX, maxX); } else { xOverlap = this.checkRangeOverlap(xAft, xBef, minX, maxX); }if (yBef<yAft) { yOverlap = this.checkRangeOverlap(yBef, yAft, minY, maxY); } else { yOverlap = this.checkRangeOverlap(yAft, yBef, minY, maxY); }if (zBef<zAft) { zOverlap = this.checkRangeOverlap(zBef, zAft, minZ, maxZ); } else { zOverlap = this.checkRangeOverlap(zAft, zBef, minZ, maxZ); }if (xOverlap==true && yOverlap==true && zOverlap==true) { return true; } return false;}
,"checkRangeOverlap":
function (inputOneMin, inputOneMax, inputTwoMin, inputTwoMax) {if (inputOneMin > inputTwoMax || inputOneMax < inputTwoMin) { return false; }return true;}
,"threnCollideContextual":
function(thren, before, after) { var hasCollide = false;var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name) { if (this.ZStraddle(before, after, all[i])===true && this.XStraddle(before, after, all[i])===true && this.YStraddle(before, after, all[i])===true) { hasCollide = true; } if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { hasCollide = true; } } }return hasCollide;}
,"ZStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.Z - before.Z;let secondDiff = target.Z - after.Z;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"XStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.X - before.X;let secondDiff = target.X - after.Y;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"YStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.Y - before.Y;let secondDiff = target.Y - after.Y;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"getFirstThrenCollide":
function(thren) { var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { return thren; } } }
,"threnCollide":
 function(thren) {var hasCollide = false;var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { hasCollide = true; } }return hasCollide;}
,"moveAll2D":
function(x, y) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } for (var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].X += x; this.AdhocSceneRefs[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } }
,"moveAll2DAround":
function(x, y, entName) { var ent = find(game.scene().Entities, entName); if (this.wouldCollide(ent.transpose(-x, -y)) === false) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } } }
,"quickMoveAll2DAround":
function(x, y, ent) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } for(var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].X += x; this.AdhocSceneRefs[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } }
,"tryMoveAll2DAround":
function(x, y, entName) {if (this.getMainTilegrid() === -1) { return this.moveAll2DAround(x, y, entName); } else { this.dynamic2DMove(x, y, entName, this.getMainTilegrid()); } }
,"dynamic2DMove":
function(x, y, entName, tileGrid) {var ent = game.findEntity(entName);if (this.wouldCollide(ent.transpose(-x, -y)) === false) {this.dynamic2DMoveX(x, ent, tileGrid);this.dynamic2DMoveY(y, ent, tileGrid); }}
,"dynamic2DMoveUp":
function(y, ent, tileGrid) {var amtMoveHeroTowardsCenter = (ent.pastCenterY() === false && ent.isCenteredY() === false) ? 0 : (ent.myCenterY() - viewportCenterY());if (amtMoveHeroTowardsCenter >= y) { ent.Y -= y; return; } else { ent.Y -= amtMoveHeroTowardsCenter; }var remainder = y - amtMoveHeroTowardsCenter;var tileGridSlack = 0 - tileGrid.Y;if (remainder <= Math.abs(tileGridSlack)) { this.quickMoveAll2DAround(0, remainder, ent); return; } else { this.quickMoveAll2DAround(0, Math.abs(tileGridSlack), ent); }remainder = remainder - Math.abs(tileGridSlack);ent.Y -= remainder;}
,"dynamic2DMoveDown":
function(y, ent, tileGrid) {var absY = Math.abs(y);var amtMoveHeroTowardsCenter = (ent.isCenteredY() || ent.pastCenterY()) ? 0 : viewportCenterY() - ent.myCenterY();if (amtMoveHeroTowardsCenter >= absY) { ent.Y -= y; return; } else { ent.Y += amtMoveHeroTowardsCenter; }var remainder = absY - amtMoveHeroTowardsCenter;var tileGridSlack = tileGrid.B() - getYDrawBounds2D();if (remainder <= tileGridSlack) { this.quickMoveAll2DAround(0, -remainder, ent); return; } else { this.quickMoveAll2DAround(0, tileGridSlack, ent); }remainder = remainder - tileGridSlack;ent.Y += remainder;}
,"dynamic2DMoveLeft":
function(x, ent, tileGrid) {var amtMoveHeroTowardsCenter = (ent.pastCenterX() === false && ent.isCenteredX() === false) ? 0 : (ent.myCenterX() - viewportCenterX());if (amtMoveHeroTowardsCenter >= x) { ent.X -= x; return; } else { ent.X -= amtMoveHeroTowardsCenter; }var remainder = x - amtMoveHeroTowardsCenter;var tileGridSlack = 0 - tileGrid.X;if (remainder <= Math.abs(tileGridSlack)) { this.quickMoveAll2DAround(remainder, 0, ent); return; } else { this.quickMoveAll2DAround(Math.abs(tileGridSlack), 0, ent); }remainder = remainder - Math.abs(tileGridSlack);ent.X -= remainder;}
,"dynamic2DMoveRight":
function(x, ent, tileGrid) {var absX = Math.abs(x);var amtMoveHeroTowardsCenter = (ent.isCenteredX() || ent.pastCenterX()) ? 0 : viewportCenterX() - ent.myCenterX();if (amtMoveHeroTowardsCenter >= absX) { ent.X -= x; return; } else { ent.X += amtMoveHeroTowardsCenter; }var remainder = absX - amtMoveHeroTowardsCenter;var tileGridSlack = tileGrid.R() - getXDrawBounds2D();if (remainder <= tileGridSlack) { this.quickMoveAll2DAround(-remainder, 0, ent); return; } else { this.quickMoveAll2DAround(tileGridSlack, 0, ent); }remainder = remainder - tileGridSlack;ent.X += remainder;}
,"dynamic2DMoveX":
function(x, ent, tileGrid) { var movingLeft = x > 0;if (movingLeft) { this.dynamic2DMoveLeft(x, ent, tileGrid); return; } else { this.dynamic2DMoveRight(x, ent, tileGrid); return; }var tileGridSlackX = x < 0 ? -1 * tileGrid.X : tileGrid.R() - getXDrawBounds2D(); if (ent.isCenteredX() !== true) { var centerSlackX = (x < 0 ? ((getXDrawBounds2D() / 2) - ent.X) : ent.X - (getXDrawBounds2D() / 2)); if (centerSlackX > Math.abs(x)) { ent.X -= x; }else if (centerSlackX < Math.abs(x) && centerSlackX > 0) { ent.X -= centerSlackX; }  }else if (tileGridSlackX > Math.abs(x)) { this.moveAll2DAround(x, 0, ent.Name); }else if (tileGridSlackX < Math.abs(x) && tileGridSlackX > 0) { this.moveAll2DAround(tileGridSlackX, 0, ent.Name); }}
,"dynamic2DMoveY":
function(y, ent, tileGrid) { var movingUp = y > 0;if (movingUp) { this.dynamic2DMoveUp(y, ent, tileGrid); return; } else { this.dynamic2DMoveDown(y, ent, tileGrid); return; }var tileGridSlackY = y < 0 ? -1 * tileGrid.Y : tileGrid.B() - getYDrawBounds2D();if (ent.isCenteredY() !== true) { var centerSlackY = (y < 0 ? ((getYDrawBounds2D() / 2) - ent.Y) : ent.Y - (getYDrawBounds2D() / 2)); if (centerSlackY > Math.abs(y)) { ent.Y -= y; }else if (centerSlackY < Math.abs(y) && centerSlackY > 0) { ent.Y -= centerSlackY; }  }else if (tileGridSlackY > Math.abs(y)) { this.moveAll2DAround(y, 0, ent.Name); }else if (tileGridSlackY < Math.abs(y) && tileGridSlackY > 0) { this.moveAll2DAround(tileGridSlackY, 0, ent.Name); }}
,"prepareForRenderer":
 function() {return {  };}
,"loadScene":
function() { loadThrentitiesIntoNewScene(this.allThrentities(), this.PointLights); }
,"allThrentities":
function() { return game.active().Omnipresent3D.concat(this.validLocalThrentities()); }
,"validLocalThrentities":
function() { return this.Threntities.filter(function(obj) { return Object.keys(obj).length > 0; }); }
,"getThrentity":
function (index) { var ent = game.active().getOmni3D(index); if (ent != null) { return ent; } var obj = this.Threntities[index]; if (obj == null || Object.keys(obj).length == 0) { return game.active().getOmni3D(index); } else { return this.Threntities[index]; } }
,"allEntities":
function() { return game.active().Omnipresent2D.concat(this.validLocalEntities()); }
,"validLocalEntities":
function() { return this.Entities.filter(function(obj) { return Object.keys(obj).length > 0; }); }
,"getEntity":
function (index) { var ent = game.active().getOmni2D(index); if (ent != null) { return ent; } var obj = this.Entities[index]; if (obj == null || Object.keys(obj).length == 0) { return game.active().getOmni2D(index); } else { return this.Entities[index]; } }
,"getMainTilegrid":
function() { for(var i in this.TileGrids) { if (this.TileGrids[i].MainGrid === true) { return this.TileGrids[i]; } } return -1; }
,"shiftToTop":
function() {  var main = this.getMainTilegrid(); if (main !== -1) { var moveY = main.Y; this.moveAll2D(0, moveY); return moveY; } }
,"shiftToBottom":
function() {  var main = this.getMainTilegrid(); if (main !== -1) { var moveY = -(main.B() - getYDrawBounds2D()); this.moveAll2D(0, moveY); return moveY; } }
,"shiftToRight":
function() { if (this.shiftedToRight == true) {  }  var main = this.getMainTilegrid(); if (main !== -1) {  var moveX = -(main.R() - getXDrawBounds2D()); this.moveAll2D(moveX, 0); this.shiftedToLeft = false; this.shiftedToRight = true; return moveX; } }
,"shiftToLeft":
function() { if (this.shiftedToLeft == true) {  } var main = this.getMainTilegrid(); if (main !== -1) {  var moveX = main.X; this.moveAll2D(moveX, 0);  this.shiftedToLeft = true; this.shiftedToRight = false; return moveX; } }
,"shiftedToLeft":
false
,"shiftedToRight":
false
,"shiftedToTop":
false
,"shiftedToBottom":
false
,"wouldCollide":
 function(entity) {var hasCollide = false;for (var i in this.TileGrids) { if (this.TileGrids[i].wouldCollide(entity) === true) { hasCollide = true; } }var all = this.allEntities(); for (var i in all) { if (all[i].NotWorldLevel !== true && all[i].NonCorporeal !== true && all[i].Disabled !== true && all[i].Name !== entity.name && all[i].wouldCollide(entity)) { hasCollide = true; } }return hasCollide;}
,"isSetup":
false
,"XResolution":640,"YResolution":400,"HasAmbientLight":false,"AmbientLightIntensity":75,"AmbientLightColor":"0xffffcf","Bounds2DX":0,"Bounds2DY":0,"TileGrids":[{"setup":
function(parent) { if (this.DelimitedGrid && this.DelimitedGrid.length > 0){ var rows = this.DelimitedGrid.split(';');for (var j in rows) { this.tiles.push([]); var cells = rows[j].split(',');  for (var i in cells) { var tile=this.getTile(parent, cells[i]); this.tiles[j].push(tile); } } } }
,"getTile":
function(parentScene, tileId) {  var eName = this.EntityNameCSVKey.split(',')[tileId]; var tile = find(parentScene.allEntities(), eName); /* tile.draw = function(x,y,w,h) { this.MyImage.active().render(x,y,w,h); }; */ return tile;  }
,"draw":
function() { if (this.SkipDraw==true) { return; } for(var j in this.tiles) { for(var i in this.tiles[j]) { if (this.tiles[j][i] != null && this.tiles[j][i].MyImage != null) { this.tiles[j][i].MyImage.active().render(this.X + (i * this.TW),this.Y + (j * this.TH),this.TW,this.TH); } } } }
,"update":
 function() {}
,"tiles":
 [] 
,"R":
 function() {return this.X + (this.getWidth() * this.TW);}
,"B":
 function() {return this.Y + (this.getHeight() * this.TH);}
,"wouldCollide":
 function(entity) {for(var j in this.tiles)      {       for (var i in this.tiles[j])       {        if (this.tiles[j][i] != null && this.tiles[j][i].ForceCollision===true)        {         var x = this.X + (i * this.TW);         var y = this.Y + (j * this.TH);         if (checkOverlap({X:x,Y:y,W:this.TW,H:this.TH}, entity) === true)         {          console.log('overlap found');         var events = this.tiles[j][i].collisionEvents;         if (events !== null)         {         }         if (this.tiles[j][i].LedgeCollision === true)         {          if (/*notideal*/downkey() && !leftkey() && !rightkey())          {           console.log('ledge collision detected');           /*arbitrary*/var speed = 4;           /* make entity.MyLogic have a non null ActionBlock? */           entity.Me.MyLogic.ActionBlock.MyActions.push({Depth:((this.TH/speed)*2)+1,SelfDestruct:true,Ct:0,Destroyed:false,update:function() { console.log('updating action');  if (this.BlockInput === true) { BlockInput(); } if (this.SelfDestruct === true && this.Ct + 1 == this.Depth) { this.Destroyed = true; } if (this.Destroyed !== true) { this.MyScript(); this.Ct++; } },MyTarget:entity,BlockInput:true,LocalData:speed,MyScript:function() { console.log('performing action...'); this.MyTarget.Me.Y += this.LocalData; }});          }         }         return true;         }        }       }      }       return false;}
,"getWidth":
function() { if (this.getHeight() > 0) { return this.tiles[0].length; } else { return 0; } }
,"getHeight":
function() { return this.tiles.length; }
,"EntityIndexCSVKey":"","EntityNameCSVKey":"tile1,tile2,tile3,tile4","DelimitedGrid":"0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0","SkipDraw":false,"MainGrid":true,"TW":32,"TH":32,"X":0,"Y":0,"Name":"","LocalData":"","TypeName":"TileGrid","Id":309}],"AdhocSceneRefs":[],"Entities":[{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2212}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2206},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2206},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'grass32');}
,"NameOfTarget":"grass32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6118}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2206},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile1","LocalData":"","TypeName":"Entity","Id":2206},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2213}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2207},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2207},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'stone32');}
,"NameOfTarget":"stone32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6119}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2207},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile2","LocalData":"","TypeName":"Entity","Id":2207},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2214}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2208},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2208},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":8,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water1');}
,"NameOfTarget":"water1","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6120},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water2');}
,"NameOfTarget":"water2","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6121},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water3');}
,"NameOfTarget":"water3","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6122},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water4');}
,"NameOfTarget":"water4","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6123},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water5');}
,"NameOfTarget":"water5","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6124},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water6');}
,"NameOfTarget":"water6","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6125},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water7');}
,"NameOfTarget":"water7","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6126},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water8');}
,"NameOfTarget":"water8","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6127},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water9');}
,"NameOfTarget":"water9","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6128},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water10');}
,"NameOfTarget":"water10","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6129},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water11');}
,"NameOfTarget":"water11","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6130},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water12');}
,"NameOfTarget":"water12","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6131},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water13');}
,"NameOfTarget":"water13","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6132},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water14');}
,"NameOfTarget":"water14","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6133},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water15');}
,"NameOfTarget":"water15","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6134}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2208},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile3","LocalData":"","TypeName":"Entity","Id":2208},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2215}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2209},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2209},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'stoneWall32');}
,"NameOfTarget":"stoneWall32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6135}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2209},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":true,"LedgeCollision":true,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile4","LocalData":"","TypeName":"Entity","Id":2209}],"Threntities":[],"PointLights":[],"MyAudio":[],"MyLogic":{"update":
 function() {for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":null,"TypeName":"SceneProceduralStatement","Id":0},{"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"SceneProceduralStatement","Id":345}],"Name":"","LocalData":"","TypeName":"SceneLogicBox","Id":345},"Name":"","LocalData":"","TypeName":"Scene","Id":345},{"reloadThrentities":
function() { var allT = this.allThrentities(); for(var i in allT) { setupThrentity(allT[i]); } }
,"setup":
 function() {if (this.isSetup !== true) {for(var i in this.TileGrids) { this.TileGrids[i].setup(this); } for(var i in this.PointLights) { this.PointLights[i].setup(this); } if (this.MyAudio !== null) { for (var i = 0; i < this.MyAudio.length; i++) { this.MyAudio[i].setup(); } }if (game.active().Omnipresent2D.length > 0) { var indices = this.entityIndexArray(); var allE = this.allEntities();  for(var i in allE) { if (allE[i].MyIndex != '') { var ind = indices.indexOf(allE[i].MyIndex); if(ind != -1) { indices.splice(ind, 1); } } else { allE[i].setup(indices[i]); } }  } else { for(var i in this.Entities) { this.Entities[i].setup(i); } }if (game.active().Omnipresent3D.length > 0) { var indices = this.threntityIndexArray(); var allT = this.allThrentities(); for(var i in allT) { if (allT[i].MyIndex != '') { var ind = indices.indexOf(allT[i].MyIndex); if (ind != -1) { indices.splice(ind, 1); } } else { allT[i].setup(indices[i]); } }  } else { for(var i in this.Threntities) { this.Threntities[i].setup(i); } }if (this.HasAmbientLight == true) { addAmbientLightToCurrentScene(this.AmbientLightColor, this.AmbientLightIntensity / parseFloat(100)); }this.isSetup = true; }}
,"update":
 function() {this.MyLogic.update();for(var i in this.MyAudio) { this.MyAudio[i].update(); } var allE = this.allEntities(); for(var i in allE) { allE[i].update(); }var allT = this.allThrentities(); for(var i in allT) { allT[i].update(); }for(var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].update(this.AdhocSceneRefs[i].TargetName); } for(var i in this.TileGrids) { this.TileGrids[i].update(); } }
,"draw":
 function() {for(var i in this.TileGrids) { this.TileGrids[i].draw(); } var allE = this.allEntities(); for(var i in allE) { if (allE[i].Disabled !== true) { allE[i].draw(); } }var allT = this.allThrentities(); for(var i in allT) { allT[i].draw(); } }
,"entityIndexArray":
function() { var ray = []; for(var x in game.active().Omnipresent2D) { ray.push(game.active().Omnipresent2D[x].MyIndex); } var rayLen = ray.length; for(i=0;i<rayLen+this.Entities.length;i++) { if (ray.includes((i).toString())) {  } else {  ray.push(i); } } return ray; }
,"threntityIndexArray":
function() { var ray = []; for(var x in game.active().Omnipresent3D) { ray.push(game.active().Omnipresent3D[x].MyIndex); } var rayLen = ray.length; for(i=0;i<rayLen+this.Threntities.length;i++) { if (ray.includes((i).toString())) {  } else {  ray.push(i); } } return ray; }
,"checkMovePoint3d":
function(point3dBefore, point3dAfter) {  var all = this.allThrentities(); for(var i in all) { if (this.checkPointCollision(all[i], point3dBefore, point3dAfter)==true) { return false; } } return true;  }
,"checkPointCollision":
function(targetThrent, point3dBefore, point3dAfter) { var xBef = point3dBefore.X;var xAft = point3dAfter.X;var yBef = point3dBefore.Y;var yAft = point3dAfter.Y;var zBef = point3dBefore.Z;var zAft = point3dAfter.Z;var minX = targetThrent.L();var maxX = targetThrent.R();var minY = targetThrent.B();var maxY = targetThrent.T();var minZ = targetThrent.A();var maxZ = targetThrent.F();var xOverlap = false; var yOverlap = false; var zOverlap = false;if (xBef<xAft) { xOverlap = this.checkRangeOverlap(xBef, xAft, minX, maxX); } else { xOverlap = this.checkRangeOverlap(xAft, xBef, minX, maxX); }if (yBef<yAft) { yOverlap = this.checkRangeOverlap(yBef, yAft, minY, maxY); } else { yOverlap = this.checkRangeOverlap(yAft, yBef, minY, maxY); }if (zBef<zAft) { zOverlap = this.checkRangeOverlap(zBef, zAft, minZ, maxZ); } else { zOverlap = this.checkRangeOverlap(zAft, zBef, minZ, maxZ); }if (xOverlap==true && yOverlap==true && zOverlap==true) { return true; } return false;}
,"checkRangeOverlap":
function (inputOneMin, inputOneMax, inputTwoMin, inputTwoMax) {if (inputOneMin > inputTwoMax || inputOneMax < inputTwoMin) { return false; }return true;}
,"threnCollideContextual":
function(thren, before, after) { var hasCollide = false;var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name) { if (this.ZStraddle(before, after, all[i])===true && this.XStraddle(before, after, all[i])===true && this.YStraddle(before, after, all[i])===true) { hasCollide = true; } if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { hasCollide = true; } } }return hasCollide;}
,"ZStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.Z - before.Z;let secondDiff = target.Z - after.Z;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"XStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.X - before.X;let secondDiff = target.X - after.Y;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"YStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.Y - before.Y;let secondDiff = target.Y - after.Y;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"getFirstThrenCollide":
function(thren) { var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { return thren; } } }
,"threnCollide":
 function(thren) {var hasCollide = false;var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { hasCollide = true; } }return hasCollide;}
,"moveAll2D":
function(x, y) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } for (var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].X += x; this.AdhocSceneRefs[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } }
,"moveAll2DAround":
function(x, y, entName) { var ent = find(game.scene().Entities, entName); if (this.wouldCollide(ent.transpose(-x, -y)) === false) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } } }
,"quickMoveAll2DAround":
function(x, y, ent) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } for(var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].X += x; this.AdhocSceneRefs[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } }
,"tryMoveAll2DAround":
function(x, y, entName) {if (this.getMainTilegrid() === -1) { return this.moveAll2DAround(x, y, entName); } else { this.dynamic2DMove(x, y, entName, this.getMainTilegrid()); } }
,"dynamic2DMove":
function(x, y, entName, tileGrid) {var ent = game.findEntity(entName);if (this.wouldCollide(ent.transpose(-x, -y)) === false) {this.dynamic2DMoveX(x, ent, tileGrid);this.dynamic2DMoveY(y, ent, tileGrid); }}
,"dynamic2DMoveUp":
function(y, ent, tileGrid) {var amtMoveHeroTowardsCenter = (ent.pastCenterY() === false && ent.isCenteredY() === false) ? 0 : (ent.myCenterY() - viewportCenterY());if (amtMoveHeroTowardsCenter >= y) { ent.Y -= y; return; } else { ent.Y -= amtMoveHeroTowardsCenter; }var remainder = y - amtMoveHeroTowardsCenter;var tileGridSlack = 0 - tileGrid.Y;if (remainder <= Math.abs(tileGridSlack)) { this.quickMoveAll2DAround(0, remainder, ent); return; } else { this.quickMoveAll2DAround(0, Math.abs(tileGridSlack), ent); }remainder = remainder - Math.abs(tileGridSlack);ent.Y -= remainder;}
,"dynamic2DMoveDown":
function(y, ent, tileGrid) {var absY = Math.abs(y);var amtMoveHeroTowardsCenter = (ent.isCenteredY() || ent.pastCenterY()) ? 0 : viewportCenterY() - ent.myCenterY();if (amtMoveHeroTowardsCenter >= absY) { ent.Y -= y; return; } else { ent.Y += amtMoveHeroTowardsCenter; }var remainder = absY - amtMoveHeroTowardsCenter;var tileGridSlack = tileGrid.B() - getYDrawBounds2D();if (remainder <= tileGridSlack) { this.quickMoveAll2DAround(0, -remainder, ent); return; } else { this.quickMoveAll2DAround(0, tileGridSlack, ent); }remainder = remainder - tileGridSlack;ent.Y += remainder;}
,"dynamic2DMoveLeft":
function(x, ent, tileGrid) {var amtMoveHeroTowardsCenter = (ent.pastCenterX() === false && ent.isCenteredX() === false) ? 0 : (ent.myCenterX() - viewportCenterX());if (amtMoveHeroTowardsCenter >= x) { ent.X -= x; return; } else { ent.X -= amtMoveHeroTowardsCenter; }var remainder = x - amtMoveHeroTowardsCenter;var tileGridSlack = 0 - tileGrid.X;if (remainder <= Math.abs(tileGridSlack)) { this.quickMoveAll2DAround(remainder, 0, ent); return; } else { this.quickMoveAll2DAround(Math.abs(tileGridSlack), 0, ent); }remainder = remainder - Math.abs(tileGridSlack);ent.X -= remainder;}
,"dynamic2DMoveRight":
function(x, ent, tileGrid) {var absX = Math.abs(x);var amtMoveHeroTowardsCenter = (ent.isCenteredX() || ent.pastCenterX()) ? 0 : viewportCenterX() - ent.myCenterX();if (amtMoveHeroTowardsCenter >= absX) { ent.X -= x; return; } else { ent.X += amtMoveHeroTowardsCenter; }var remainder = absX - amtMoveHeroTowardsCenter;var tileGridSlack = tileGrid.R() - getXDrawBounds2D();if (remainder <= tileGridSlack) { this.quickMoveAll2DAround(-remainder, 0, ent); return; } else { this.quickMoveAll2DAround(tileGridSlack, 0, ent); }remainder = remainder - tileGridSlack;ent.X += remainder;}
,"dynamic2DMoveX":
function(x, ent, tileGrid) { var movingLeft = x > 0;if (movingLeft) { this.dynamic2DMoveLeft(x, ent, tileGrid); return; } else { this.dynamic2DMoveRight(x, ent, tileGrid); return; }var tileGridSlackX = x < 0 ? -1 * tileGrid.X : tileGrid.R() - getXDrawBounds2D(); if (ent.isCenteredX() !== true) { var centerSlackX = (x < 0 ? ((getXDrawBounds2D() / 2) - ent.X) : ent.X - (getXDrawBounds2D() / 2)); if (centerSlackX > Math.abs(x)) { ent.X -= x; }else if (centerSlackX < Math.abs(x) && centerSlackX > 0) { ent.X -= centerSlackX; }  }else if (tileGridSlackX > Math.abs(x)) { this.moveAll2DAround(x, 0, ent.Name); }else if (tileGridSlackX < Math.abs(x) && tileGridSlackX > 0) { this.moveAll2DAround(tileGridSlackX, 0, ent.Name); }}
,"dynamic2DMoveY":
function(y, ent, tileGrid) { var movingUp = y > 0;if (movingUp) { this.dynamic2DMoveUp(y, ent, tileGrid); return; } else { this.dynamic2DMoveDown(y, ent, tileGrid); return; }var tileGridSlackY = y < 0 ? -1 * tileGrid.Y : tileGrid.B() - getYDrawBounds2D();if (ent.isCenteredY() !== true) { var centerSlackY = (y < 0 ? ((getYDrawBounds2D() / 2) - ent.Y) : ent.Y - (getYDrawBounds2D() / 2)); if (centerSlackY > Math.abs(y)) { ent.Y -= y; }else if (centerSlackY < Math.abs(y) && centerSlackY > 0) { ent.Y -= centerSlackY; }  }else if (tileGridSlackY > Math.abs(y)) { this.moveAll2DAround(y, 0, ent.Name); }else if (tileGridSlackY < Math.abs(y) && tileGridSlackY > 0) { this.moveAll2DAround(tileGridSlackY, 0, ent.Name); }}
,"prepareForRenderer":
 function() {return {  };}
,"loadScene":
function() { loadThrentitiesIntoNewScene(this.allThrentities(), this.PointLights); }
,"allThrentities":
function() { return game.active().Omnipresent3D.concat(this.validLocalThrentities()); }
,"validLocalThrentities":
function() { return this.Threntities.filter(function(obj) { return Object.keys(obj).length > 0; }); }
,"getThrentity":
function (index) { var ent = game.active().getOmni3D(index); if (ent != null) { return ent; } var obj = this.Threntities[index]; if (obj == null || Object.keys(obj).length == 0) { return game.active().getOmni3D(index); } else { return this.Threntities[index]; } }
,"allEntities":
function() { return game.active().Omnipresent2D.concat(this.validLocalEntities()); }
,"validLocalEntities":
function() { return this.Entities.filter(function(obj) { return Object.keys(obj).length > 0; }); }
,"getEntity":
function (index) { var ent = game.active().getOmni2D(index); if (ent != null) { return ent; } var obj = this.Entities[index]; if (obj == null || Object.keys(obj).length == 0) { return game.active().getOmni2D(index); } else { return this.Entities[index]; } }
,"getMainTilegrid":
function() { for(var i in this.TileGrids) { if (this.TileGrids[i].MainGrid === true) { return this.TileGrids[i]; } } return -1; }
,"shiftToTop":
function() {  var main = this.getMainTilegrid(); if (main !== -1) { var moveY = main.Y; this.moveAll2D(0, moveY); return moveY; } }
,"shiftToBottom":
function() {  var main = this.getMainTilegrid(); if (main !== -1) { var moveY = -(main.B() - getYDrawBounds2D()); this.moveAll2D(0, moveY); return moveY; } }
,"shiftToRight":
function() { if (this.shiftedToRight == true) {  }  var main = this.getMainTilegrid(); if (main !== -1) {  var moveX = -(main.R() - getXDrawBounds2D()); this.moveAll2D(moveX, 0); this.shiftedToLeft = false; this.shiftedToRight = true; return moveX; } }
,"shiftToLeft":
function() { if (this.shiftedToLeft == true) {  } var main = this.getMainTilegrid(); if (main !== -1) {  var moveX = main.X; this.moveAll2D(moveX, 0);  this.shiftedToLeft = true; this.shiftedToRight = false; return moveX; } }
,"shiftedToLeft":
false
,"shiftedToRight":
false
,"shiftedToTop":
false
,"shiftedToBottom":
false
,"wouldCollide":
 function(entity) {var hasCollide = false;for (var i in this.TileGrids) { if (this.TileGrids[i].wouldCollide(entity) === true) { hasCollide = true; } }var all = this.allEntities(); for (var i in all) { if (all[i].NotWorldLevel !== true && all[i].NonCorporeal !== true && all[i].Disabled !== true && all[i].Name !== entity.name && all[i].wouldCollide(entity)) { hasCollide = true; } }return hasCollide;}
,"isSetup":
false
,"XResolution":640,"YResolution":400,"HasAmbientLight":false,"AmbientLightIntensity":75,"AmbientLightColor":"0xffffcf","Bounds2DX":0,"Bounds2DY":0,"TileGrids":[{"setup":
function(parent) { if (this.DelimitedGrid && this.DelimitedGrid.length > 0){ var rows = this.DelimitedGrid.split(';');for (var j in rows) { this.tiles.push([]); var cells = rows[j].split(',');  for (var i in cells) { var tile=this.getTile(parent, cells[i]); this.tiles[j].push(tile); } } } }
,"getTile":
function(parentScene, tileId) {  var eName = this.EntityNameCSVKey.split(',')[tileId]; var tile = find(parentScene.allEntities(), eName); /* tile.draw = function(x,y,w,h) { this.MyImage.active().render(x,y,w,h); }; */ return tile;  }
,"draw":
function() { if (this.SkipDraw==true) { return; } for(var j in this.tiles) { for(var i in this.tiles[j]) { if (this.tiles[j][i] != null && this.tiles[j][i].MyImage != null) { this.tiles[j][i].MyImage.active().render(this.X + (i * this.TW),this.Y + (j * this.TH),this.TW,this.TH); } } } }
,"update":
 function() {}
,"tiles":
 [] 
,"R":
 function() {return this.X + (this.getWidth() * this.TW);}
,"B":
 function() {return this.Y + (this.getHeight() * this.TH);}
,"wouldCollide":
 function(entity) {for(var j in this.tiles)      {       for (var i in this.tiles[j])       {        if (this.tiles[j][i] != null && this.tiles[j][i].ForceCollision===true)        {         var x = this.X + (i * this.TW);         var y = this.Y + (j * this.TH);         if (checkOverlap({X:x,Y:y,W:this.TW,H:this.TH}, entity) === true)         {          console.log('overlap found');         var events = this.tiles[j][i].collisionEvents;         if (events !== null)         {         }         if (this.tiles[j][i].LedgeCollision === true)         {          if (/*notideal*/downkey() && !leftkey() && !rightkey())          {           console.log('ledge collision detected');           /*arbitrary*/var speed = 4;           /* make entity.MyLogic have a non null ActionBlock? */           entity.Me.MyLogic.ActionBlock.MyActions.push({Depth:((this.TH/speed)*2)+1,SelfDestruct:true,Ct:0,Destroyed:false,update:function() { console.log('updating action');  if (this.BlockInput === true) { BlockInput(); } if (this.SelfDestruct === true && this.Ct + 1 == this.Depth) { this.Destroyed = true; } if (this.Destroyed !== true) { this.MyScript(); this.Ct++; } },MyTarget:entity,BlockInput:true,LocalData:speed,MyScript:function() { console.log('performing action...'); this.MyTarget.Me.Y += this.LocalData; }});          }         }         return true;         }        }       }      }       return false;}
,"getWidth":
function() { if (this.getHeight() > 0) { return this.tiles[0].length; } else { return 0; } }
,"getHeight":
function() { return this.tiles.length; }
,"EntityIndexCSVKey":"","EntityNameCSVKey":"tile1,tile2,tile3,tile4","DelimitedGrid":"0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0","SkipDraw":false,"MainGrid":true,"TW":32,"TH":32,"X":0,"Y":0,"Name":"","LocalData":"","TypeName":"TileGrid","Id":310}],"AdhocSceneRefs":[],"Entities":[{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2216}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2210},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2210},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'grass32');}
,"NameOfTarget":"grass32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6136}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2210},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile1","LocalData":"","TypeName":"Entity","Id":2210},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2217}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2211},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2211},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'stone32');}
,"NameOfTarget":"stone32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6137}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2211},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile2","LocalData":"","TypeName":"Entity","Id":2211},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2218}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2212},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2212},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":8,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water1');}
,"NameOfTarget":"water1","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6138},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water2');}
,"NameOfTarget":"water2","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6139},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water3');}
,"NameOfTarget":"water3","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6140},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water4');}
,"NameOfTarget":"water4","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6141},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water5');}
,"NameOfTarget":"water5","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6142},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water6');}
,"NameOfTarget":"water6","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6143},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water7');}
,"NameOfTarget":"water7","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6144},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water8');}
,"NameOfTarget":"water8","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6145},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water9');}
,"NameOfTarget":"water9","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6146},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water10');}
,"NameOfTarget":"water10","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6147},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water11');}
,"NameOfTarget":"water11","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6148},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water12');}
,"NameOfTarget":"water12","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6149},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water13');}
,"NameOfTarget":"water13","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6150},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water14');}
,"NameOfTarget":"water14","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6151},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water15');}
,"NameOfTarget":"water15","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6152}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2212},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile3","LocalData":"","TypeName":"Entity","Id":2212},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2219}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2213},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2213},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'stoneWall32');}
,"NameOfTarget":"stoneWall32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6153}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2213},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":true,"LedgeCollision":true,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile4","LocalData":"","TypeName":"Entity","Id":2213}],"Threntities":[],"PointLights":[],"MyAudio":[],"MyLogic":{"update":
 function() {for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":null,"TypeName":"SceneProceduralStatement","Id":0},{"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"SceneProceduralStatement","Id":346}],"Name":"","LocalData":"","TypeName":"SceneLogicBox","Id":346},"Name":"","LocalData":"","TypeName":"Scene","Id":346},{"reloadThrentities":
function() { var allT = this.allThrentities(); for(var i in allT) { setupThrentity(allT[i]); } }
,"setup":
 function() {if (this.isSetup !== true) {for(var i in this.TileGrids) { this.TileGrids[i].setup(this); } for(var i in this.PointLights) { this.PointLights[i].setup(this); } if (this.MyAudio !== null) { for (var i = 0; i < this.MyAudio.length; i++) { this.MyAudio[i].setup(); } }if (game.active().Omnipresent2D.length > 0) { var indices = this.entityIndexArray(); var allE = this.allEntities();  for(var i in allE) { if (allE[i].MyIndex != '') { var ind = indices.indexOf(allE[i].MyIndex); if(ind != -1) { indices.splice(ind, 1); } } else { allE[i].setup(indices[i]); } }  } else { for(var i in this.Entities) { this.Entities[i].setup(i); } }if (game.active().Omnipresent3D.length > 0) { var indices = this.threntityIndexArray(); var allT = this.allThrentities(); for(var i in allT) { if (allT[i].MyIndex != '') { var ind = indices.indexOf(allT[i].MyIndex); if (ind != -1) { indices.splice(ind, 1); } } else { allT[i].setup(indices[i]); } }  } else { for(var i in this.Threntities) { this.Threntities[i].setup(i); } }if (this.HasAmbientLight == true) { addAmbientLightToCurrentScene(this.AmbientLightColor, this.AmbientLightIntensity / parseFloat(100)); }this.isSetup = true; }}
,"update":
 function() {this.MyLogic.update();for(var i in this.MyAudio) { this.MyAudio[i].update(); } var allE = this.allEntities(); for(var i in allE) { allE[i].update(); }var allT = this.allThrentities(); for(var i in allT) { allT[i].update(); }for(var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].update(this.AdhocSceneRefs[i].TargetName); } for(var i in this.TileGrids) { this.TileGrids[i].update(); } }
,"draw":
 function() {for(var i in this.TileGrids) { this.TileGrids[i].draw(); } var allE = this.allEntities(); for(var i in allE) { if (allE[i].Disabled !== true) { allE[i].draw(); } }var allT = this.allThrentities(); for(var i in allT) { allT[i].draw(); } }
,"entityIndexArray":
function() { var ray = []; for(var x in game.active().Omnipresent2D) { ray.push(game.active().Omnipresent2D[x].MyIndex); } var rayLen = ray.length; for(i=0;i<rayLen+this.Entities.length;i++) { if (ray.includes((i).toString())) {  } else {  ray.push(i); } } return ray; }
,"threntityIndexArray":
function() { var ray = []; for(var x in game.active().Omnipresent3D) { ray.push(game.active().Omnipresent3D[x].MyIndex); } var rayLen = ray.length; for(i=0;i<rayLen+this.Threntities.length;i++) { if (ray.includes((i).toString())) {  } else {  ray.push(i); } } return ray; }
,"checkMovePoint3d":
function(point3dBefore, point3dAfter) {  var all = this.allThrentities(); for(var i in all) { if (this.checkPointCollision(all[i], point3dBefore, point3dAfter)==true) { return false; } } return true;  }
,"checkPointCollision":
function(targetThrent, point3dBefore, point3dAfter) { var xBef = point3dBefore.X;var xAft = point3dAfter.X;var yBef = point3dBefore.Y;var yAft = point3dAfter.Y;var zBef = point3dBefore.Z;var zAft = point3dAfter.Z;var minX = targetThrent.L();var maxX = targetThrent.R();var minY = targetThrent.B();var maxY = targetThrent.T();var minZ = targetThrent.A();var maxZ = targetThrent.F();var xOverlap = false; var yOverlap = false; var zOverlap = false;if (xBef<xAft) { xOverlap = this.checkRangeOverlap(xBef, xAft, minX, maxX); } else { xOverlap = this.checkRangeOverlap(xAft, xBef, minX, maxX); }if (yBef<yAft) { yOverlap = this.checkRangeOverlap(yBef, yAft, minY, maxY); } else { yOverlap = this.checkRangeOverlap(yAft, yBef, minY, maxY); }if (zBef<zAft) { zOverlap = this.checkRangeOverlap(zBef, zAft, minZ, maxZ); } else { zOverlap = this.checkRangeOverlap(zAft, zBef, minZ, maxZ); }if (xOverlap==true && yOverlap==true && zOverlap==true) { return true; } return false;}
,"checkRangeOverlap":
function (inputOneMin, inputOneMax, inputTwoMin, inputTwoMax) {if (inputOneMin > inputTwoMax || inputOneMax < inputTwoMin) { return false; }return true;}
,"threnCollideContextual":
function(thren, before, after) { var hasCollide = false;var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name) { if (this.ZStraddle(before, after, all[i])===true && this.XStraddle(before, after, all[i])===true && this.YStraddle(before, after, all[i])===true) { hasCollide = true; } if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { hasCollide = true; } } }return hasCollide;}
,"ZStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.Z - before.Z;let secondDiff = target.Z - after.Z;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"XStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.X - before.X;let secondDiff = target.X - after.Y;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"YStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.Y - before.Y;let secondDiff = target.Y - after.Y;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"getFirstThrenCollide":
function(thren) { var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { return thren; } } }
,"threnCollide":
 function(thren) {var hasCollide = false;var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { hasCollide = true; } }return hasCollide;}
,"moveAll2D":
function(x, y) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } for (var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].X += x; this.AdhocSceneRefs[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } }
,"moveAll2DAround":
function(x, y, entName) { var ent = find(game.scene().Entities, entName); if (this.wouldCollide(ent.transpose(-x, -y)) === false) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } } }
,"quickMoveAll2DAround":
function(x, y, ent) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } for(var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].X += x; this.AdhocSceneRefs[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } }
,"tryMoveAll2DAround":
function(x, y, entName) {if (this.getMainTilegrid() === -1) { return this.moveAll2DAround(x, y, entName); } else { this.dynamic2DMove(x, y, entName, this.getMainTilegrid()); } }
,"dynamic2DMove":
function(x, y, entName, tileGrid) {var ent = game.findEntity(entName);if (this.wouldCollide(ent.transpose(-x, -y)) === false) {this.dynamic2DMoveX(x, ent, tileGrid);this.dynamic2DMoveY(y, ent, tileGrid); }}
,"dynamic2DMoveUp":
function(y, ent, tileGrid) {var amtMoveHeroTowardsCenter = (ent.pastCenterY() === false && ent.isCenteredY() === false) ? 0 : (ent.myCenterY() - viewportCenterY());if (amtMoveHeroTowardsCenter >= y) { ent.Y -= y; return; } else { ent.Y -= amtMoveHeroTowardsCenter; }var remainder = y - amtMoveHeroTowardsCenter;var tileGridSlack = 0 - tileGrid.Y;if (remainder <= Math.abs(tileGridSlack)) { this.quickMoveAll2DAround(0, remainder, ent); return; } else { this.quickMoveAll2DAround(0, Math.abs(tileGridSlack), ent); }remainder = remainder - Math.abs(tileGridSlack);ent.Y -= remainder;}
,"dynamic2DMoveDown":
function(y, ent, tileGrid) {var absY = Math.abs(y);var amtMoveHeroTowardsCenter = (ent.isCenteredY() || ent.pastCenterY()) ? 0 : viewportCenterY() - ent.myCenterY();if (amtMoveHeroTowardsCenter >= absY) { ent.Y -= y; return; } else { ent.Y += amtMoveHeroTowardsCenter; }var remainder = absY - amtMoveHeroTowardsCenter;var tileGridSlack = tileGrid.B() - getYDrawBounds2D();if (remainder <= tileGridSlack) { this.quickMoveAll2DAround(0, -remainder, ent); return; } else { this.quickMoveAll2DAround(0, tileGridSlack, ent); }remainder = remainder - tileGridSlack;ent.Y += remainder;}
,"dynamic2DMoveLeft":
function(x, ent, tileGrid) {var amtMoveHeroTowardsCenter = (ent.pastCenterX() === false && ent.isCenteredX() === false) ? 0 : (ent.myCenterX() - viewportCenterX());if (amtMoveHeroTowardsCenter >= x) { ent.X -= x; return; } else { ent.X -= amtMoveHeroTowardsCenter; }var remainder = x - amtMoveHeroTowardsCenter;var tileGridSlack = 0 - tileGrid.X;if (remainder <= Math.abs(tileGridSlack)) { this.quickMoveAll2DAround(remainder, 0, ent); return; } else { this.quickMoveAll2DAround(Math.abs(tileGridSlack), 0, ent); }remainder = remainder - Math.abs(tileGridSlack);ent.X -= remainder;}
,"dynamic2DMoveRight":
function(x, ent, tileGrid) {var absX = Math.abs(x);var amtMoveHeroTowardsCenter = (ent.isCenteredX() || ent.pastCenterX()) ? 0 : viewportCenterX() - ent.myCenterX();if (amtMoveHeroTowardsCenter >= absX) { ent.X -= x; return; } else { ent.X += amtMoveHeroTowardsCenter; }var remainder = absX - amtMoveHeroTowardsCenter;var tileGridSlack = tileGrid.R() - getXDrawBounds2D();if (remainder <= tileGridSlack) { this.quickMoveAll2DAround(-remainder, 0, ent); return; } else { this.quickMoveAll2DAround(tileGridSlack, 0, ent); }remainder = remainder - tileGridSlack;ent.X += remainder;}
,"dynamic2DMoveX":
function(x, ent, tileGrid) { var movingLeft = x > 0;if (movingLeft) { this.dynamic2DMoveLeft(x, ent, tileGrid); return; } else { this.dynamic2DMoveRight(x, ent, tileGrid); return; }var tileGridSlackX = x < 0 ? -1 * tileGrid.X : tileGrid.R() - getXDrawBounds2D(); if (ent.isCenteredX() !== true) { var centerSlackX = (x < 0 ? ((getXDrawBounds2D() / 2) - ent.X) : ent.X - (getXDrawBounds2D() / 2)); if (centerSlackX > Math.abs(x)) { ent.X -= x; }else if (centerSlackX < Math.abs(x) && centerSlackX > 0) { ent.X -= centerSlackX; }  }else if (tileGridSlackX > Math.abs(x)) { this.moveAll2DAround(x, 0, ent.Name); }else if (tileGridSlackX < Math.abs(x) && tileGridSlackX > 0) { this.moveAll2DAround(tileGridSlackX, 0, ent.Name); }}
,"dynamic2DMoveY":
function(y, ent, tileGrid) { var movingUp = y > 0;if (movingUp) { this.dynamic2DMoveUp(y, ent, tileGrid); return; } else { this.dynamic2DMoveDown(y, ent, tileGrid); return; }var tileGridSlackY = y < 0 ? -1 * tileGrid.Y : tileGrid.B() - getYDrawBounds2D();if (ent.isCenteredY() !== true) { var centerSlackY = (y < 0 ? ((getYDrawBounds2D() / 2) - ent.Y) : ent.Y - (getYDrawBounds2D() / 2)); if (centerSlackY > Math.abs(y)) { ent.Y -= y; }else if (centerSlackY < Math.abs(y) && centerSlackY > 0) { ent.Y -= centerSlackY; }  }else if (tileGridSlackY > Math.abs(y)) { this.moveAll2DAround(y, 0, ent.Name); }else if (tileGridSlackY < Math.abs(y) && tileGridSlackY > 0) { this.moveAll2DAround(tileGridSlackY, 0, ent.Name); }}
,"prepareForRenderer":
 function() {return {  };}
,"loadScene":
function() { loadThrentitiesIntoNewScene(this.allThrentities(), this.PointLights); }
,"allThrentities":
function() { return game.active().Omnipresent3D.concat(this.validLocalThrentities()); }
,"validLocalThrentities":
function() { return this.Threntities.filter(function(obj) { return Object.keys(obj).length > 0; }); }
,"getThrentity":
function (index) { var ent = game.active().getOmni3D(index); if (ent != null) { return ent; } var obj = this.Threntities[index]; if (obj == null || Object.keys(obj).length == 0) { return game.active().getOmni3D(index); } else { return this.Threntities[index]; } }
,"allEntities":
function() { return game.active().Omnipresent2D.concat(this.validLocalEntities()); }
,"validLocalEntities":
function() { return this.Entities.filter(function(obj) { return Object.keys(obj).length > 0; }); }
,"getEntity":
function (index) { var ent = game.active().getOmni2D(index); if (ent != null) { return ent; } var obj = this.Entities[index]; if (obj == null || Object.keys(obj).length == 0) { return game.active().getOmni2D(index); } else { return this.Entities[index]; } }
,"getMainTilegrid":
function() { for(var i in this.TileGrids) { if (this.TileGrids[i].MainGrid === true) { return this.TileGrids[i]; } } return -1; }
,"shiftToTop":
function() {  var main = this.getMainTilegrid(); if (main !== -1) { var moveY = main.Y; this.moveAll2D(0, moveY); return moveY; } }
,"shiftToBottom":
function() {  var main = this.getMainTilegrid(); if (main !== -1) { var moveY = -(main.B() - getYDrawBounds2D()); this.moveAll2D(0, moveY); return moveY; } }
,"shiftToRight":
function() { if (this.shiftedToRight == true) {  }  var main = this.getMainTilegrid(); if (main !== -1) {  var moveX = -(main.R() - getXDrawBounds2D()); this.moveAll2D(moveX, 0); this.shiftedToLeft = false; this.shiftedToRight = true; return moveX; } }
,"shiftToLeft":
function() { if (this.shiftedToLeft == true) {  } var main = this.getMainTilegrid(); if (main !== -1) {  var moveX = main.X; this.moveAll2D(moveX, 0);  this.shiftedToLeft = true; this.shiftedToRight = false; return moveX; } }
,"shiftedToLeft":
false
,"shiftedToRight":
false
,"shiftedToTop":
false
,"shiftedToBottom":
false
,"wouldCollide":
 function(entity) {var hasCollide = false;for (var i in this.TileGrids) { if (this.TileGrids[i].wouldCollide(entity) === true) { hasCollide = true; } }var all = this.allEntities(); for (var i in all) { if (all[i].NotWorldLevel !== true && all[i].NonCorporeal !== true && all[i].Disabled !== true && all[i].Name !== entity.name && all[i].wouldCollide(entity)) { hasCollide = true; } }return hasCollide;}
,"isSetup":
false
,"XResolution":640,"YResolution":400,"HasAmbientLight":false,"AmbientLightIntensity":75,"AmbientLightColor":"0xffffcf","Bounds2DX":0,"Bounds2DY":0,"TileGrids":[{"setup":
function(parent) { if (this.DelimitedGrid && this.DelimitedGrid.length > 0){ var rows = this.DelimitedGrid.split(';');for (var j in rows) { this.tiles.push([]); var cells = rows[j].split(',');  for (var i in cells) { var tile=this.getTile(parent, cells[i]); this.tiles[j].push(tile); } } } }
,"getTile":
function(parentScene, tileId) {  var eName = this.EntityNameCSVKey.split(',')[tileId]; var tile = find(parentScene.allEntities(), eName); /* tile.draw = function(x,y,w,h) { this.MyImage.active().render(x,y,w,h); }; */ return tile;  }
,"draw":
function() { if (this.SkipDraw==true) { return; } for(var j in this.tiles) { for(var i in this.tiles[j]) { if (this.tiles[j][i] != null && this.tiles[j][i].MyImage != null) { this.tiles[j][i].MyImage.active().render(this.X + (i * this.TW),this.Y + (j * this.TH),this.TW,this.TH); } } } }
,"update":
 function() {}
,"tiles":
 [] 
,"R":
 function() {return this.X + (this.getWidth() * this.TW);}
,"B":
 function() {return this.Y + (this.getHeight() * this.TH);}
,"wouldCollide":
 function(entity) {for(var j in this.tiles)      {       for (var i in this.tiles[j])       {        if (this.tiles[j][i] != null && this.tiles[j][i].ForceCollision===true)        {         var x = this.X + (i * this.TW);         var y = this.Y + (j * this.TH);         if (checkOverlap({X:x,Y:y,W:this.TW,H:this.TH}, entity) === true)         {          console.log('overlap found');         var events = this.tiles[j][i].collisionEvents;         if (events !== null)         {         }         if (this.tiles[j][i].LedgeCollision === true)         {          if (/*notideal*/downkey() && !leftkey() && !rightkey())          {           console.log('ledge collision detected');           /*arbitrary*/var speed = 4;           /* make entity.MyLogic have a non null ActionBlock? */           entity.Me.MyLogic.ActionBlock.MyActions.push({Depth:((this.TH/speed)*2)+1,SelfDestruct:true,Ct:0,Destroyed:false,update:function() { console.log('updating action');  if (this.BlockInput === true) { BlockInput(); } if (this.SelfDestruct === true && this.Ct + 1 == this.Depth) { this.Destroyed = true; } if (this.Destroyed !== true) { this.MyScript(); this.Ct++; } },MyTarget:entity,BlockInput:true,LocalData:speed,MyScript:function() { console.log('performing action...'); this.MyTarget.Me.Y += this.LocalData; }});          }         }         return true;         }        }       }      }       return false;}
,"getWidth":
function() { if (this.getHeight() > 0) { return this.tiles[0].length; } else { return 0; } }
,"getHeight":
function() { return this.tiles.length; }
,"EntityIndexCSVKey":"","EntityNameCSVKey":"tile1,tile2,tile3,tile4","DelimitedGrid":"0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0","SkipDraw":false,"MainGrid":true,"TW":32,"TH":32,"X":0,"Y":0,"Name":"","LocalData":"","TypeName":"TileGrid","Id":311}],"AdhocSceneRefs":[],"Entities":[{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2220}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2214},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2214},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'grass32');}
,"NameOfTarget":"grass32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6154}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2214},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile1","LocalData":"","TypeName":"Entity","Id":2214},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2221}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2215},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2215},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'stone32');}
,"NameOfTarget":"stone32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6155}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2215},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile2","LocalData":"","TypeName":"Entity","Id":2215},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2222}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2216},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2216},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":8,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water1');}
,"NameOfTarget":"water1","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6156},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water2');}
,"NameOfTarget":"water2","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6157},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water3');}
,"NameOfTarget":"water3","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6158},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water4');}
,"NameOfTarget":"water4","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6159},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water5');}
,"NameOfTarget":"water5","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6160},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water6');}
,"NameOfTarget":"water6","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6161},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water7');}
,"NameOfTarget":"water7","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6162},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water8');}
,"NameOfTarget":"water8","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6163},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water9');}
,"NameOfTarget":"water9","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6164},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water10');}
,"NameOfTarget":"water10","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6165},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water11');}
,"NameOfTarget":"water11","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6166},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water12');}
,"NameOfTarget":"water12","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6167},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water13');}
,"NameOfTarget":"water13","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6168},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water14');}
,"NameOfTarget":"water14","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6169},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water15');}
,"NameOfTarget":"water15","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6170}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2216},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile3","LocalData":"","TypeName":"Entity","Id":2216},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2223}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2217},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2217},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'stoneWall32');}
,"NameOfTarget":"stoneWall32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6171}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2217},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":true,"LedgeCollision":true,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile4","LocalData":"","TypeName":"Entity","Id":2217}],"Threntities":[],"PointLights":[],"MyAudio":[],"MyLogic":{"update":
 function() {for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":null,"TypeName":"SceneProceduralStatement","Id":0},{"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"SceneProceduralStatement","Id":347}],"Name":"","LocalData":"","TypeName":"SceneLogicBox","Id":347},"Name":"","LocalData":"","TypeName":"Scene","Id":347},{"reloadThrentities":
function() { var allT = this.allThrentities(); for(var i in allT) { setupThrentity(allT[i]); } }
,"setup":
 function() {if (this.isSetup !== true) {for(var i in this.TileGrids) { this.TileGrids[i].setup(this); } for(var i in this.PointLights) { this.PointLights[i].setup(this); } if (this.MyAudio !== null) { for (var i = 0; i < this.MyAudio.length; i++) { this.MyAudio[i].setup(); } }if (game.active().Omnipresent2D.length > 0) { var indices = this.entityIndexArray(); var allE = this.allEntities();  for(var i in allE) { if (allE[i].MyIndex != '') { var ind = indices.indexOf(allE[i].MyIndex); if(ind != -1) { indices.splice(ind, 1); } } else { allE[i].setup(indices[i]); } }  } else { for(var i in this.Entities) { this.Entities[i].setup(i); } }if (game.active().Omnipresent3D.length > 0) { var indices = this.threntityIndexArray(); var allT = this.allThrentities(); for(var i in allT) { if (allT[i].MyIndex != '') { var ind = indices.indexOf(allT[i].MyIndex); if (ind != -1) { indices.splice(ind, 1); } } else { allT[i].setup(indices[i]); } }  } else { for(var i in this.Threntities) { this.Threntities[i].setup(i); } }if (this.HasAmbientLight == true) { addAmbientLightToCurrentScene(this.AmbientLightColor, this.AmbientLightIntensity / parseFloat(100)); }this.isSetup = true; }}
,"update":
 function() {this.MyLogic.update();for(var i in this.MyAudio) { this.MyAudio[i].update(); } var allE = this.allEntities(); for(var i in allE) { allE[i].update(); }var allT = this.allThrentities(); for(var i in allT) { allT[i].update(); }for(var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].update(this.AdhocSceneRefs[i].TargetName); } for(var i in this.TileGrids) { this.TileGrids[i].update(); } }
,"draw":
 function() {for(var i in this.TileGrids) { this.TileGrids[i].draw(); } var allE = this.allEntities(); for(var i in allE) { if (allE[i].Disabled !== true) { allE[i].draw(); } }var allT = this.allThrentities(); for(var i in allT) { allT[i].draw(); } }
,"entityIndexArray":
function() { var ray = []; for(var x in game.active().Omnipresent2D) { ray.push(game.active().Omnipresent2D[x].MyIndex); } var rayLen = ray.length; for(i=0;i<rayLen+this.Entities.length;i++) { if (ray.includes((i).toString())) {  } else {  ray.push(i); } } return ray; }
,"threntityIndexArray":
function() { var ray = []; for(var x in game.active().Omnipresent3D) { ray.push(game.active().Omnipresent3D[x].MyIndex); } var rayLen = ray.length; for(i=0;i<rayLen+this.Threntities.length;i++) { if (ray.includes((i).toString())) {  } else {  ray.push(i); } } return ray; }
,"checkMovePoint3d":
function(point3dBefore, point3dAfter) {  var all = this.allThrentities(); for(var i in all) { if (this.checkPointCollision(all[i], point3dBefore, point3dAfter)==true) { return false; } } return true;  }
,"checkPointCollision":
function(targetThrent, point3dBefore, point3dAfter) { var xBef = point3dBefore.X;var xAft = point3dAfter.X;var yBef = point3dBefore.Y;var yAft = point3dAfter.Y;var zBef = point3dBefore.Z;var zAft = point3dAfter.Z;var minX = targetThrent.L();var maxX = targetThrent.R();var minY = targetThrent.B();var maxY = targetThrent.T();var minZ = targetThrent.A();var maxZ = targetThrent.F();var xOverlap = false; var yOverlap = false; var zOverlap = false;if (xBef<xAft) { xOverlap = this.checkRangeOverlap(xBef, xAft, minX, maxX); } else { xOverlap = this.checkRangeOverlap(xAft, xBef, minX, maxX); }if (yBef<yAft) { yOverlap = this.checkRangeOverlap(yBef, yAft, minY, maxY); } else { yOverlap = this.checkRangeOverlap(yAft, yBef, minY, maxY); }if (zBef<zAft) { zOverlap = this.checkRangeOverlap(zBef, zAft, minZ, maxZ); } else { zOverlap = this.checkRangeOverlap(zAft, zBef, minZ, maxZ); }if (xOverlap==true && yOverlap==true && zOverlap==true) { return true; } return false;}
,"checkRangeOverlap":
function (inputOneMin, inputOneMax, inputTwoMin, inputTwoMax) {if (inputOneMin > inputTwoMax || inputOneMax < inputTwoMin) { return false; }return true;}
,"threnCollideContextual":
function(thren, before, after) { var hasCollide = false;var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name) { if (this.ZStraddle(before, after, all[i])===true && this.XStraddle(before, after, all[i])===true && this.YStraddle(before, after, all[i])===true) { hasCollide = true; } if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { hasCollide = true; } } }return hasCollide;}
,"ZStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.Z - before.Z;let secondDiff = target.Z - after.Z;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"XStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.X - before.X;let secondDiff = target.X - after.Y;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"YStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.Y - before.Y;let secondDiff = target.Y - after.Y;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"getFirstThrenCollide":
function(thren) { var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { return thren; } } }
,"threnCollide":
 function(thren) {var hasCollide = false;var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { hasCollide = true; } }return hasCollide;}
,"moveAll2D":
function(x, y) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } for (var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].X += x; this.AdhocSceneRefs[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } }
,"moveAll2DAround":
function(x, y, entName) { var ent = find(game.scene().Entities, entName); if (this.wouldCollide(ent.transpose(-x, -y)) === false) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } } }
,"quickMoveAll2DAround":
function(x, y, ent) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } for(var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].X += x; this.AdhocSceneRefs[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } }
,"tryMoveAll2DAround":
function(x, y, entName) {if (this.getMainTilegrid() === -1) { return this.moveAll2DAround(x, y, entName); } else { this.dynamic2DMove(x, y, entName, this.getMainTilegrid()); } }
,"dynamic2DMove":
function(x, y, entName, tileGrid) {var ent = game.findEntity(entName);if (this.wouldCollide(ent.transpose(-x, -y)) === false) {this.dynamic2DMoveX(x, ent, tileGrid);this.dynamic2DMoveY(y, ent, tileGrid); }}
,"dynamic2DMoveUp":
function(y, ent, tileGrid) {var amtMoveHeroTowardsCenter = (ent.pastCenterY() === false && ent.isCenteredY() === false) ? 0 : (ent.myCenterY() - viewportCenterY());if (amtMoveHeroTowardsCenter >= y) { ent.Y -= y; return; } else { ent.Y -= amtMoveHeroTowardsCenter; }var remainder = y - amtMoveHeroTowardsCenter;var tileGridSlack = 0 - tileGrid.Y;if (remainder <= Math.abs(tileGridSlack)) { this.quickMoveAll2DAround(0, remainder, ent); return; } else { this.quickMoveAll2DAround(0, Math.abs(tileGridSlack), ent); }remainder = remainder - Math.abs(tileGridSlack);ent.Y -= remainder;}
,"dynamic2DMoveDown":
function(y, ent, tileGrid) {var absY = Math.abs(y);var amtMoveHeroTowardsCenter = (ent.isCenteredY() || ent.pastCenterY()) ? 0 : viewportCenterY() - ent.myCenterY();if (amtMoveHeroTowardsCenter >= absY) { ent.Y -= y; return; } else { ent.Y += amtMoveHeroTowardsCenter; }var remainder = absY - amtMoveHeroTowardsCenter;var tileGridSlack = tileGrid.B() - getYDrawBounds2D();if (remainder <= tileGridSlack) { this.quickMoveAll2DAround(0, -remainder, ent); return; } else { this.quickMoveAll2DAround(0, tileGridSlack, ent); }remainder = remainder - tileGridSlack;ent.Y += remainder;}
,"dynamic2DMoveLeft":
function(x, ent, tileGrid) {var amtMoveHeroTowardsCenter = (ent.pastCenterX() === false && ent.isCenteredX() === false) ? 0 : (ent.myCenterX() - viewportCenterX());if (amtMoveHeroTowardsCenter >= x) { ent.X -= x; return; } else { ent.X -= amtMoveHeroTowardsCenter; }var remainder = x - amtMoveHeroTowardsCenter;var tileGridSlack = 0 - tileGrid.X;if (remainder <= Math.abs(tileGridSlack)) { this.quickMoveAll2DAround(remainder, 0, ent); return; } else { this.quickMoveAll2DAround(Math.abs(tileGridSlack), 0, ent); }remainder = remainder - Math.abs(tileGridSlack);ent.X -= remainder;}
,"dynamic2DMoveRight":
function(x, ent, tileGrid) {var absX = Math.abs(x);var amtMoveHeroTowardsCenter = (ent.isCenteredX() || ent.pastCenterX()) ? 0 : viewportCenterX() - ent.myCenterX();if (amtMoveHeroTowardsCenter >= absX) { ent.X -= x; return; } else { ent.X += amtMoveHeroTowardsCenter; }var remainder = absX - amtMoveHeroTowardsCenter;var tileGridSlack = tileGrid.R() - getXDrawBounds2D();if (remainder <= tileGridSlack) { this.quickMoveAll2DAround(-remainder, 0, ent); return; } else { this.quickMoveAll2DAround(tileGridSlack, 0, ent); }remainder = remainder - tileGridSlack;ent.X += remainder;}
,"dynamic2DMoveX":
function(x, ent, tileGrid) { var movingLeft = x > 0;if (movingLeft) { this.dynamic2DMoveLeft(x, ent, tileGrid); return; } else { this.dynamic2DMoveRight(x, ent, tileGrid); return; }var tileGridSlackX = x < 0 ? -1 * tileGrid.X : tileGrid.R() - getXDrawBounds2D(); if (ent.isCenteredX() !== true) { var centerSlackX = (x < 0 ? ((getXDrawBounds2D() / 2) - ent.X) : ent.X - (getXDrawBounds2D() / 2)); if (centerSlackX > Math.abs(x)) { ent.X -= x; }else if (centerSlackX < Math.abs(x) && centerSlackX > 0) { ent.X -= centerSlackX; }  }else if (tileGridSlackX > Math.abs(x)) { this.moveAll2DAround(x, 0, ent.Name); }else if (tileGridSlackX < Math.abs(x) && tileGridSlackX > 0) { this.moveAll2DAround(tileGridSlackX, 0, ent.Name); }}
,"dynamic2DMoveY":
function(y, ent, tileGrid) { var movingUp = y > 0;if (movingUp) { this.dynamic2DMoveUp(y, ent, tileGrid); return; } else { this.dynamic2DMoveDown(y, ent, tileGrid); return; }var tileGridSlackY = y < 0 ? -1 * tileGrid.Y : tileGrid.B() - getYDrawBounds2D();if (ent.isCenteredY() !== true) { var centerSlackY = (y < 0 ? ((getYDrawBounds2D() / 2) - ent.Y) : ent.Y - (getYDrawBounds2D() / 2)); if (centerSlackY > Math.abs(y)) { ent.Y -= y; }else if (centerSlackY < Math.abs(y) && centerSlackY > 0) { ent.Y -= centerSlackY; }  }else if (tileGridSlackY > Math.abs(y)) { this.moveAll2DAround(y, 0, ent.Name); }else if (tileGridSlackY < Math.abs(y) && tileGridSlackY > 0) { this.moveAll2DAround(tileGridSlackY, 0, ent.Name); }}
,"prepareForRenderer":
 function() {return {  };}
,"loadScene":
function() { loadThrentitiesIntoNewScene(this.allThrentities(), this.PointLights); }
,"allThrentities":
function() { return game.active().Omnipresent3D.concat(this.validLocalThrentities()); }
,"validLocalThrentities":
function() { return this.Threntities.filter(function(obj) { return Object.keys(obj).length > 0; }); }
,"getThrentity":
function (index) { var ent = game.active().getOmni3D(index); if (ent != null) { return ent; } var obj = this.Threntities[index]; if (obj == null || Object.keys(obj).length == 0) { return game.active().getOmni3D(index); } else { return this.Threntities[index]; } }
,"allEntities":
function() { return game.active().Omnipresent2D.concat(this.validLocalEntities()); }
,"validLocalEntities":
function() { return this.Entities.filter(function(obj) { return Object.keys(obj).length > 0; }); }
,"getEntity":
function (index) { var ent = game.active().getOmni2D(index); if (ent != null) { return ent; } var obj = this.Entities[index]; if (obj == null || Object.keys(obj).length == 0) { return game.active().getOmni2D(index); } else { return this.Entities[index]; } }
,"getMainTilegrid":
function() { for(var i in this.TileGrids) { if (this.TileGrids[i].MainGrid === true) { return this.TileGrids[i]; } } return -1; }
,"shiftToTop":
function() {  var main = this.getMainTilegrid(); if (main !== -1) { var moveY = main.Y; this.moveAll2D(0, moveY); return moveY; } }
,"shiftToBottom":
function() {  var main = this.getMainTilegrid(); if (main !== -1) { var moveY = -(main.B() - getYDrawBounds2D()); this.moveAll2D(0, moveY); return moveY; } }
,"shiftToRight":
function() { if (this.shiftedToRight == true) {  }  var main = this.getMainTilegrid(); if (main !== -1) {  var moveX = -(main.R() - getXDrawBounds2D()); this.moveAll2D(moveX, 0); this.shiftedToLeft = false; this.shiftedToRight = true; return moveX; } }
,"shiftToLeft":
function() { if (this.shiftedToLeft == true) {  } var main = this.getMainTilegrid(); if (main !== -1) {  var moveX = main.X; this.moveAll2D(moveX, 0);  this.shiftedToLeft = true; this.shiftedToRight = false; return moveX; } }
,"shiftedToLeft":
false
,"shiftedToRight":
false
,"shiftedToTop":
false
,"shiftedToBottom":
false
,"wouldCollide":
 function(entity) {var hasCollide = false;for (var i in this.TileGrids) { if (this.TileGrids[i].wouldCollide(entity) === true) { hasCollide = true; } }var all = this.allEntities(); for (var i in all) { if (all[i].NotWorldLevel !== true && all[i].NonCorporeal !== true && all[i].Disabled !== true && all[i].Name !== entity.name && all[i].wouldCollide(entity)) { hasCollide = true; } }return hasCollide;}
,"isSetup":
false
,"XResolution":640,"YResolution":400,"HasAmbientLight":false,"AmbientLightIntensity":75,"AmbientLightColor":"0xffffcf","Bounds2DX":0,"Bounds2DY":0,"TileGrids":[{"setup":
function(parent) { if (this.DelimitedGrid && this.DelimitedGrid.length > 0){ var rows = this.DelimitedGrid.split(';');for (var j in rows) { this.tiles.push([]); var cells = rows[j].split(',');  for (var i in cells) { var tile=this.getTile(parent, cells[i]); this.tiles[j].push(tile); } } } }
,"getTile":
function(parentScene, tileId) {  var eName = this.EntityNameCSVKey.split(',')[tileId]; var tile = find(parentScene.allEntities(), eName); /* tile.draw = function(x,y,w,h) { this.MyImage.active().render(x,y,w,h); }; */ return tile;  }
,"draw":
function() { if (this.SkipDraw==true) { return; } for(var j in this.tiles) { for(var i in this.tiles[j]) { if (this.tiles[j][i] != null && this.tiles[j][i].MyImage != null) { this.tiles[j][i].MyImage.active().render(this.X + (i * this.TW),this.Y + (j * this.TH),this.TW,this.TH); } } } }
,"update":
 function() {}
,"tiles":
 [] 
,"R":
 function() {return this.X + (this.getWidth() * this.TW);}
,"B":
 function() {return this.Y + (this.getHeight() * this.TH);}
,"wouldCollide":
 function(entity) {for(var j in this.tiles)      {       for (var i in this.tiles[j])       {        if (this.tiles[j][i] != null && this.tiles[j][i].ForceCollision===true)        {         var x = this.X + (i * this.TW);         var y = this.Y + (j * this.TH);         if (checkOverlap({X:x,Y:y,W:this.TW,H:this.TH}, entity) === true)         {          console.log('overlap found');         var events = this.tiles[j][i].collisionEvents;         if (events !== null)         {         }         if (this.tiles[j][i].LedgeCollision === true)         {          if (/*notideal*/downkey() && !leftkey() && !rightkey())          {           console.log('ledge collision detected');           /*arbitrary*/var speed = 4;           /* make entity.MyLogic have a non null ActionBlock? */           entity.Me.MyLogic.ActionBlock.MyActions.push({Depth:((this.TH/speed)*2)+1,SelfDestruct:true,Ct:0,Destroyed:false,update:function() { console.log('updating action');  if (this.BlockInput === true) { BlockInput(); } if (this.SelfDestruct === true && this.Ct + 1 == this.Depth) { this.Destroyed = true; } if (this.Destroyed !== true) { this.MyScript(); this.Ct++; } },MyTarget:entity,BlockInput:true,LocalData:speed,MyScript:function() { console.log('performing action...'); this.MyTarget.Me.Y += this.LocalData; }});          }         }         return true;         }        }       }      }       return false;}
,"getWidth":
function() { if (this.getHeight() > 0) { return this.tiles[0].length; } else { return 0; } }
,"getHeight":
function() { return this.tiles.length; }
,"EntityIndexCSVKey":"","EntityNameCSVKey":"tile1,tile2,tile3,tile4","DelimitedGrid":"0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0","SkipDraw":false,"MainGrid":true,"TW":32,"TH":32,"X":0,"Y":0,"Name":"","LocalData":"","TypeName":"TileGrid","Id":312}],"AdhocSceneRefs":[],"Entities":[{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2224}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2218},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2218},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'grass32');}
,"NameOfTarget":"grass32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6172}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2218},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile1","LocalData":"","TypeName":"Entity","Id":2218},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2225}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2219},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2219},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'stone32');}
,"NameOfTarget":"stone32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6173}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2219},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile2","LocalData":"","TypeName":"Entity","Id":2219},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2226}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2220},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2220},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":8,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water1');}
,"NameOfTarget":"water1","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6174},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water2');}
,"NameOfTarget":"water2","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6175},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water3');}
,"NameOfTarget":"water3","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6176},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water4');}
,"NameOfTarget":"water4","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6177},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water5');}
,"NameOfTarget":"water5","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6178},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water6');}
,"NameOfTarget":"water6","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6179},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water7');}
,"NameOfTarget":"water7","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6180},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water8');}
,"NameOfTarget":"water8","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6181},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water9');}
,"NameOfTarget":"water9","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6182},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water10');}
,"NameOfTarget":"water10","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6183},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water11');}
,"NameOfTarget":"water11","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6184},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water12');}
,"NameOfTarget":"water12","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6185},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water13');}
,"NameOfTarget":"water13","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6186},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water14');}
,"NameOfTarget":"water14","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6187},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water15');}
,"NameOfTarget":"water15","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6188}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2220},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile3","LocalData":"","TypeName":"Entity","Id":2220},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2227}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2221},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2221},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'stoneWall32');}
,"NameOfTarget":"stoneWall32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6189}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2221},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":true,"LedgeCollision":true,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile4","LocalData":"","TypeName":"Entity","Id":2221}],"Threntities":[],"PointLights":[],"MyAudio":[],"MyLogic":{"update":
 function() {for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":null,"TypeName":"SceneProceduralStatement","Id":0},{"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"SceneProceduralStatement","Id":348}],"Name":"","LocalData":"","TypeName":"SceneLogicBox","Id":348},"Name":"","LocalData":"","TypeName":"Scene","Id":348},{"reloadThrentities":
function() { var allT = this.allThrentities(); for(var i in allT) { setupThrentity(allT[i]); } }
,"setup":
 function() {if (this.isSetup !== true) {for(var i in this.TileGrids) { this.TileGrids[i].setup(this); } for(var i in this.PointLights) { this.PointLights[i].setup(this); } if (this.MyAudio !== null) { for (var i = 0; i < this.MyAudio.length; i++) { this.MyAudio[i].setup(); } }if (game.active().Omnipresent2D.length > 0) { var indices = this.entityIndexArray(); var allE = this.allEntities();  for(var i in allE) { if (allE[i].MyIndex != '') { var ind = indices.indexOf(allE[i].MyIndex); if(ind != -1) { indices.splice(ind, 1); } } else { allE[i].setup(indices[i]); } }  } else { for(var i in this.Entities) { this.Entities[i].setup(i); } }if (game.active().Omnipresent3D.length > 0) { var indices = this.threntityIndexArray(); var allT = this.allThrentities(); for(var i in allT) { if (allT[i].MyIndex != '') { var ind = indices.indexOf(allT[i].MyIndex); if (ind != -1) { indices.splice(ind, 1); } } else { allT[i].setup(indices[i]); } }  } else { for(var i in this.Threntities) { this.Threntities[i].setup(i); } }if (this.HasAmbientLight == true) { addAmbientLightToCurrentScene(this.AmbientLightColor, this.AmbientLightIntensity / parseFloat(100)); }this.isSetup = true; }}
,"update":
 function() {this.MyLogic.update();for(var i in this.MyAudio) { this.MyAudio[i].update(); } var allE = this.allEntities(); for(var i in allE) { allE[i].update(); }var allT = this.allThrentities(); for(var i in allT) { allT[i].update(); }for(var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].update(this.AdhocSceneRefs[i].TargetName); } for(var i in this.TileGrids) { this.TileGrids[i].update(); } }
,"draw":
 function() {for(var i in this.TileGrids) { this.TileGrids[i].draw(); } var allE = this.allEntities(); for(var i in allE) { if (allE[i].Disabled !== true) { allE[i].draw(); } }var allT = this.allThrentities(); for(var i in allT) { allT[i].draw(); } }
,"entityIndexArray":
function() { var ray = []; for(var x in game.active().Omnipresent2D) { ray.push(game.active().Omnipresent2D[x].MyIndex); } var rayLen = ray.length; for(i=0;i<rayLen+this.Entities.length;i++) { if (ray.includes((i).toString())) {  } else {  ray.push(i); } } return ray; }
,"threntityIndexArray":
function() { var ray = []; for(var x in game.active().Omnipresent3D) { ray.push(game.active().Omnipresent3D[x].MyIndex); } var rayLen = ray.length; for(i=0;i<rayLen+this.Threntities.length;i++) { if (ray.includes((i).toString())) {  } else {  ray.push(i); } } return ray; }
,"checkMovePoint3d":
function(point3dBefore, point3dAfter) {  var all = this.allThrentities(); for(var i in all) { if (this.checkPointCollision(all[i], point3dBefore, point3dAfter)==true) { return false; } } return true;  }
,"checkPointCollision":
function(targetThrent, point3dBefore, point3dAfter) { var xBef = point3dBefore.X;var xAft = point3dAfter.X;var yBef = point3dBefore.Y;var yAft = point3dAfter.Y;var zBef = point3dBefore.Z;var zAft = point3dAfter.Z;var minX = targetThrent.L();var maxX = targetThrent.R();var minY = targetThrent.B();var maxY = targetThrent.T();var minZ = targetThrent.A();var maxZ = targetThrent.F();var xOverlap = false; var yOverlap = false; var zOverlap = false;if (xBef<xAft) { xOverlap = this.checkRangeOverlap(xBef, xAft, minX, maxX); } else { xOverlap = this.checkRangeOverlap(xAft, xBef, minX, maxX); }if (yBef<yAft) { yOverlap = this.checkRangeOverlap(yBef, yAft, minY, maxY); } else { yOverlap = this.checkRangeOverlap(yAft, yBef, minY, maxY); }if (zBef<zAft) { zOverlap = this.checkRangeOverlap(zBef, zAft, minZ, maxZ); } else { zOverlap = this.checkRangeOverlap(zAft, zBef, minZ, maxZ); }if (xOverlap==true && yOverlap==true && zOverlap==true) { return true; } return false;}
,"checkRangeOverlap":
function (inputOneMin, inputOneMax, inputTwoMin, inputTwoMax) {if (inputOneMin > inputTwoMax || inputOneMax < inputTwoMin) { return false; }return true;}
,"threnCollideContextual":
function(thren, before, after) { var hasCollide = false;var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name) { if (this.ZStraddle(before, after, all[i])===true && this.XStraddle(before, after, all[i])===true && this.YStraddle(before, after, all[i])===true) { hasCollide = true; } if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { hasCollide = true; } } }return hasCollide;}
,"ZStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.Z - before.Z;let secondDiff = target.Z - after.Z;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"XStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.X - before.X;let secondDiff = target.X - after.Y;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"YStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.Y - before.Y;let secondDiff = target.Y - after.Y;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"getFirstThrenCollide":
function(thren) { var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { return thren; } } }
,"threnCollide":
 function(thren) {var hasCollide = false;var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { hasCollide = true; } }return hasCollide;}
,"moveAll2D":
function(x, y) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } for (var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].X += x; this.AdhocSceneRefs[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } }
,"moveAll2DAround":
function(x, y, entName) { var ent = find(game.scene().Entities, entName); if (this.wouldCollide(ent.transpose(-x, -y)) === false) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } } }
,"quickMoveAll2DAround":
function(x, y, ent) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } for(var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].X += x; this.AdhocSceneRefs[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } }
,"tryMoveAll2DAround":
function(x, y, entName) {if (this.getMainTilegrid() === -1) { return this.moveAll2DAround(x, y, entName); } else { this.dynamic2DMove(x, y, entName, this.getMainTilegrid()); } }
,"dynamic2DMove":
function(x, y, entName, tileGrid) {var ent = game.findEntity(entName);if (this.wouldCollide(ent.transpose(-x, -y)) === false) {this.dynamic2DMoveX(x, ent, tileGrid);this.dynamic2DMoveY(y, ent, tileGrid); }}
,"dynamic2DMoveUp":
function(y, ent, tileGrid) {var amtMoveHeroTowardsCenter = (ent.pastCenterY() === false && ent.isCenteredY() === false) ? 0 : (ent.myCenterY() - viewportCenterY());if (amtMoveHeroTowardsCenter >= y) { ent.Y -= y; return; } else { ent.Y -= amtMoveHeroTowardsCenter; }var remainder = y - amtMoveHeroTowardsCenter;var tileGridSlack = 0 - tileGrid.Y;if (remainder <= Math.abs(tileGridSlack)) { this.quickMoveAll2DAround(0, remainder, ent); return; } else { this.quickMoveAll2DAround(0, Math.abs(tileGridSlack), ent); }remainder = remainder - Math.abs(tileGridSlack);ent.Y -= remainder;}
,"dynamic2DMoveDown":
function(y, ent, tileGrid) {var absY = Math.abs(y);var amtMoveHeroTowardsCenter = (ent.isCenteredY() || ent.pastCenterY()) ? 0 : viewportCenterY() - ent.myCenterY();if (amtMoveHeroTowardsCenter >= absY) { ent.Y -= y; return; } else { ent.Y += amtMoveHeroTowardsCenter; }var remainder = absY - amtMoveHeroTowardsCenter;var tileGridSlack = tileGrid.B() - getYDrawBounds2D();if (remainder <= tileGridSlack) { this.quickMoveAll2DAround(0, -remainder, ent); return; } else { this.quickMoveAll2DAround(0, tileGridSlack, ent); }remainder = remainder - tileGridSlack;ent.Y += remainder;}
,"dynamic2DMoveLeft":
function(x, ent, tileGrid) {var amtMoveHeroTowardsCenter = (ent.pastCenterX() === false && ent.isCenteredX() === false) ? 0 : (ent.myCenterX() - viewportCenterX());if (amtMoveHeroTowardsCenter >= x) { ent.X -= x; return; } else { ent.X -= amtMoveHeroTowardsCenter; }var remainder = x - amtMoveHeroTowardsCenter;var tileGridSlack = 0 - tileGrid.X;if (remainder <= Math.abs(tileGridSlack)) { this.quickMoveAll2DAround(remainder, 0, ent); return; } else { this.quickMoveAll2DAround(Math.abs(tileGridSlack), 0, ent); }remainder = remainder - Math.abs(tileGridSlack);ent.X -= remainder;}
,"dynamic2DMoveRight":
function(x, ent, tileGrid) {var absX = Math.abs(x);var amtMoveHeroTowardsCenter = (ent.isCenteredX() || ent.pastCenterX()) ? 0 : viewportCenterX() - ent.myCenterX();if (amtMoveHeroTowardsCenter >= absX) { ent.X -= x; return; } else { ent.X += amtMoveHeroTowardsCenter; }var remainder = absX - amtMoveHeroTowardsCenter;var tileGridSlack = tileGrid.R() - getXDrawBounds2D();if (remainder <= tileGridSlack) { this.quickMoveAll2DAround(-remainder, 0, ent); return; } else { this.quickMoveAll2DAround(tileGridSlack, 0, ent); }remainder = remainder - tileGridSlack;ent.X += remainder;}
,"dynamic2DMoveX":
function(x, ent, tileGrid) { var movingLeft = x > 0;if (movingLeft) { this.dynamic2DMoveLeft(x, ent, tileGrid); return; } else { this.dynamic2DMoveRight(x, ent, tileGrid); return; }var tileGridSlackX = x < 0 ? -1 * tileGrid.X : tileGrid.R() - getXDrawBounds2D(); if (ent.isCenteredX() !== true) { var centerSlackX = (x < 0 ? ((getXDrawBounds2D() / 2) - ent.X) : ent.X - (getXDrawBounds2D() / 2)); if (centerSlackX > Math.abs(x)) { ent.X -= x; }else if (centerSlackX < Math.abs(x) && centerSlackX > 0) { ent.X -= centerSlackX; }  }else if (tileGridSlackX > Math.abs(x)) { this.moveAll2DAround(x, 0, ent.Name); }else if (tileGridSlackX < Math.abs(x) && tileGridSlackX > 0) { this.moveAll2DAround(tileGridSlackX, 0, ent.Name); }}
,"dynamic2DMoveY":
function(y, ent, tileGrid) { var movingUp = y > 0;if (movingUp) { this.dynamic2DMoveUp(y, ent, tileGrid); return; } else { this.dynamic2DMoveDown(y, ent, tileGrid); return; }var tileGridSlackY = y < 0 ? -1 * tileGrid.Y : tileGrid.B() - getYDrawBounds2D();if (ent.isCenteredY() !== true) { var centerSlackY = (y < 0 ? ((getYDrawBounds2D() / 2) - ent.Y) : ent.Y - (getYDrawBounds2D() / 2)); if (centerSlackY > Math.abs(y)) { ent.Y -= y; }else if (centerSlackY < Math.abs(y) && centerSlackY > 0) { ent.Y -= centerSlackY; }  }else if (tileGridSlackY > Math.abs(y)) { this.moveAll2DAround(y, 0, ent.Name); }else if (tileGridSlackY < Math.abs(y) && tileGridSlackY > 0) { this.moveAll2DAround(tileGridSlackY, 0, ent.Name); }}
,"prepareForRenderer":
 function() {return {  };}
,"loadScene":
function() { loadThrentitiesIntoNewScene(this.allThrentities(), this.PointLights); }
,"allThrentities":
function() { return game.active().Omnipresent3D.concat(this.validLocalThrentities()); }
,"validLocalThrentities":
function() { return this.Threntities.filter(function(obj) { return Object.keys(obj).length > 0; }); }
,"getThrentity":
function (index) { var ent = game.active().getOmni3D(index); if (ent != null) { return ent; } var obj = this.Threntities[index]; if (obj == null || Object.keys(obj).length == 0) { return game.active().getOmni3D(index); } else { return this.Threntities[index]; } }
,"allEntities":
function() { return game.active().Omnipresent2D.concat(this.validLocalEntities()); }
,"validLocalEntities":
function() { return this.Entities.filter(function(obj) { return Object.keys(obj).length > 0; }); }
,"getEntity":
function (index) { var ent = game.active().getOmni2D(index); if (ent != null) { return ent; } var obj = this.Entities[index]; if (obj == null || Object.keys(obj).length == 0) { return game.active().getOmni2D(index); } else { return this.Entities[index]; } }
,"getMainTilegrid":
function() { for(var i in this.TileGrids) { if (this.TileGrids[i].MainGrid === true) { return this.TileGrids[i]; } } return -1; }
,"shiftToTop":
function() {  var main = this.getMainTilegrid(); if (main !== -1) { var moveY = main.Y; this.moveAll2D(0, moveY); return moveY; } }
,"shiftToBottom":
function() {  var main = this.getMainTilegrid(); if (main !== -1) { var moveY = -(main.B() - getYDrawBounds2D()); this.moveAll2D(0, moveY); return moveY; } }
,"shiftToRight":
function() { if (this.shiftedToRight == true) {  }  var main = this.getMainTilegrid(); if (main !== -1) {  var moveX = -(main.R() - getXDrawBounds2D()); this.moveAll2D(moveX, 0); this.shiftedToLeft = false; this.shiftedToRight = true; return moveX; } }
,"shiftToLeft":
function() { if (this.shiftedToLeft == true) {  } var main = this.getMainTilegrid(); if (main !== -1) {  var moveX = main.X; this.moveAll2D(moveX, 0);  this.shiftedToLeft = true; this.shiftedToRight = false; return moveX; } }
,"shiftedToLeft":
false
,"shiftedToRight":
false
,"shiftedToTop":
false
,"shiftedToBottom":
false
,"wouldCollide":
 function(entity) {var hasCollide = false;for (var i in this.TileGrids) { if (this.TileGrids[i].wouldCollide(entity) === true) { hasCollide = true; } }var all = this.allEntities(); for (var i in all) { if (all[i].NotWorldLevel !== true && all[i].NonCorporeal !== true && all[i].Disabled !== true && all[i].Name !== entity.name && all[i].wouldCollide(entity)) { hasCollide = true; } }return hasCollide;}
,"isSetup":
false
,"XResolution":640,"YResolution":400,"HasAmbientLight":false,"AmbientLightIntensity":75,"AmbientLightColor":"0xffffcf","Bounds2DX":0,"Bounds2DY":0,"TileGrids":[{"setup":
function(parent) { if (this.DelimitedGrid && this.DelimitedGrid.length > 0){ var rows = this.DelimitedGrid.split(';');for (var j in rows) { this.tiles.push([]); var cells = rows[j].split(',');  for (var i in cells) { var tile=this.getTile(parent, cells[i]); this.tiles[j].push(tile); } } } }
,"getTile":
function(parentScene, tileId) {  var eName = this.EntityNameCSVKey.split(',')[tileId]; var tile = find(parentScene.allEntities(), eName); /* tile.draw = function(x,y,w,h) { this.MyImage.active().render(x,y,w,h); }; */ return tile;  }
,"draw":
function() { if (this.SkipDraw==true) { return; } for(var j in this.tiles) { for(var i in this.tiles[j]) { if (this.tiles[j][i] != null && this.tiles[j][i].MyImage != null) { this.tiles[j][i].MyImage.active().render(this.X + (i * this.TW),this.Y + (j * this.TH),this.TW,this.TH); } } } }
,"update":
 function() {}
,"tiles":
 [] 
,"R":
 function() {return this.X + (this.getWidth() * this.TW);}
,"B":
 function() {return this.Y + (this.getHeight() * this.TH);}
,"wouldCollide":
 function(entity) {for(var j in this.tiles)      {       for (var i in this.tiles[j])       {        if (this.tiles[j][i] != null && this.tiles[j][i].ForceCollision===true)        {         var x = this.X + (i * this.TW);         var y = this.Y + (j * this.TH);         if (checkOverlap({X:x,Y:y,W:this.TW,H:this.TH}, entity) === true)         {          console.log('overlap found');         var events = this.tiles[j][i].collisionEvents;         if (events !== null)         {         }         if (this.tiles[j][i].LedgeCollision === true)         {          if (/*notideal*/downkey() && !leftkey() && !rightkey())          {           console.log('ledge collision detected');           /*arbitrary*/var speed = 4;           /* make entity.MyLogic have a non null ActionBlock? */           entity.Me.MyLogic.ActionBlock.MyActions.push({Depth:((this.TH/speed)*2)+1,SelfDestruct:true,Ct:0,Destroyed:false,update:function() { console.log('updating action');  if (this.BlockInput === true) { BlockInput(); } if (this.SelfDestruct === true && this.Ct + 1 == this.Depth) { this.Destroyed = true; } if (this.Destroyed !== true) { this.MyScript(); this.Ct++; } },MyTarget:entity,BlockInput:true,LocalData:speed,MyScript:function() { console.log('performing action...'); this.MyTarget.Me.Y += this.LocalData; }});          }         }         return true;         }        }       }      }       return false;}
,"getWidth":
function() { if (this.getHeight() > 0) { return this.tiles[0].length; } else { return 0; } }
,"getHeight":
function() { return this.tiles.length; }
,"EntityIndexCSVKey":"","EntityNameCSVKey":"tile1,tile2,tile3,tile4","DelimitedGrid":"0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0","SkipDraw":false,"MainGrid":true,"TW":32,"TH":32,"X":0,"Y":0,"Name":"","LocalData":"","TypeName":"TileGrid","Id":313}],"AdhocSceneRefs":[],"Entities":[{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2228}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2222},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2222},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'grass32');}
,"NameOfTarget":"grass32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6190}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2222},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile1","LocalData":"","TypeName":"Entity","Id":2222},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2229}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2223},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2223},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'stone32');}
,"NameOfTarget":"stone32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6191}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2223},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile2","LocalData":"","TypeName":"Entity","Id":2223},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2230}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2224},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2224},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":8,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water1');}
,"NameOfTarget":"water1","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6192},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water2');}
,"NameOfTarget":"water2","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6193},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water3');}
,"NameOfTarget":"water3","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6194},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water4');}
,"NameOfTarget":"water4","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6195},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water5');}
,"NameOfTarget":"water5","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6196},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water6');}
,"NameOfTarget":"water6","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6197},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water7');}
,"NameOfTarget":"water7","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6198},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water8');}
,"NameOfTarget":"water8","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6199},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water9');}
,"NameOfTarget":"water9","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6200},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water10');}
,"NameOfTarget":"water10","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6201},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water11');}
,"NameOfTarget":"water11","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6202},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water12');}
,"NameOfTarget":"water12","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6203},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water13');}
,"NameOfTarget":"water13","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6204},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water14');}
,"NameOfTarget":"water14","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6205},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water15');}
,"NameOfTarget":"water15","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6206}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2224},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile3","LocalData":"","TypeName":"Entity","Id":2224},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2231}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2225},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2225},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'stoneWall32');}
,"NameOfTarget":"stoneWall32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6207}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2225},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":true,"LedgeCollision":true,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile4","LocalData":"","TypeName":"Entity","Id":2225}],"Threntities":[],"PointLights":[],"MyAudio":[],"MyLogic":{"update":
 function() {for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":null,"TypeName":"SceneProceduralStatement","Id":0},{"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"SceneProceduralStatement","Id":349}],"Name":"","LocalData":"","TypeName":"SceneLogicBox","Id":349},"Name":"","LocalData":"","TypeName":"Scene","Id":349},{"reloadThrentities":
function() { var allT = this.allThrentities(); for(var i in allT) { setupThrentity(allT[i]); } }
,"setup":
 function() {if (this.isSetup !== true) {for(var i in this.TileGrids) { this.TileGrids[i].setup(this); } for(var i in this.PointLights) { this.PointLights[i].setup(this); } if (this.MyAudio !== null) { for (var i = 0; i < this.MyAudio.length; i++) { this.MyAudio[i].setup(); } }if (game.active().Omnipresent2D.length > 0) { var indices = this.entityIndexArray(); var allE = this.allEntities();  for(var i in allE) { if (allE[i].MyIndex != '') { var ind = indices.indexOf(allE[i].MyIndex); if(ind != -1) { indices.splice(ind, 1); } } else { allE[i].setup(indices[i]); } }  } else { for(var i in this.Entities) { this.Entities[i].setup(i); } }if (game.active().Omnipresent3D.length > 0) { var indices = this.threntityIndexArray(); var allT = this.allThrentities(); for(var i in allT) { if (allT[i].MyIndex != '') { var ind = indices.indexOf(allT[i].MyIndex); if (ind != -1) { indices.splice(ind, 1); } } else { allT[i].setup(indices[i]); } }  } else { for(var i in this.Threntities) { this.Threntities[i].setup(i); } }if (this.HasAmbientLight == true) { addAmbientLightToCurrentScene(this.AmbientLightColor, this.AmbientLightIntensity / parseFloat(100)); }this.isSetup = true; }}
,"update":
 function() {this.MyLogic.update();for(var i in this.MyAudio) { this.MyAudio[i].update(); } var allE = this.allEntities(); for(var i in allE) { allE[i].update(); }var allT = this.allThrentities(); for(var i in allT) { allT[i].update(); }for(var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].update(this.AdhocSceneRefs[i].TargetName); } for(var i in this.TileGrids) { this.TileGrids[i].update(); } }
,"draw":
 function() {for(var i in this.TileGrids) { this.TileGrids[i].draw(); } var allE = this.allEntities(); for(var i in allE) { if (allE[i].Disabled !== true) { allE[i].draw(); } }var allT = this.allThrentities(); for(var i in allT) { allT[i].draw(); } }
,"entityIndexArray":
function() { var ray = []; for(var x in game.active().Omnipresent2D) { ray.push(game.active().Omnipresent2D[x].MyIndex); } var rayLen = ray.length; for(i=0;i<rayLen+this.Entities.length;i++) { if (ray.includes((i).toString())) {  } else {  ray.push(i); } } return ray; }
,"threntityIndexArray":
function() { var ray = []; for(var x in game.active().Omnipresent3D) { ray.push(game.active().Omnipresent3D[x].MyIndex); } var rayLen = ray.length; for(i=0;i<rayLen+this.Threntities.length;i++) { if (ray.includes((i).toString())) {  } else {  ray.push(i); } } return ray; }
,"checkMovePoint3d":
function(point3dBefore, point3dAfter) {  var all = this.allThrentities(); for(var i in all) { if (this.checkPointCollision(all[i], point3dBefore, point3dAfter)==true) { return false; } } return true;  }
,"checkPointCollision":
function(targetThrent, point3dBefore, point3dAfter) { var xBef = point3dBefore.X;var xAft = point3dAfter.X;var yBef = point3dBefore.Y;var yAft = point3dAfter.Y;var zBef = point3dBefore.Z;var zAft = point3dAfter.Z;var minX = targetThrent.L();var maxX = targetThrent.R();var minY = targetThrent.B();var maxY = targetThrent.T();var minZ = targetThrent.A();var maxZ = targetThrent.F();var xOverlap = false; var yOverlap = false; var zOverlap = false;if (xBef<xAft) { xOverlap = this.checkRangeOverlap(xBef, xAft, minX, maxX); } else { xOverlap = this.checkRangeOverlap(xAft, xBef, minX, maxX); }if (yBef<yAft) { yOverlap = this.checkRangeOverlap(yBef, yAft, minY, maxY); } else { yOverlap = this.checkRangeOverlap(yAft, yBef, minY, maxY); }if (zBef<zAft) { zOverlap = this.checkRangeOverlap(zBef, zAft, minZ, maxZ); } else { zOverlap = this.checkRangeOverlap(zAft, zBef, minZ, maxZ); }if (xOverlap==true && yOverlap==true && zOverlap==true) { return true; } return false;}
,"checkRangeOverlap":
function (inputOneMin, inputOneMax, inputTwoMin, inputTwoMax) {if (inputOneMin > inputTwoMax || inputOneMax < inputTwoMin) { return false; }return true;}
,"threnCollideContextual":
function(thren, before, after) { var hasCollide = false;var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name) { if (this.ZStraddle(before, after, all[i])===true && this.XStraddle(before, after, all[i])===true && this.YStraddle(before, after, all[i])===true) { hasCollide = true; } if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { hasCollide = true; } } }return hasCollide;}
,"ZStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.Z - before.Z;let secondDiff = target.Z - after.Z;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"XStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.X - before.X;let secondDiff = target.X - after.Y;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"YStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.Y - before.Y;let secondDiff = target.Y - after.Y;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"getFirstThrenCollide":
function(thren) { var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { return thren; } } }
,"threnCollide":
 function(thren) {var hasCollide = false;var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { hasCollide = true; } }return hasCollide;}
,"moveAll2D":
function(x, y) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } for (var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].X += x; this.AdhocSceneRefs[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } }
,"moveAll2DAround":
function(x, y, entName) { var ent = find(game.scene().Entities, entName); if (this.wouldCollide(ent.transpose(-x, -y)) === false) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } } }
,"quickMoveAll2DAround":
function(x, y, ent) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } for(var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].X += x; this.AdhocSceneRefs[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } }
,"tryMoveAll2DAround":
function(x, y, entName) {if (this.getMainTilegrid() === -1) { return this.moveAll2DAround(x, y, entName); } else { this.dynamic2DMove(x, y, entName, this.getMainTilegrid()); } }
,"dynamic2DMove":
function(x, y, entName, tileGrid) {var ent = game.findEntity(entName);if (this.wouldCollide(ent.transpose(-x, -y)) === false) {this.dynamic2DMoveX(x, ent, tileGrid);this.dynamic2DMoveY(y, ent, tileGrid); }}
,"dynamic2DMoveUp":
function(y, ent, tileGrid) {var amtMoveHeroTowardsCenter = (ent.pastCenterY() === false && ent.isCenteredY() === false) ? 0 : (ent.myCenterY() - viewportCenterY());if (amtMoveHeroTowardsCenter >= y) { ent.Y -= y; return; } else { ent.Y -= amtMoveHeroTowardsCenter; }var remainder = y - amtMoveHeroTowardsCenter;var tileGridSlack = 0 - tileGrid.Y;if (remainder <= Math.abs(tileGridSlack)) { this.quickMoveAll2DAround(0, remainder, ent); return; } else { this.quickMoveAll2DAround(0, Math.abs(tileGridSlack), ent); }remainder = remainder - Math.abs(tileGridSlack);ent.Y -= remainder;}
,"dynamic2DMoveDown":
function(y, ent, tileGrid) {var absY = Math.abs(y);var amtMoveHeroTowardsCenter = (ent.isCenteredY() || ent.pastCenterY()) ? 0 : viewportCenterY() - ent.myCenterY();if (amtMoveHeroTowardsCenter >= absY) { ent.Y -= y; return; } else { ent.Y += amtMoveHeroTowardsCenter; }var remainder = absY - amtMoveHeroTowardsCenter;var tileGridSlack = tileGrid.B() - getYDrawBounds2D();if (remainder <= tileGridSlack) { this.quickMoveAll2DAround(0, -remainder, ent); return; } else { this.quickMoveAll2DAround(0, tileGridSlack, ent); }remainder = remainder - tileGridSlack;ent.Y += remainder;}
,"dynamic2DMoveLeft":
function(x, ent, tileGrid) {var amtMoveHeroTowardsCenter = (ent.pastCenterX() === false && ent.isCenteredX() === false) ? 0 : (ent.myCenterX() - viewportCenterX());if (amtMoveHeroTowardsCenter >= x) { ent.X -= x; return; } else { ent.X -= amtMoveHeroTowardsCenter; }var remainder = x - amtMoveHeroTowardsCenter;var tileGridSlack = 0 - tileGrid.X;if (remainder <= Math.abs(tileGridSlack)) { this.quickMoveAll2DAround(remainder, 0, ent); return; } else { this.quickMoveAll2DAround(Math.abs(tileGridSlack), 0, ent); }remainder = remainder - Math.abs(tileGridSlack);ent.X -= remainder;}
,"dynamic2DMoveRight":
function(x, ent, tileGrid) {var absX = Math.abs(x);var amtMoveHeroTowardsCenter = (ent.isCenteredX() || ent.pastCenterX()) ? 0 : viewportCenterX() - ent.myCenterX();if (amtMoveHeroTowardsCenter >= absX) { ent.X -= x; return; } else { ent.X += amtMoveHeroTowardsCenter; }var remainder = absX - amtMoveHeroTowardsCenter;var tileGridSlack = tileGrid.R() - getXDrawBounds2D();if (remainder <= tileGridSlack) { this.quickMoveAll2DAround(-remainder, 0, ent); return; } else { this.quickMoveAll2DAround(tileGridSlack, 0, ent); }remainder = remainder - tileGridSlack;ent.X += remainder;}
,"dynamic2DMoveX":
function(x, ent, tileGrid) { var movingLeft = x > 0;if (movingLeft) { this.dynamic2DMoveLeft(x, ent, tileGrid); return; } else { this.dynamic2DMoveRight(x, ent, tileGrid); return; }var tileGridSlackX = x < 0 ? -1 * tileGrid.X : tileGrid.R() - getXDrawBounds2D(); if (ent.isCenteredX() !== true) { var centerSlackX = (x < 0 ? ((getXDrawBounds2D() / 2) - ent.X) : ent.X - (getXDrawBounds2D() / 2)); if (centerSlackX > Math.abs(x)) { ent.X -= x; }else if (centerSlackX < Math.abs(x) && centerSlackX > 0) { ent.X -= centerSlackX; }  }else if (tileGridSlackX > Math.abs(x)) { this.moveAll2DAround(x, 0, ent.Name); }else if (tileGridSlackX < Math.abs(x) && tileGridSlackX > 0) { this.moveAll2DAround(tileGridSlackX, 0, ent.Name); }}
,"dynamic2DMoveY":
function(y, ent, tileGrid) { var movingUp = y > 0;if (movingUp) { this.dynamic2DMoveUp(y, ent, tileGrid); return; } else { this.dynamic2DMoveDown(y, ent, tileGrid); return; }var tileGridSlackY = y < 0 ? -1 * tileGrid.Y : tileGrid.B() - getYDrawBounds2D();if (ent.isCenteredY() !== true) { var centerSlackY = (y < 0 ? ((getYDrawBounds2D() / 2) - ent.Y) : ent.Y - (getYDrawBounds2D() / 2)); if (centerSlackY > Math.abs(y)) { ent.Y -= y; }else if (centerSlackY < Math.abs(y) && centerSlackY > 0) { ent.Y -= centerSlackY; }  }else if (tileGridSlackY > Math.abs(y)) { this.moveAll2DAround(y, 0, ent.Name); }else if (tileGridSlackY < Math.abs(y) && tileGridSlackY > 0) { this.moveAll2DAround(tileGridSlackY, 0, ent.Name); }}
,"prepareForRenderer":
 function() {return {  };}
,"loadScene":
function() { loadThrentitiesIntoNewScene(this.allThrentities(), this.PointLights); }
,"allThrentities":
function() { return game.active().Omnipresent3D.concat(this.validLocalThrentities()); }
,"validLocalThrentities":
function() { return this.Threntities.filter(function(obj) { return Object.keys(obj).length > 0; }); }
,"getThrentity":
function (index) { var ent = game.active().getOmni3D(index); if (ent != null) { return ent; } var obj = this.Threntities[index]; if (obj == null || Object.keys(obj).length == 0) { return game.active().getOmni3D(index); } else { return this.Threntities[index]; } }
,"allEntities":
function() { return game.active().Omnipresent2D.concat(this.validLocalEntities()); }
,"validLocalEntities":
function() { return this.Entities.filter(function(obj) { return Object.keys(obj).length > 0; }); }
,"getEntity":
function (index) { var ent = game.active().getOmni2D(index); if (ent != null) { return ent; } var obj = this.Entities[index]; if (obj == null || Object.keys(obj).length == 0) { return game.active().getOmni2D(index); } else { return this.Entities[index]; } }
,"getMainTilegrid":
function() { for(var i in this.TileGrids) { if (this.TileGrids[i].MainGrid === true) { return this.TileGrids[i]; } } return -1; }
,"shiftToTop":
function() {  var main = this.getMainTilegrid(); if (main !== -1) { var moveY = main.Y; this.moveAll2D(0, moveY); return moveY; } }
,"shiftToBottom":
function() {  var main = this.getMainTilegrid(); if (main !== -1) { var moveY = -(main.B() - getYDrawBounds2D()); this.moveAll2D(0, moveY); return moveY; } }
,"shiftToRight":
function() { if (this.shiftedToRight == true) {  }  var main = this.getMainTilegrid(); if (main !== -1) {  var moveX = -(main.R() - getXDrawBounds2D()); this.moveAll2D(moveX, 0); this.shiftedToLeft = false; this.shiftedToRight = true; return moveX; } }
,"shiftToLeft":
function() { if (this.shiftedToLeft == true) {  } var main = this.getMainTilegrid(); if (main !== -1) {  var moveX = main.X; this.moveAll2D(moveX, 0);  this.shiftedToLeft = true; this.shiftedToRight = false; return moveX; } }
,"shiftedToLeft":
false
,"shiftedToRight":
false
,"shiftedToTop":
false
,"shiftedToBottom":
false
,"wouldCollide":
 function(entity) {var hasCollide = false;for (var i in this.TileGrids) { if (this.TileGrids[i].wouldCollide(entity) === true) { hasCollide = true; } }var all = this.allEntities(); for (var i in all) { if (all[i].NotWorldLevel !== true && all[i].NonCorporeal !== true && all[i].Disabled !== true && all[i].Name !== entity.name && all[i].wouldCollide(entity)) { hasCollide = true; } }return hasCollide;}
,"isSetup":
false
,"XResolution":640,"YResolution":400,"HasAmbientLight":false,"AmbientLightIntensity":75,"AmbientLightColor":"0xffffcf","Bounds2DX":0,"Bounds2DY":0,"TileGrids":[{"setup":
function(parent) { if (this.DelimitedGrid && this.DelimitedGrid.length > 0){ var rows = this.DelimitedGrid.split(';');for (var j in rows) { this.tiles.push([]); var cells = rows[j].split(',');  for (var i in cells) { var tile=this.getTile(parent, cells[i]); this.tiles[j].push(tile); } } } }
,"getTile":
function(parentScene, tileId) {  var eName = this.EntityNameCSVKey.split(',')[tileId]; var tile = find(parentScene.allEntities(), eName); /* tile.draw = function(x,y,w,h) { this.MyImage.active().render(x,y,w,h); }; */ return tile;  }
,"draw":
function() { if (this.SkipDraw==true) { return; } for(var j in this.tiles) { for(var i in this.tiles[j]) { if (this.tiles[j][i] != null && this.tiles[j][i].MyImage != null) { this.tiles[j][i].MyImage.active().render(this.X + (i * this.TW),this.Y + (j * this.TH),this.TW,this.TH); } } } }
,"update":
 function() {}
,"tiles":
 [] 
,"R":
 function() {return this.X + (this.getWidth() * this.TW);}
,"B":
 function() {return this.Y + (this.getHeight() * this.TH);}
,"wouldCollide":
 function(entity) {for(var j in this.tiles)      {       for (var i in this.tiles[j])       {        if (this.tiles[j][i] != null && this.tiles[j][i].ForceCollision===true)        {         var x = this.X + (i * this.TW);         var y = this.Y + (j * this.TH);         if (checkOverlap({X:x,Y:y,W:this.TW,H:this.TH}, entity) === true)         {          console.log('overlap found');         var events = this.tiles[j][i].collisionEvents;         if (events !== null)         {         }         if (this.tiles[j][i].LedgeCollision === true)         {          if (/*notideal*/downkey() && !leftkey() && !rightkey())          {           console.log('ledge collision detected');           /*arbitrary*/var speed = 4;           /* make entity.MyLogic have a non null ActionBlock? */           entity.Me.MyLogic.ActionBlock.MyActions.push({Depth:((this.TH/speed)*2)+1,SelfDestruct:true,Ct:0,Destroyed:false,update:function() { console.log('updating action');  if (this.BlockInput === true) { BlockInput(); } if (this.SelfDestruct === true && this.Ct + 1 == this.Depth) { this.Destroyed = true; } if (this.Destroyed !== true) { this.MyScript(); this.Ct++; } },MyTarget:entity,BlockInput:true,LocalData:speed,MyScript:function() { console.log('performing action...'); this.MyTarget.Me.Y += this.LocalData; }});          }         }         return true;         }        }       }      }       return false;}
,"getWidth":
function() { if (this.getHeight() > 0) { return this.tiles[0].length; } else { return 0; } }
,"getHeight":
function() { return this.tiles.length; }
,"EntityIndexCSVKey":"","EntityNameCSVKey":"tile1,tile2,tile3,tile4","DelimitedGrid":"0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;0,0,0,0,0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,0,0,0,0","SkipDraw":false,"MainGrid":true,"TW":32,"TH":32,"X":0,"Y":0,"Name":"","LocalData":"","TypeName":"TileGrid","Id":314}],"AdhocSceneRefs":[],"Entities":[{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2232}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2226},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2226},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'grass32');}
,"NameOfTarget":"grass32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6208}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2226},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile1","LocalData":"","TypeName":"Entity","Id":2226},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2233}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2227},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2227},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'stone32');}
,"NameOfTarget":"stone32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6209}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2227},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile2","LocalData":"","TypeName":"Entity","Id":2227},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2234}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2228},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2228},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":8,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water1');}
,"NameOfTarget":"water1","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6210},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water2');}
,"NameOfTarget":"water2","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6211},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water3');}
,"NameOfTarget":"water3","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6212},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water4');}
,"NameOfTarget":"water4","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6213},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water5');}
,"NameOfTarget":"water5","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6214},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water6');}
,"NameOfTarget":"water6","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6215},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water7');}
,"NameOfTarget":"water7","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6216},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water8');}
,"NameOfTarget":"water8","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6217},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water9');}
,"NameOfTarget":"water9","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6218},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water10');}
,"NameOfTarget":"water10","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6219},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water11');}
,"NameOfTarget":"water11","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6220},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water12');}
,"NameOfTarget":"water12","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6221},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water13');}
,"NameOfTarget":"water13","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6222},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water14');}
,"NameOfTarget":"water14","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6223},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water15');}
,"NameOfTarget":"water15","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6224}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2228},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile3","LocalData":"","TypeName":"Entity","Id":2228},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2235}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2229},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2229},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'stoneWall32');}
,"NameOfTarget":"stoneWall32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6225}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2229},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":true,"LedgeCollision":true,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile4","LocalData":"","TypeName":"Entity","Id":2229}],"Threntities":[],"PointLights":[],"MyAudio":[],"MyLogic":{"update":
 function() {for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":null,"TypeName":"SceneProceduralStatement","Id":0},{"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"SceneProceduralStatement","Id":350}],"Name":"","LocalData":"","TypeName":"SceneLogicBox","Id":350},"Name":"","LocalData":"","TypeName":"Scene","Id":350},{"reloadThrentities":
function() { var allT = this.allThrentities(); for(var i in allT) { setupThrentity(allT[i]); } }
,"setup":
 function() {if (this.isSetup !== true) {for(var i in this.TileGrids) { this.TileGrids[i].setup(this); } for(var i in this.PointLights) { this.PointLights[i].setup(this); } if (this.MyAudio !== null) { for (var i = 0; i < this.MyAudio.length; i++) { this.MyAudio[i].setup(); } }if (game.active().Omnipresent2D.length > 0) { var indices = this.entityIndexArray(); var allE = this.allEntities();  for(var i in allE) { if (allE[i].MyIndex != '') { var ind = indices.indexOf(allE[i].MyIndex); if(ind != -1) { indices.splice(ind, 1); } } else { allE[i].setup(indices[i]); } }  } else { for(var i in this.Entities) { this.Entities[i].setup(i); } }if (game.active().Omnipresent3D.length > 0) { var indices = this.threntityIndexArray(); var allT = this.allThrentities(); for(var i in allT) { if (allT[i].MyIndex != '') { var ind = indices.indexOf(allT[i].MyIndex); if (ind != -1) { indices.splice(ind, 1); } } else { allT[i].setup(indices[i]); } }  } else { for(var i in this.Threntities) { this.Threntities[i].setup(i); } }if (this.HasAmbientLight == true) { addAmbientLightToCurrentScene(this.AmbientLightColor, this.AmbientLightIntensity / parseFloat(100)); }this.isSetup = true; }}
,"update":
 function() {this.MyLogic.update();for(var i in this.MyAudio) { this.MyAudio[i].update(); } var allE = this.allEntities(); for(var i in allE) { allE[i].update(); }var allT = this.allThrentities(); for(var i in allT) { allT[i].update(); }for(var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].update(this.AdhocSceneRefs[i].TargetName); } for(var i in this.TileGrids) { this.TileGrids[i].update(); } }
,"draw":
 function() {for(var i in this.TileGrids) { this.TileGrids[i].draw(); } var allE = this.allEntities(); for(var i in allE) { if (allE[i].Disabled !== true) { allE[i].draw(); } }var allT = this.allThrentities(); for(var i in allT) { allT[i].draw(); } }
,"entityIndexArray":
function() { var ray = []; for(var x in game.active().Omnipresent2D) { ray.push(game.active().Omnipresent2D[x].MyIndex); } var rayLen = ray.length; for(i=0;i<rayLen+this.Entities.length;i++) { if (ray.includes((i).toString())) {  } else {  ray.push(i); } } return ray; }
,"threntityIndexArray":
function() { var ray = []; for(var x in game.active().Omnipresent3D) { ray.push(game.active().Omnipresent3D[x].MyIndex); } var rayLen = ray.length; for(i=0;i<rayLen+this.Threntities.length;i++) { if (ray.includes((i).toString())) {  } else {  ray.push(i); } } return ray; }
,"checkMovePoint3d":
function(point3dBefore, point3dAfter) {  var all = this.allThrentities(); for(var i in all) { if (this.checkPointCollision(all[i], point3dBefore, point3dAfter)==true) { return false; } } return true;  }
,"checkPointCollision":
function(targetThrent, point3dBefore, point3dAfter) { var xBef = point3dBefore.X;var xAft = point3dAfter.X;var yBef = point3dBefore.Y;var yAft = point3dAfter.Y;var zBef = point3dBefore.Z;var zAft = point3dAfter.Z;var minX = targetThrent.L();var maxX = targetThrent.R();var minY = targetThrent.B();var maxY = targetThrent.T();var minZ = targetThrent.A();var maxZ = targetThrent.F();var xOverlap = false; var yOverlap = false; var zOverlap = false;if (xBef<xAft) { xOverlap = this.checkRangeOverlap(xBef, xAft, minX, maxX); } else { xOverlap = this.checkRangeOverlap(xAft, xBef, minX, maxX); }if (yBef<yAft) { yOverlap = this.checkRangeOverlap(yBef, yAft, minY, maxY); } else { yOverlap = this.checkRangeOverlap(yAft, yBef, minY, maxY); }if (zBef<zAft) { zOverlap = this.checkRangeOverlap(zBef, zAft, minZ, maxZ); } else { zOverlap = this.checkRangeOverlap(zAft, zBef, minZ, maxZ); }if (xOverlap==true && yOverlap==true && zOverlap==true) { return true; } return false;}
,"checkRangeOverlap":
function (inputOneMin, inputOneMax, inputTwoMin, inputTwoMax) {if (inputOneMin > inputTwoMax || inputOneMax < inputTwoMin) { return false; }return true;}
,"threnCollideContextual":
function(thren, before, after) { var hasCollide = false;var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name) { if (this.ZStraddle(before, after, all[i])===true && this.XStraddle(before, after, all[i])===true && this.YStraddle(before, after, all[i])===true) { hasCollide = true; } if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { hasCollide = true; } } }return hasCollide;}
,"ZStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.Z - before.Z;let secondDiff = target.Z - after.Z;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"XStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.X - before.X;let secondDiff = target.X - after.Y;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"YStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.Y - before.Y;let secondDiff = target.Y - after.Y;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"getFirstThrenCollide":
function(thren) { var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { return thren; } } }
,"threnCollide":
 function(thren) {var hasCollide = false;var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { hasCollide = true; } }return hasCollide;}
,"moveAll2D":
function(x, y) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } for (var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].X += x; this.AdhocSceneRefs[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } }
,"moveAll2DAround":
function(x, y, entName) { var ent = find(game.scene().Entities, entName); if (this.wouldCollide(ent.transpose(-x, -y)) === false) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } } }
,"quickMoveAll2DAround":
function(x, y, ent) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } for(var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].X += x; this.AdhocSceneRefs[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } }
,"tryMoveAll2DAround":
function(x, y, entName) {if (this.getMainTilegrid() === -1) { return this.moveAll2DAround(x, y, entName); } else { this.dynamic2DMove(x, y, entName, this.getMainTilegrid()); } }
,"dynamic2DMove":
function(x, y, entName, tileGrid) {var ent = game.findEntity(entName);if (this.wouldCollide(ent.transpose(-x, -y)) === false) {this.dynamic2DMoveX(x, ent, tileGrid);this.dynamic2DMoveY(y, ent, tileGrid); }}
,"dynamic2DMoveUp":
function(y, ent, tileGrid) {var amtMoveHeroTowardsCenter = (ent.pastCenterY() === false && ent.isCenteredY() === false) ? 0 : (ent.myCenterY() - viewportCenterY());if (amtMoveHeroTowardsCenter >= y) { ent.Y -= y; return; } else { ent.Y -= amtMoveHeroTowardsCenter; }var remainder = y - amtMoveHeroTowardsCenter;var tileGridSlack = 0 - tileGrid.Y;if (remainder <= Math.abs(tileGridSlack)) { this.quickMoveAll2DAround(0, remainder, ent); return; } else { this.quickMoveAll2DAround(0, Math.abs(tileGridSlack), ent); }remainder = remainder - Math.abs(tileGridSlack);ent.Y -= remainder;}
,"dynamic2DMoveDown":
function(y, ent, tileGrid) {var absY = Math.abs(y);var amtMoveHeroTowardsCenter = (ent.isCenteredY() || ent.pastCenterY()) ? 0 : viewportCenterY() - ent.myCenterY();if (amtMoveHeroTowardsCenter >= absY) { ent.Y -= y; return; } else { ent.Y += amtMoveHeroTowardsCenter; }var remainder = absY - amtMoveHeroTowardsCenter;var tileGridSlack = tileGrid.B() - getYDrawBounds2D();if (remainder <= tileGridSlack) { this.quickMoveAll2DAround(0, -remainder, ent); return; } else { this.quickMoveAll2DAround(0, tileGridSlack, ent); }remainder = remainder - tileGridSlack;ent.Y += remainder;}
,"dynamic2DMoveLeft":
function(x, ent, tileGrid) {var amtMoveHeroTowardsCenter = (ent.pastCenterX() === false && ent.isCenteredX() === false) ? 0 : (ent.myCenterX() - viewportCenterX());if (amtMoveHeroTowardsCenter >= x) { ent.X -= x; return; } else { ent.X -= amtMoveHeroTowardsCenter; }var remainder = x - amtMoveHeroTowardsCenter;var tileGridSlack = 0 - tileGrid.X;if (remainder <= Math.abs(tileGridSlack)) { this.quickMoveAll2DAround(remainder, 0, ent); return; } else { this.quickMoveAll2DAround(Math.abs(tileGridSlack), 0, ent); }remainder = remainder - Math.abs(tileGridSlack);ent.X -= remainder;}
,"dynamic2DMoveRight":
function(x, ent, tileGrid) {var absX = Math.abs(x);var amtMoveHeroTowardsCenter = (ent.isCenteredX() || ent.pastCenterX()) ? 0 : viewportCenterX() - ent.myCenterX();if (amtMoveHeroTowardsCenter >= absX) { ent.X -= x; return; } else { ent.X += amtMoveHeroTowardsCenter; }var remainder = absX - amtMoveHeroTowardsCenter;var tileGridSlack = tileGrid.R() - getXDrawBounds2D();if (remainder <= tileGridSlack) { this.quickMoveAll2DAround(-remainder, 0, ent); return; } else { this.quickMoveAll2DAround(tileGridSlack, 0, ent); }remainder = remainder - tileGridSlack;ent.X += remainder;}
,"dynamic2DMoveX":
function(x, ent, tileGrid) { var movingLeft = x > 0;if (movingLeft) { this.dynamic2DMoveLeft(x, ent, tileGrid); return; } else { this.dynamic2DMoveRight(x, ent, tileGrid); return; }var tileGridSlackX = x < 0 ? -1 * tileGrid.X : tileGrid.R() - getXDrawBounds2D(); if (ent.isCenteredX() !== true) { var centerSlackX = (x < 0 ? ((getXDrawBounds2D() / 2) - ent.X) : ent.X - (getXDrawBounds2D() / 2)); if (centerSlackX > Math.abs(x)) { ent.X -= x; }else if (centerSlackX < Math.abs(x) && centerSlackX > 0) { ent.X -= centerSlackX; }  }else if (tileGridSlackX > Math.abs(x)) { this.moveAll2DAround(x, 0, ent.Name); }else if (tileGridSlackX < Math.abs(x) && tileGridSlackX > 0) { this.moveAll2DAround(tileGridSlackX, 0, ent.Name); }}
,"dynamic2DMoveY":
function(y, ent, tileGrid) { var movingUp = y > 0;if (movingUp) { this.dynamic2DMoveUp(y, ent, tileGrid); return; } else { this.dynamic2DMoveDown(y, ent, tileGrid); return; }var tileGridSlackY = y < 0 ? -1 * tileGrid.Y : tileGrid.B() - getYDrawBounds2D();if (ent.isCenteredY() !== true) { var centerSlackY = (y < 0 ? ((getYDrawBounds2D() / 2) - ent.Y) : ent.Y - (getYDrawBounds2D() / 2)); if (centerSlackY > Math.abs(y)) { ent.Y -= y; }else if (centerSlackY < Math.abs(y) && centerSlackY > 0) { ent.Y -= centerSlackY; }  }else if (tileGridSlackY > Math.abs(y)) { this.moveAll2DAround(y, 0, ent.Name); }else if (tileGridSlackY < Math.abs(y) && tileGridSlackY > 0) { this.moveAll2DAround(tileGridSlackY, 0, ent.Name); }}
,"prepareForRenderer":
 function() {return {  };}
,"loadScene":
function() { loadThrentitiesIntoNewScene(this.allThrentities(), this.PointLights); }
,"allThrentities":
function() { return game.active().Omnipresent3D.concat(this.validLocalThrentities()); }
,"validLocalThrentities":
function() { return this.Threntities.filter(function(obj) { return Object.keys(obj).length > 0; }); }
,"getThrentity":
function (index) { var ent = game.active().getOmni3D(index); if (ent != null) { return ent; } var obj = this.Threntities[index]; if (obj == null || Object.keys(obj).length == 0) { return game.active().getOmni3D(index); } else { return this.Threntities[index]; } }
,"allEntities":
function() { return game.active().Omnipresent2D.concat(this.validLocalEntities()); }
,"validLocalEntities":
function() { return this.Entities.filter(function(obj) { return Object.keys(obj).length > 0; }); }
,"getEntity":
function (index) { var ent = game.active().getOmni2D(index); if (ent != null) { return ent; } var obj = this.Entities[index]; if (obj == null || Object.keys(obj).length == 0) { return game.active().getOmni2D(index); } else { return this.Entities[index]; } }
,"getMainTilegrid":
function() { for(var i in this.TileGrids) { if (this.TileGrids[i].MainGrid === true) { return this.TileGrids[i]; } } return -1; }
,"shiftToTop":
function() {  var main = this.getMainTilegrid(); if (main !== -1) { var moveY = main.Y; this.moveAll2D(0, moveY); return moveY; } }
,"shiftToBottom":
function() {  var main = this.getMainTilegrid(); if (main !== -1) { var moveY = -(main.B() - getYDrawBounds2D()); this.moveAll2D(0, moveY); return moveY; } }
,"shiftToRight":
function() { if (this.shiftedToRight == true) {  }  var main = this.getMainTilegrid(); if (main !== -1) {  var moveX = -(main.R() - getXDrawBounds2D()); this.moveAll2D(moveX, 0); this.shiftedToLeft = false; this.shiftedToRight = true; return moveX; } }
,"shiftToLeft":
function() { if (this.shiftedToLeft == true) {  } var main = this.getMainTilegrid(); if (main !== -1) {  var moveX = main.X; this.moveAll2D(moveX, 0);  this.shiftedToLeft = true; this.shiftedToRight = false; return moveX; } }
,"shiftedToLeft":
false
,"shiftedToRight":
false
,"shiftedToTop":
false
,"shiftedToBottom":
false
,"wouldCollide":
 function(entity) {var hasCollide = false;for (var i in this.TileGrids) { if (this.TileGrids[i].wouldCollide(entity) === true) { hasCollide = true; } }var all = this.allEntities(); for (var i in all) { if (all[i].NotWorldLevel !== true && all[i].NonCorporeal !== true && all[i].Disabled !== true && all[i].Name !== entity.name && all[i].wouldCollide(entity)) { hasCollide = true; } }return hasCollide;}
,"isSetup":
false
,"XResolution":640,"YResolution":400,"HasAmbientLight":false,"AmbientLightIntensity":75,"AmbientLightColor":"0xffffcf","Bounds2DX":0,"Bounds2DY":0,"TileGrids":[{"setup":
function(parent) { if (this.DelimitedGrid && this.DelimitedGrid.length > 0){ var rows = this.DelimitedGrid.split(';');for (var j in rows) { this.tiles.push([]); var cells = rows[j].split(',');  for (var i in cells) { var tile=this.getTile(parent, cells[i]); this.tiles[j].push(tile); } } } }
,"getTile":
function(parentScene, tileId) {  var eName = this.EntityNameCSVKey.split(',')[tileId]; var tile = find(parentScene.allEntities(), eName); /* tile.draw = function(x,y,w,h) { this.MyImage.active().render(x,y,w,h); }; */ return tile;  }
,"draw":
function() { if (this.SkipDraw==true) { return; } for(var j in this.tiles) { for(var i in this.tiles[j]) { if (this.tiles[j][i] != null && this.tiles[j][i].MyImage != null) { this.tiles[j][i].MyImage.active().render(this.X + (i * this.TW),this.Y + (j * this.TH),this.TW,this.TH); } } } }
,"update":
 function() {}
,"tiles":
 [] 
,"R":
 function() {return this.X + (this.getWidth() * this.TW);}
,"B":
 function() {return this.Y + (this.getHeight() * this.TH);}
,"wouldCollide":
 function(entity) {for(var j in this.tiles)      {       for (var i in this.tiles[j])       {        if (this.tiles[j][i] != null && this.tiles[j][i].ForceCollision===true)        {         var x = this.X + (i * this.TW);         var y = this.Y + (j * this.TH);         if (checkOverlap({X:x,Y:y,W:this.TW,H:this.TH}, entity) === true)         {          console.log('overlap found');         var events = this.tiles[j][i].collisionEvents;         if (events !== null)         {         }         if (this.tiles[j][i].LedgeCollision === true)         {          if (/*notideal*/downkey() && !leftkey() && !rightkey())          {           console.log('ledge collision detected');           /*arbitrary*/var speed = 4;           /* make entity.MyLogic have a non null ActionBlock? */           entity.Me.MyLogic.ActionBlock.MyActions.push({Depth:((this.TH/speed)*2)+1,SelfDestruct:true,Ct:0,Destroyed:false,update:function() { console.log('updating action');  if (this.BlockInput === true) { BlockInput(); } if (this.SelfDestruct === true && this.Ct + 1 == this.Depth) { this.Destroyed = true; } if (this.Destroyed !== true) { this.MyScript(); this.Ct++; } },MyTarget:entity,BlockInput:true,LocalData:speed,MyScript:function() { console.log('performing action...'); this.MyTarget.Me.Y += this.LocalData; }});          }         }         return true;         }        }       }      }       return false;}
,"getWidth":
function() { if (this.getHeight() > 0) { return this.tiles[0].length; } else { return 0; } }
,"getHeight":
function() { return this.tiles.length; }
,"EntityIndexCSVKey":"","EntityNameCSVKey":"tile1,tile2,tile3,tile4,tile5,tile6","DelimitedGrid":"4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4","SkipDraw":false,"MainGrid":true,"TW":32,"TH":32,"X":0,"Y":0,"Name":"","LocalData":"","TypeName":"TileGrid","Id":315}],"AdhocSceneRefs":[],"Entities":[{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2236}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2230},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2230},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'grass32');}
,"NameOfTarget":"grass32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6226}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2230},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile1","LocalData":"","TypeName":"Entity","Id":2230},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2237}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2231},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2231},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'stone32');}
,"NameOfTarget":"stone32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6227}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2231},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile2","LocalData":"","TypeName":"Entity","Id":2231},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2238}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2232},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2232},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":8,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water1');}
,"NameOfTarget":"water1","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6228},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water2');}
,"NameOfTarget":"water2","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6229},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water3');}
,"NameOfTarget":"water3","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6230},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water4');}
,"NameOfTarget":"water4","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6231},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water5');}
,"NameOfTarget":"water5","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6232},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water6');}
,"NameOfTarget":"water6","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6233},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water7');}
,"NameOfTarget":"water7","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6234},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water8');}
,"NameOfTarget":"water8","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6235},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water9');}
,"NameOfTarget":"water9","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6236},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water10');}
,"NameOfTarget":"water10","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6237},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water11');}
,"NameOfTarget":"water11","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6238},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water12');}
,"NameOfTarget":"water12","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6239},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water13');}
,"NameOfTarget":"water13","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6240},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water14');}
,"NameOfTarget":"water14","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6241},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water15');}
,"NameOfTarget":"water15","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6242}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2232},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile3","LocalData":"","TypeName":"Entity","Id":2232},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2239}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2233},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2233},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'stoneWall32');}
,"NameOfTarget":"stoneWall32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6243}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2233},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":true,"LedgeCollision":true,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile4","LocalData":"","TypeName":"Entity","Id":2233},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2240}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2234},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2234},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'dirt32');}
,"NameOfTarget":"dirt32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6244}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2234},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile5","LocalData":"","TypeName":"Entity","Id":2234},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2241}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2235},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2235},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return true;}
,"imageFilePath":"ivanGreatForest205_cc_tile60.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'ivanGreatForest205tile60');}
,"NameOfTarget":"","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6245}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2235},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":true,"LedgeCollision":true,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile6","LocalData":"","TypeName":"Entity","Id":2235}],"Threntities":[],"PointLights":[],"MyAudio":[],"MyLogic":{"update":
 function() {for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":null,"TypeName":"SceneProceduralStatement","Id":0},{"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"SceneProceduralStatement","Id":351}],"Name":"","LocalData":"","TypeName":"SceneLogicBox","Id":351},"Name":"","LocalData":"","TypeName":"Scene","Id":351},{"reloadThrentities":
function() { var allT = this.allThrentities(); for(var i in allT) { setupThrentity(allT[i]); } }
,"setup":
 function() {if (this.isSetup !== true) {for(var i in this.TileGrids) { this.TileGrids[i].setup(this); } for(var i in this.PointLights) { this.PointLights[i].setup(this); } if (this.MyAudio !== null) { for (var i = 0; i < this.MyAudio.length; i++) { this.MyAudio[i].setup(); } }if (game.active().Omnipresent2D.length > 0) { var indices = this.entityIndexArray(); var allE = this.allEntities();  for(var i in allE) { if (allE[i].MyIndex != '') { var ind = indices.indexOf(allE[i].MyIndex); if(ind != -1) { indices.splice(ind, 1); } } else { allE[i].setup(indices[i]); } }  } else { for(var i in this.Entities) { this.Entities[i].setup(i); } }if (game.active().Omnipresent3D.length > 0) { var indices = this.threntityIndexArray(); var allT = this.allThrentities(); for(var i in allT) { if (allT[i].MyIndex != '') { var ind = indices.indexOf(allT[i].MyIndex); if (ind != -1) { indices.splice(ind, 1); } } else { allT[i].setup(indices[i]); } }  } else { for(var i in this.Threntities) { this.Threntities[i].setup(i); } }if (this.HasAmbientLight == true) { addAmbientLightToCurrentScene(this.AmbientLightColor, this.AmbientLightIntensity / parseFloat(100)); }this.isSetup = true; }}
,"update":
 function() {this.MyLogic.update();for(var i in this.MyAudio) { this.MyAudio[i].update(); } var allE = this.allEntities(); for(var i in allE) { allE[i].update(); }var allT = this.allThrentities(); for(var i in allT) { allT[i].update(); }for(var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].update(this.AdhocSceneRefs[i].TargetName); } for(var i in this.TileGrids) { this.TileGrids[i].update(); } }
,"draw":
 function() {for(var i in this.TileGrids) { this.TileGrids[i].draw(); } var allE = this.allEntities(); for(var i in allE) { if (allE[i].Disabled !== true) { allE[i].draw(); } }var allT = this.allThrentities(); for(var i in allT) { allT[i].draw(); } }
,"entityIndexArray":
function() { var ray = []; for(var x in game.active().Omnipresent2D) { ray.push(game.active().Omnipresent2D[x].MyIndex); } var rayLen = ray.length; for(i=0;i<rayLen+this.Entities.length;i++) { if (ray.includes((i).toString())) {  } else {  ray.push(i); } } return ray; }
,"threntityIndexArray":
function() { var ray = []; for(var x in game.active().Omnipresent3D) { ray.push(game.active().Omnipresent3D[x].MyIndex); } var rayLen = ray.length; for(i=0;i<rayLen+this.Threntities.length;i++) { if (ray.includes((i).toString())) {  } else {  ray.push(i); } } return ray; }
,"checkMovePoint3d":
function(point3dBefore, point3dAfter) {  var all = this.allThrentities(); for(var i in all) { if (this.checkPointCollision(all[i], point3dBefore, point3dAfter)==true) { return false; } } return true;  }
,"checkPointCollision":
function(targetThrent, point3dBefore, point3dAfter) { var xBef = point3dBefore.X;var xAft = point3dAfter.X;var yBef = point3dBefore.Y;var yAft = point3dAfter.Y;var zBef = point3dBefore.Z;var zAft = point3dAfter.Z;var minX = targetThrent.L();var maxX = targetThrent.R();var minY = targetThrent.B();var maxY = targetThrent.T();var minZ = targetThrent.A();var maxZ = targetThrent.F();var xOverlap = false; var yOverlap = false; var zOverlap = false;if (xBef<xAft) { xOverlap = this.checkRangeOverlap(xBef, xAft, minX, maxX); } else { xOverlap = this.checkRangeOverlap(xAft, xBef, minX, maxX); }if (yBef<yAft) { yOverlap = this.checkRangeOverlap(yBef, yAft, minY, maxY); } else { yOverlap = this.checkRangeOverlap(yAft, yBef, minY, maxY); }if (zBef<zAft) { zOverlap = this.checkRangeOverlap(zBef, zAft, minZ, maxZ); } else { zOverlap = this.checkRangeOverlap(zAft, zBef, minZ, maxZ); }if (xOverlap==true && yOverlap==true && zOverlap==true) { return true; } return false;}
,"checkRangeOverlap":
function (inputOneMin, inputOneMax, inputTwoMin, inputTwoMax) {if (inputOneMin > inputTwoMax || inputOneMax < inputTwoMin) { return false; }return true;}
,"threnCollideContextual":
function(thren, before, after) { var hasCollide = false;var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name) { if (this.ZStraddle(before, after, all[i])===true && this.XStraddle(before, after, all[i])===true && this.YStraddle(before, after, all[i])===true) { hasCollide = true; } if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { hasCollide = true; } } }return hasCollide;}
,"ZStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.Z - before.Z;let secondDiff = target.Z - after.Z;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"XStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.X - before.X;let secondDiff = target.X - after.Y;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"YStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.Y - before.Y;let secondDiff = target.Y - after.Y;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"getFirstThrenCollide":
function(thren) { var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { return thren; } } }
,"threnCollide":
 function(thren) {var hasCollide = false;var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { hasCollide = true; } }return hasCollide;}
,"moveAll2D":
function(x, y) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } for (var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].X += x; this.AdhocSceneRefs[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } }
,"moveAll2DAround":
function(x, y, entName) { var ent = find(game.scene().Entities, entName); if (this.wouldCollide(ent.transpose(-x, -y)) === false) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } } }
,"quickMoveAll2DAround":
function(x, y, ent) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } for(var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].X += x; this.AdhocSceneRefs[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } }
,"tryMoveAll2DAround":
function(x, y, entName) {if (this.getMainTilegrid() === -1) { return this.moveAll2DAround(x, y, entName); } else { this.dynamic2DMove(x, y, entName, this.getMainTilegrid()); } }
,"dynamic2DMove":
function(x, y, entName, tileGrid) {var ent = game.findEntity(entName);if (this.wouldCollide(ent.transpose(-x, -y)) === false) {this.dynamic2DMoveX(x, ent, tileGrid);this.dynamic2DMoveY(y, ent, tileGrid); }}
,"dynamic2DMoveUp":
function(y, ent, tileGrid) {var amtMoveHeroTowardsCenter = (ent.pastCenterY() === false && ent.isCenteredY() === false) ? 0 : (ent.myCenterY() - viewportCenterY());if (amtMoveHeroTowardsCenter >= y) { ent.Y -= y; return; } else { ent.Y -= amtMoveHeroTowardsCenter; }var remainder = y - amtMoveHeroTowardsCenter;var tileGridSlack = 0 - tileGrid.Y;if (remainder <= Math.abs(tileGridSlack)) { this.quickMoveAll2DAround(0, remainder, ent); return; } else { this.quickMoveAll2DAround(0, Math.abs(tileGridSlack), ent); }remainder = remainder - Math.abs(tileGridSlack);ent.Y -= remainder;}
,"dynamic2DMoveDown":
function(y, ent, tileGrid) {var absY = Math.abs(y);var amtMoveHeroTowardsCenter = (ent.isCenteredY() || ent.pastCenterY()) ? 0 : viewportCenterY() - ent.myCenterY();if (amtMoveHeroTowardsCenter >= absY) { ent.Y -= y; return; } else { ent.Y += amtMoveHeroTowardsCenter; }var remainder = absY - amtMoveHeroTowardsCenter;var tileGridSlack = tileGrid.B() - getYDrawBounds2D();if (remainder <= tileGridSlack) { this.quickMoveAll2DAround(0, -remainder, ent); return; } else { this.quickMoveAll2DAround(0, tileGridSlack, ent); }remainder = remainder - tileGridSlack;ent.Y += remainder;}
,"dynamic2DMoveLeft":
function(x, ent, tileGrid) {var amtMoveHeroTowardsCenter = (ent.pastCenterX() === false && ent.isCenteredX() === false) ? 0 : (ent.myCenterX() - viewportCenterX());if (amtMoveHeroTowardsCenter >= x) { ent.X -= x; return; } else { ent.X -= amtMoveHeroTowardsCenter; }var remainder = x - amtMoveHeroTowardsCenter;var tileGridSlack = 0 - tileGrid.X;if (remainder <= Math.abs(tileGridSlack)) { this.quickMoveAll2DAround(remainder, 0, ent); return; } else { this.quickMoveAll2DAround(Math.abs(tileGridSlack), 0, ent); }remainder = remainder - Math.abs(tileGridSlack);ent.X -= remainder;}
,"dynamic2DMoveRight":
function(x, ent, tileGrid) {var absX = Math.abs(x);var amtMoveHeroTowardsCenter = (ent.isCenteredX() || ent.pastCenterX()) ? 0 : viewportCenterX() - ent.myCenterX();if (amtMoveHeroTowardsCenter >= absX) { ent.X -= x; return; } else { ent.X += amtMoveHeroTowardsCenter; }var remainder = absX - amtMoveHeroTowardsCenter;var tileGridSlack = tileGrid.R() - getXDrawBounds2D();if (remainder <= tileGridSlack) { this.quickMoveAll2DAround(-remainder, 0, ent); return; } else { this.quickMoveAll2DAround(tileGridSlack, 0, ent); }remainder = remainder - tileGridSlack;ent.X += remainder;}
,"dynamic2DMoveX":
function(x, ent, tileGrid) { var movingLeft = x > 0;if (movingLeft) { this.dynamic2DMoveLeft(x, ent, tileGrid); return; } else { this.dynamic2DMoveRight(x, ent, tileGrid); return; }var tileGridSlackX = x < 0 ? -1 * tileGrid.X : tileGrid.R() - getXDrawBounds2D(); if (ent.isCenteredX() !== true) { var centerSlackX = (x < 0 ? ((getXDrawBounds2D() / 2) - ent.X) : ent.X - (getXDrawBounds2D() / 2)); if (centerSlackX > Math.abs(x)) { ent.X -= x; }else if (centerSlackX < Math.abs(x) && centerSlackX > 0) { ent.X -= centerSlackX; }  }else if (tileGridSlackX > Math.abs(x)) { this.moveAll2DAround(x, 0, ent.Name); }else if (tileGridSlackX < Math.abs(x) && tileGridSlackX > 0) { this.moveAll2DAround(tileGridSlackX, 0, ent.Name); }}
,"dynamic2DMoveY":
function(y, ent, tileGrid) { var movingUp = y > 0;if (movingUp) { this.dynamic2DMoveUp(y, ent, tileGrid); return; } else { this.dynamic2DMoveDown(y, ent, tileGrid); return; }var tileGridSlackY = y < 0 ? -1 * tileGrid.Y : tileGrid.B() - getYDrawBounds2D();if (ent.isCenteredY() !== true) { var centerSlackY = (y < 0 ? ((getYDrawBounds2D() / 2) - ent.Y) : ent.Y - (getYDrawBounds2D() / 2)); if (centerSlackY > Math.abs(y)) { ent.Y -= y; }else if (centerSlackY < Math.abs(y) && centerSlackY > 0) { ent.Y -= centerSlackY; }  }else if (tileGridSlackY > Math.abs(y)) { this.moveAll2DAround(y, 0, ent.Name); }else if (tileGridSlackY < Math.abs(y) && tileGridSlackY > 0) { this.moveAll2DAround(tileGridSlackY, 0, ent.Name); }}
,"prepareForRenderer":
 function() {return {  };}
,"loadScene":
function() { loadThrentitiesIntoNewScene(this.allThrentities(), this.PointLights); }
,"allThrentities":
function() { return game.active().Omnipresent3D.concat(this.validLocalThrentities()); }
,"validLocalThrentities":
function() { return this.Threntities.filter(function(obj) { return Object.keys(obj).length > 0; }); }
,"getThrentity":
function (index) { var ent = game.active().getOmni3D(index); if (ent != null) { return ent; } var obj = this.Threntities[index]; if (obj == null || Object.keys(obj).length == 0) { return game.active().getOmni3D(index); } else { return this.Threntities[index]; } }
,"allEntities":
function() { return game.active().Omnipresent2D.concat(this.validLocalEntities()); }
,"validLocalEntities":
function() { return this.Entities.filter(function(obj) { return Object.keys(obj).length > 0; }); }
,"getEntity":
function (index) { var ent = game.active().getOmni2D(index); if (ent != null) { return ent; } var obj = this.Entities[index]; if (obj == null || Object.keys(obj).length == 0) { return game.active().getOmni2D(index); } else { return this.Entities[index]; } }
,"getMainTilegrid":
function() { for(var i in this.TileGrids) { if (this.TileGrids[i].MainGrid === true) { return this.TileGrids[i]; } } return -1; }
,"shiftToTop":
function() {  var main = this.getMainTilegrid(); if (main !== -1) { var moveY = main.Y; this.moveAll2D(0, moveY); return moveY; } }
,"shiftToBottom":
function() {  var main = this.getMainTilegrid(); if (main !== -1) { var moveY = -(main.B() - getYDrawBounds2D()); this.moveAll2D(0, moveY); return moveY; } }
,"shiftToRight":
function() { if (this.shiftedToRight == true) {  }  var main = this.getMainTilegrid(); if (main !== -1) {  var moveX = -(main.R() - getXDrawBounds2D()); this.moveAll2D(moveX, 0); this.shiftedToLeft = false; this.shiftedToRight = true; return moveX; } }
,"shiftToLeft":
function() { if (this.shiftedToLeft == true) {  } var main = this.getMainTilegrid(); if (main !== -1) {  var moveX = main.X; this.moveAll2D(moveX, 0);  this.shiftedToLeft = true; this.shiftedToRight = false; return moveX; } }
,"shiftedToLeft":
false
,"shiftedToRight":
false
,"shiftedToTop":
false
,"shiftedToBottom":
false
,"wouldCollide":
 function(entity) {var hasCollide = false;for (var i in this.TileGrids) { if (this.TileGrids[i].wouldCollide(entity) === true) { hasCollide = true; } }var all = this.allEntities(); for (var i in all) { if (all[i].NotWorldLevel !== true && all[i].NonCorporeal !== true && all[i].Disabled !== true && all[i].Name !== entity.name && all[i].wouldCollide(entity)) { hasCollide = true; } }return hasCollide;}
,"isSetup":
false
,"XResolution":640,"YResolution":400,"HasAmbientLight":false,"AmbientLightIntensity":75,"AmbientLightColor":"0xffffcf","Bounds2DX":0,"Bounds2DY":0,"TileGrids":[{"setup":
function(parent) { if (this.DelimitedGrid && this.DelimitedGrid.length > 0){ var rows = this.DelimitedGrid.split(';');for (var j in rows) { this.tiles.push([]); var cells = rows[j].split(',');  for (var i in cells) { var tile=this.getTile(parent, cells[i]); this.tiles[j].push(tile); } } } }
,"getTile":
function(parentScene, tileId) {  var eName = this.EntityNameCSVKey.split(',')[tileId]; var tile = find(parentScene.allEntities(), eName); /* tile.draw = function(x,y,w,h) { this.MyImage.active().render(x,y,w,h); }; */ return tile;  }
,"draw":
function() { if (this.SkipDraw==true) { return; } for(var j in this.tiles) { for(var i in this.tiles[j]) { if (this.tiles[j][i] != null && this.tiles[j][i].MyImage != null) { this.tiles[j][i].MyImage.active().render(this.X + (i * this.TW),this.Y + (j * this.TH),this.TW,this.TH); } } } }
,"update":
 function() {}
,"tiles":
 [] 
,"R":
 function() {return this.X + (this.getWidth() * this.TW);}
,"B":
 function() {return this.Y + (this.getHeight() * this.TH);}
,"wouldCollide":
 function(entity) {for(var j in this.tiles)      {       for (var i in this.tiles[j])       {        if (this.tiles[j][i] != null && this.tiles[j][i].ForceCollision===true)        {         var x = this.X + (i * this.TW);         var y = this.Y + (j * this.TH);         if (checkOverlap({X:x,Y:y,W:this.TW,H:this.TH}, entity) === true)         {          console.log('overlap found');         var events = this.tiles[j][i].collisionEvents;         if (events !== null)         {         }         if (this.tiles[j][i].LedgeCollision === true)         {          if (/*notideal*/downkey() && !leftkey() && !rightkey())          {           console.log('ledge collision detected');           /*arbitrary*/var speed = 4;           /* make entity.MyLogic have a non null ActionBlock? */           entity.Me.MyLogic.ActionBlock.MyActions.push({Depth:((this.TH/speed)*2)+1,SelfDestruct:true,Ct:0,Destroyed:false,update:function() { console.log('updating action');  if (this.BlockInput === true) { BlockInput(); } if (this.SelfDestruct === true && this.Ct + 1 == this.Depth) { this.Destroyed = true; } if (this.Destroyed !== true) { this.MyScript(); this.Ct++; } },MyTarget:entity,BlockInput:true,LocalData:speed,MyScript:function() { console.log('performing action...'); this.MyTarget.Me.Y += this.LocalData; }});          }         }         return true;         }        }       }      }       return false;}
,"getWidth":
function() { if (this.getHeight() > 0) { return this.tiles[0].length; } else { return 0; } }
,"getHeight":
function() { return this.tiles.length; }
,"EntityIndexCSVKey":"","EntityNameCSVKey":"tile1,tile2,tile3,tile4,tile5,tile6","DelimitedGrid":"4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4;4,4,4,4,4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4;4,4,4,4,4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4;4,4,4,4,4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4;4,4,4,4,4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4;4,4,4,4,4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4;4,4,4,4,4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4;4,4,4,4,4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4;4,4,4,4,4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4;4,4,4,4,4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4;4,4,4,4,4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4;4,4,4,4,4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4;4,4,4,4,4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4;4,4,4,4,4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4","SkipDraw":false,"MainGrid":true,"TW":32,"TH":32,"X":0,"Y":0,"Name":"","LocalData":"","TypeName":"TileGrid","Id":316}],"AdhocSceneRefs":[],"Entities":[{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2242}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2236},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2236},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'grass32');}
,"NameOfTarget":"grass32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6246}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2236},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile1","LocalData":"","TypeName":"Entity","Id":2236},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2243}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2237},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2237},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'stone32');}
,"NameOfTarget":"stone32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6247}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2237},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile2","LocalData":"","TypeName":"Entity","Id":2237},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2244}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2238},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2238},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":8,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water1');}
,"NameOfTarget":"water1","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6248},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water2');}
,"NameOfTarget":"water2","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6249},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water3');}
,"NameOfTarget":"water3","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6250},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water4');}
,"NameOfTarget":"water4","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6251},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water5');}
,"NameOfTarget":"water5","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6252},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water6');}
,"NameOfTarget":"water6","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6253},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water7');}
,"NameOfTarget":"water7","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6254},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water8');}
,"NameOfTarget":"water8","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6255},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water9');}
,"NameOfTarget":"water9","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6256},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water10');}
,"NameOfTarget":"water10","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6257},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water11');}
,"NameOfTarget":"water11","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6258},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water12');}
,"NameOfTarget":"water12","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6259},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water13');}
,"NameOfTarget":"water13","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6260},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water14');}
,"NameOfTarget":"water14","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6261},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water15');}
,"NameOfTarget":"water15","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6262}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2238},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile3","LocalData":"","TypeName":"Entity","Id":2238},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2245}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2239},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2239},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'stoneWall32');}
,"NameOfTarget":"stoneWall32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6263}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2239},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":true,"LedgeCollision":true,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile4","LocalData":"","TypeName":"Entity","Id":2239},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2246}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2240},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2240},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'dirt32');}
,"NameOfTarget":"dirt32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6264}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2240},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile5","LocalData":"","TypeName":"Entity","Id":2240},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2247}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2241},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2241},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return true;}
,"imageFilePath":"ivanGreatForest205_cc_tile60.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'ivanGreatForest205tile60');}
,"NameOfTarget":"","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6265}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2241},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":true,"LedgeCollision":true,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile6","LocalData":"","TypeName":"Entity","Id":2241}],"Threntities":[],"PointLights":[],"MyAudio":[],"MyLogic":{"update":
 function() {for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":null,"TypeName":"SceneProceduralStatement","Id":0},{"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"SceneProceduralStatement","Id":352}],"Name":"","LocalData":"","TypeName":"SceneLogicBox","Id":352},"Name":"","LocalData":"","TypeName":"Scene","Id":352},{"reloadThrentities":
function() { var allT = this.allThrentities(); for(var i in allT) { setupThrentity(allT[i]); } }
,"setup":
 function() {if (this.isSetup !== true) {for(var i in this.TileGrids) { this.TileGrids[i].setup(this); } for(var i in this.PointLights) { this.PointLights[i].setup(this); } if (this.MyAudio !== null) { for (var i = 0; i < this.MyAudio.length; i++) { this.MyAudio[i].setup(); } }if (game.active().Omnipresent2D.length > 0) { var indices = this.entityIndexArray(); var allE = this.allEntities();  for(var i in allE) { if (allE[i].MyIndex != '') { var ind = indices.indexOf(allE[i].MyIndex); if(ind != -1) { indices.splice(ind, 1); } } else { allE[i].setup(indices[i]); } }  } else { for(var i in this.Entities) { this.Entities[i].setup(i); } }if (game.active().Omnipresent3D.length > 0) { var indices = this.threntityIndexArray(); var allT = this.allThrentities(); for(var i in allT) { if (allT[i].MyIndex != '') { var ind = indices.indexOf(allT[i].MyIndex); if (ind != -1) { indices.splice(ind, 1); } } else { allT[i].setup(indices[i]); } }  } else { for(var i in this.Threntities) { this.Threntities[i].setup(i); } }if (this.HasAmbientLight == true) { addAmbientLightToCurrentScene(this.AmbientLightColor, this.AmbientLightIntensity / parseFloat(100)); }this.isSetup = true; }}
,"update":
 function() {this.MyLogic.update();for(var i in this.MyAudio) { this.MyAudio[i].update(); } var allE = this.allEntities(); for(var i in allE) { allE[i].update(); }var allT = this.allThrentities(); for(var i in allT) { allT[i].update(); }for(var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].update(this.AdhocSceneRefs[i].TargetName); } for(var i in this.TileGrids) { this.TileGrids[i].update(); } }
,"draw":
 function() {for(var i in this.TileGrids) { this.TileGrids[i].draw(); } var allE = this.allEntities(); for(var i in allE) { if (allE[i].Disabled !== true) { allE[i].draw(); } }var allT = this.allThrentities(); for(var i in allT) { allT[i].draw(); } }
,"entityIndexArray":
function() { var ray = []; for(var x in game.active().Omnipresent2D) { ray.push(game.active().Omnipresent2D[x].MyIndex); } var rayLen = ray.length; for(i=0;i<rayLen+this.Entities.length;i++) { if (ray.includes((i).toString())) {  } else {  ray.push(i); } } return ray; }
,"threntityIndexArray":
function() { var ray = []; for(var x in game.active().Omnipresent3D) { ray.push(game.active().Omnipresent3D[x].MyIndex); } var rayLen = ray.length; for(i=0;i<rayLen+this.Threntities.length;i++) { if (ray.includes((i).toString())) {  } else {  ray.push(i); } } return ray; }
,"checkMovePoint3d":
function(point3dBefore, point3dAfter) {  var all = this.allThrentities(); for(var i in all) { if (this.checkPointCollision(all[i], point3dBefore, point3dAfter)==true) { return false; } } return true;  }
,"checkPointCollision":
function(targetThrent, point3dBefore, point3dAfter) { var xBef = point3dBefore.X;var xAft = point3dAfter.X;var yBef = point3dBefore.Y;var yAft = point3dAfter.Y;var zBef = point3dBefore.Z;var zAft = point3dAfter.Z;var minX = targetThrent.L();var maxX = targetThrent.R();var minY = targetThrent.B();var maxY = targetThrent.T();var minZ = targetThrent.A();var maxZ = targetThrent.F();var xOverlap = false; var yOverlap = false; var zOverlap = false;if (xBef<xAft) { xOverlap = this.checkRangeOverlap(xBef, xAft, minX, maxX); } else { xOverlap = this.checkRangeOverlap(xAft, xBef, minX, maxX); }if (yBef<yAft) { yOverlap = this.checkRangeOverlap(yBef, yAft, minY, maxY); } else { yOverlap = this.checkRangeOverlap(yAft, yBef, minY, maxY); }if (zBef<zAft) { zOverlap = this.checkRangeOverlap(zBef, zAft, minZ, maxZ); } else { zOverlap = this.checkRangeOverlap(zAft, zBef, minZ, maxZ); }if (xOverlap==true && yOverlap==true && zOverlap==true) { return true; } return false;}
,"checkRangeOverlap":
function (inputOneMin, inputOneMax, inputTwoMin, inputTwoMax) {if (inputOneMin > inputTwoMax || inputOneMax < inputTwoMin) { return false; }return true;}
,"threnCollideContextual":
function(thren, before, after) { var hasCollide = false;var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name) { if (this.ZStraddle(before, after, all[i])===true && this.XStraddle(before, after, all[i])===true && this.YStraddle(before, after, all[i])===true) { hasCollide = true; } if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { hasCollide = true; } } }return hasCollide;}
,"ZStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.Z - before.Z;let secondDiff = target.Z - after.Z;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"XStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.X - before.X;let secondDiff = target.X - after.Y;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"YStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.Y - before.Y;let secondDiff = target.Y - after.Y;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"getFirstThrenCollide":
function(thren) { var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { return thren; } } }
,"threnCollide":
 function(thren) {var hasCollide = false;var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { hasCollide = true; } }return hasCollide;}
,"moveAll2D":
function(x, y) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } for (var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].X += x; this.AdhocSceneRefs[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } }
,"moveAll2DAround":
function(x, y, entName) { var ent = find(game.scene().Entities, entName); if (this.wouldCollide(ent.transpose(-x, -y)) === false) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } } }
,"quickMoveAll2DAround":
function(x, y, ent) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } for(var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].X += x; this.AdhocSceneRefs[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } }
,"tryMoveAll2DAround":
function(x, y, entName) {if (this.getMainTilegrid() === -1) { return this.moveAll2DAround(x, y, entName); } else { this.dynamic2DMove(x, y, entName, this.getMainTilegrid()); } }
,"dynamic2DMove":
function(x, y, entName, tileGrid) {var ent = game.findEntity(entName);if (this.wouldCollide(ent.transpose(-x, -y)) === false) {this.dynamic2DMoveX(x, ent, tileGrid);this.dynamic2DMoveY(y, ent, tileGrid); }}
,"dynamic2DMoveUp":
function(y, ent, tileGrid) {var amtMoveHeroTowardsCenter = (ent.pastCenterY() === false && ent.isCenteredY() === false) ? 0 : (ent.myCenterY() - viewportCenterY());if (amtMoveHeroTowardsCenter >= y) { ent.Y -= y; return; } else { ent.Y -= amtMoveHeroTowardsCenter; }var remainder = y - amtMoveHeroTowardsCenter;var tileGridSlack = 0 - tileGrid.Y;if (remainder <= Math.abs(tileGridSlack)) { this.quickMoveAll2DAround(0, remainder, ent); return; } else { this.quickMoveAll2DAround(0, Math.abs(tileGridSlack), ent); }remainder = remainder - Math.abs(tileGridSlack);ent.Y -= remainder;}
,"dynamic2DMoveDown":
function(y, ent, tileGrid) {var absY = Math.abs(y);var amtMoveHeroTowardsCenter = (ent.isCenteredY() || ent.pastCenterY()) ? 0 : viewportCenterY() - ent.myCenterY();if (amtMoveHeroTowardsCenter >= absY) { ent.Y -= y; return; } else { ent.Y += amtMoveHeroTowardsCenter; }var remainder = absY - amtMoveHeroTowardsCenter;var tileGridSlack = tileGrid.B() - getYDrawBounds2D();if (remainder <= tileGridSlack) { this.quickMoveAll2DAround(0, -remainder, ent); return; } else { this.quickMoveAll2DAround(0, tileGridSlack, ent); }remainder = remainder - tileGridSlack;ent.Y += remainder;}
,"dynamic2DMoveLeft":
function(x, ent, tileGrid) {var amtMoveHeroTowardsCenter = (ent.pastCenterX() === false && ent.isCenteredX() === false) ? 0 : (ent.myCenterX() - viewportCenterX());if (amtMoveHeroTowardsCenter >= x) { ent.X -= x; return; } else { ent.X -= amtMoveHeroTowardsCenter; }var remainder = x - amtMoveHeroTowardsCenter;var tileGridSlack = 0 - tileGrid.X;if (remainder <= Math.abs(tileGridSlack)) { this.quickMoveAll2DAround(remainder, 0, ent); return; } else { this.quickMoveAll2DAround(Math.abs(tileGridSlack), 0, ent); }remainder = remainder - Math.abs(tileGridSlack);ent.X -= remainder;}
,"dynamic2DMoveRight":
function(x, ent, tileGrid) {var absX = Math.abs(x);var amtMoveHeroTowardsCenter = (ent.isCenteredX() || ent.pastCenterX()) ? 0 : viewportCenterX() - ent.myCenterX();if (amtMoveHeroTowardsCenter >= absX) { ent.X -= x; return; } else { ent.X += amtMoveHeroTowardsCenter; }var remainder = absX - amtMoveHeroTowardsCenter;var tileGridSlack = tileGrid.R() - getXDrawBounds2D();if (remainder <= tileGridSlack) { this.quickMoveAll2DAround(-remainder, 0, ent); return; } else { this.quickMoveAll2DAround(tileGridSlack, 0, ent); }remainder = remainder - tileGridSlack;ent.X += remainder;}
,"dynamic2DMoveX":
function(x, ent, tileGrid) { var movingLeft = x > 0;if (movingLeft) { this.dynamic2DMoveLeft(x, ent, tileGrid); return; } else { this.dynamic2DMoveRight(x, ent, tileGrid); return; }var tileGridSlackX = x < 0 ? -1 * tileGrid.X : tileGrid.R() - getXDrawBounds2D(); if (ent.isCenteredX() !== true) { var centerSlackX = (x < 0 ? ((getXDrawBounds2D() / 2) - ent.X) : ent.X - (getXDrawBounds2D() / 2)); if (centerSlackX > Math.abs(x)) { ent.X -= x; }else if (centerSlackX < Math.abs(x) && centerSlackX > 0) { ent.X -= centerSlackX; }  }else if (tileGridSlackX > Math.abs(x)) { this.moveAll2DAround(x, 0, ent.Name); }else if (tileGridSlackX < Math.abs(x) && tileGridSlackX > 0) { this.moveAll2DAround(tileGridSlackX, 0, ent.Name); }}
,"dynamic2DMoveY":
function(y, ent, tileGrid) { var movingUp = y > 0;if (movingUp) { this.dynamic2DMoveUp(y, ent, tileGrid); return; } else { this.dynamic2DMoveDown(y, ent, tileGrid); return; }var tileGridSlackY = y < 0 ? -1 * tileGrid.Y : tileGrid.B() - getYDrawBounds2D();if (ent.isCenteredY() !== true) { var centerSlackY = (y < 0 ? ((getYDrawBounds2D() / 2) - ent.Y) : ent.Y - (getYDrawBounds2D() / 2)); if (centerSlackY > Math.abs(y)) { ent.Y -= y; }else if (centerSlackY < Math.abs(y) && centerSlackY > 0) { ent.Y -= centerSlackY; }  }else if (tileGridSlackY > Math.abs(y)) { this.moveAll2DAround(y, 0, ent.Name); }else if (tileGridSlackY < Math.abs(y) && tileGridSlackY > 0) { this.moveAll2DAround(tileGridSlackY, 0, ent.Name); }}
,"prepareForRenderer":
 function() {return {  };}
,"loadScene":
function() { loadThrentitiesIntoNewScene(this.allThrentities(), this.PointLights); }
,"allThrentities":
function() { return game.active().Omnipresent3D.concat(this.validLocalThrentities()); }
,"validLocalThrentities":
function() { return this.Threntities.filter(function(obj) { return Object.keys(obj).length > 0; }); }
,"getThrentity":
function (index) { var ent = game.active().getOmni3D(index); if (ent != null) { return ent; } var obj = this.Threntities[index]; if (obj == null || Object.keys(obj).length == 0) { return game.active().getOmni3D(index); } else { return this.Threntities[index]; } }
,"allEntities":
function() { return game.active().Omnipresent2D.concat(this.validLocalEntities()); }
,"validLocalEntities":
function() { return this.Entities.filter(function(obj) { return Object.keys(obj).length > 0; }); }
,"getEntity":
function (index) { var ent = game.active().getOmni2D(index); if (ent != null) { return ent; } var obj = this.Entities[index]; if (obj == null || Object.keys(obj).length == 0) { return game.active().getOmni2D(index); } else { return this.Entities[index]; } }
,"getMainTilegrid":
function() { for(var i in this.TileGrids) { if (this.TileGrids[i].MainGrid === true) { return this.TileGrids[i]; } } return -1; }
,"shiftToTop":
function() {  var main = this.getMainTilegrid(); if (main !== -1) { var moveY = main.Y; this.moveAll2D(0, moveY); return moveY; } }
,"shiftToBottom":
function() {  var main = this.getMainTilegrid(); if (main !== -1) { var moveY = -(main.B() - getYDrawBounds2D()); this.moveAll2D(0, moveY); return moveY; } }
,"shiftToRight":
function() { if (this.shiftedToRight == true) {  }  var main = this.getMainTilegrid(); if (main !== -1) {  var moveX = -(main.R() - getXDrawBounds2D()); this.moveAll2D(moveX, 0); this.shiftedToLeft = false; this.shiftedToRight = true; return moveX; } }
,"shiftToLeft":
function() { if (this.shiftedToLeft == true) {  } var main = this.getMainTilegrid(); if (main !== -1) {  var moveX = main.X; this.moveAll2D(moveX, 0);  this.shiftedToLeft = true; this.shiftedToRight = false; return moveX; } }
,"shiftedToLeft":
false
,"shiftedToRight":
false
,"shiftedToTop":
false
,"shiftedToBottom":
false
,"wouldCollide":
 function(entity) {var hasCollide = false;for (var i in this.TileGrids) { if (this.TileGrids[i].wouldCollide(entity) === true) { hasCollide = true; } }var all = this.allEntities(); for (var i in all) { if (all[i].NotWorldLevel !== true && all[i].NonCorporeal !== true && all[i].Disabled !== true && all[i].Name !== entity.name && all[i].wouldCollide(entity)) { hasCollide = true; } }return hasCollide;}
,"isSetup":
false
,"XResolution":640,"YResolution":400,"HasAmbientLight":false,"AmbientLightIntensity":75,"AmbientLightColor":"0xffffcf","Bounds2DX":0,"Bounds2DY":0,"TileGrids":[{"setup":
function(parent) { if (this.DelimitedGrid && this.DelimitedGrid.length > 0){ var rows = this.DelimitedGrid.split(';');for (var j in rows) { this.tiles.push([]); var cells = rows[j].split(',');  for (var i in cells) { var tile=this.getTile(parent, cells[i]); this.tiles[j].push(tile); } } } }
,"getTile":
function(parentScene, tileId) {  var eName = this.EntityNameCSVKey.split(',')[tileId]; var tile = find(parentScene.allEntities(), eName); /* tile.draw = function(x,y,w,h) { this.MyImage.active().render(x,y,w,h); }; */ return tile;  }
,"draw":
function() { if (this.SkipDraw==true) { return; } for(var j in this.tiles) { for(var i in this.tiles[j]) { if (this.tiles[j][i] != null && this.tiles[j][i].MyImage != null) { this.tiles[j][i].MyImage.active().render(this.X + (i * this.TW),this.Y + (j * this.TH),this.TW,this.TH); } } } }
,"update":
 function() {}
,"tiles":
 [] 
,"R":
 function() {return this.X + (this.getWidth() * this.TW);}
,"B":
 function() {return this.Y + (this.getHeight() * this.TH);}
,"wouldCollide":
 function(entity) {for(var j in this.tiles)      {       for (var i in this.tiles[j])       {        if (this.tiles[j][i] != null && this.tiles[j][i].ForceCollision===true)        {         var x = this.X + (i * this.TW);         var y = this.Y + (j * this.TH);         if (checkOverlap({X:x,Y:y,W:this.TW,H:this.TH}, entity) === true)         {          console.log('overlap found');         var events = this.tiles[j][i].collisionEvents;         if (events !== null)         {         }         if (this.tiles[j][i].LedgeCollision === true)         {          if (/*notideal*/downkey() && !leftkey() && !rightkey())          {           console.log('ledge collision detected');           /*arbitrary*/var speed = 4;           /* make entity.MyLogic have a non null ActionBlock? */           entity.Me.MyLogic.ActionBlock.MyActions.push({Depth:((this.TH/speed)*2)+1,SelfDestruct:true,Ct:0,Destroyed:false,update:function() { console.log('updating action');  if (this.BlockInput === true) { BlockInput(); } if (this.SelfDestruct === true && this.Ct + 1 == this.Depth) { this.Destroyed = true; } if (this.Destroyed !== true) { this.MyScript(); this.Ct++; } },MyTarget:entity,BlockInput:true,LocalData:speed,MyScript:function() { console.log('performing action...'); this.MyTarget.Me.Y += this.LocalData; }});          }         }         return true;         }        }       }      }       return false;}
,"getWidth":
function() { if (this.getHeight() > 0) { return this.tiles[0].length; } else { return 0; } }
,"getHeight":
function() { return this.tiles.length; }
,"EntityIndexCSVKey":"","EntityNameCSVKey":"tile1,tile2,tile3,tile4,tile5,tile6","DelimitedGrid":"4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,1,1,1,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,1,1,1,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,1,1,1,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,1,1,1,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,1,1,1,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,1,1,1,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,1,1,1,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,1,1,1,1,1,1,1,1,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4","SkipDraw":false,"MainGrid":true,"TW":32,"TH":32,"X":0,"Y":0,"Name":"","LocalData":"","TypeName":"TileGrid","Id":317}],"AdhocSceneRefs":[{"TargetName":"hero","update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":320,"Y":160,"W":32,"H":32,"TargetX":0,"TargetY":0,"SkipXMove":true,"SkipYMove":true,"TargetScene":3,"LocalScene":18,"Name":"","LocalData":"","TypeName":"AdhocSceneRef","Id":28}],"Entities":[{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2248}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2242},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2242},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'grass32');}
,"NameOfTarget":"grass32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6266}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2242},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile1","LocalData":"","TypeName":"Entity","Id":2242},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2249}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2243},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2243},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'stone32');}
,"NameOfTarget":"stone32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6267}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2243},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile2","LocalData":"","TypeName":"Entity","Id":2243},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2250}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2244},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2244},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":8,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water1');}
,"NameOfTarget":"water1","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6268},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water2');}
,"NameOfTarget":"water2","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6269},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water3');}
,"NameOfTarget":"water3","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6270},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water4');}
,"NameOfTarget":"water4","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6271},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water5');}
,"NameOfTarget":"water5","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6272},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water6');}
,"NameOfTarget":"water6","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6273},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water7');}
,"NameOfTarget":"water7","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6274},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water8');}
,"NameOfTarget":"water8","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6275},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water9');}
,"NameOfTarget":"water9","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6276},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water10');}
,"NameOfTarget":"water10","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6277},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water11');}
,"NameOfTarget":"water11","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6278},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water12');}
,"NameOfTarget":"water12","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6279},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water13');}
,"NameOfTarget":"water13","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6280},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water14');}
,"NameOfTarget":"water14","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6281},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water15');}
,"NameOfTarget":"water15","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6282}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2244},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile3","LocalData":"","TypeName":"Entity","Id":2244},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2251}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2245},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2245},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'stoneWall32');}
,"NameOfTarget":"stoneWall32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6283}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2245},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":true,"LedgeCollision":true,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile4","LocalData":"","TypeName":"Entity","Id":2245},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2252}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2246},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2246},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'dirt32');}
,"NameOfTarget":"dirt32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6284}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2246},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile5","LocalData":"","TypeName":"Entity","Id":2246},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2253}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2247},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2247},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return true;}
,"imageFilePath":"ivanGreatForest205_cc_tile60.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'ivanGreatForest205tile60');}
,"NameOfTarget":"","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6285}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2247},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":true,"LedgeCollision":true,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile6","LocalData":"","TypeName":"Entity","Id":2247},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2254}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2248},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2248},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return true;}
,"imageFilePath":"C:\\IISProj\\PlaceholderWebApp 10 Oct 2017 II\\PlaceholderWebApp\\PlaceholderWebApp\\Pages/TempImages/ivanGreatForest205_cc_testStairs0.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'ivanGreatForest205testStairs0');}
,"NameOfTarget":"","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6286}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2248},"MyColor":"","X":320,"Y":160,"W":32,"H":32,"MX":0,"MY":0,"Disabled":false,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":true,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"testStairs","LocalData":"","TypeName":"Entity","Id":2248}],"Threntities":[],"PointLights":[],"MyAudio":[],"MyLogic":{"update":
 function() {for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":null,"TypeName":"SceneProceduralStatement","Id":0},{"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"SceneProceduralStatement","Id":353}],"Name":"","LocalData":"","TypeName":"SceneLogicBox","Id":353},"Name":"","LocalData":"","TypeName":"Scene","Id":353},{"reloadThrentities":
function() { var allT = this.allThrentities(); for(var i in allT) { setupThrentity(allT[i]); } }
,"setup":
 function() {if (this.isSetup !== true) {for(var i in this.TileGrids) { this.TileGrids[i].setup(this); } for(var i in this.PointLights) { this.PointLights[i].setup(this); } if (this.MyAudio !== null) { for (var i = 0; i < this.MyAudio.length; i++) { this.MyAudio[i].setup(); } }if (game.active().Omnipresent2D.length > 0) { var indices = this.entityIndexArray(); var allE = this.allEntities();  for(var i in allE) { if (allE[i].MyIndex != '') { var ind = indices.indexOf(allE[i].MyIndex); if(ind != -1) { indices.splice(ind, 1); } } else { allE[i].setup(indices[i]); } }  } else { for(var i in this.Entities) { this.Entities[i].setup(i); } }if (game.active().Omnipresent3D.length > 0) { var indices = this.threntityIndexArray(); var allT = this.allThrentities(); for(var i in allT) { if (allT[i].MyIndex != '') { var ind = indices.indexOf(allT[i].MyIndex); if (ind != -1) { indices.splice(ind, 1); } } else { allT[i].setup(indices[i]); } }  } else { for(var i in this.Threntities) { this.Threntities[i].setup(i); } }if (this.HasAmbientLight == true) { addAmbientLightToCurrentScene(this.AmbientLightColor, this.AmbientLightIntensity / parseFloat(100)); }this.isSetup = true; }}
,"update":
 function() {this.MyLogic.update();for(var i in this.MyAudio) { this.MyAudio[i].update(); } var allE = this.allEntities(); for(var i in allE) { allE[i].update(); }var allT = this.allThrentities(); for(var i in allT) { allT[i].update(); }for(var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].update(this.AdhocSceneRefs[i].TargetName); } for(var i in this.TileGrids) { this.TileGrids[i].update(); } }
,"draw":
 function() {for(var i in this.TileGrids) { this.TileGrids[i].draw(); } var allE = this.allEntities(); for(var i in allE) { if (allE[i].Disabled !== true) { allE[i].draw(); } }var allT = this.allThrentities(); for(var i in allT) { allT[i].draw(); } }
,"entityIndexArray":
function() { var ray = []; for(var x in game.active().Omnipresent2D) { ray.push(game.active().Omnipresent2D[x].MyIndex); } var rayLen = ray.length; for(i=0;i<rayLen+this.Entities.length;i++) { if (ray.includes((i).toString())) {  } else {  ray.push(i); } } return ray; }
,"threntityIndexArray":
function() { var ray = []; for(var x in game.active().Omnipresent3D) { ray.push(game.active().Omnipresent3D[x].MyIndex); } var rayLen = ray.length; for(i=0;i<rayLen+this.Threntities.length;i++) { if (ray.includes((i).toString())) {  } else {  ray.push(i); } } return ray; }
,"checkMovePoint3d":
function(point3dBefore, point3dAfter) {  var all = this.allThrentities(); for(var i in all) { if (this.checkPointCollision(all[i], point3dBefore, point3dAfter)==true) { return false; } } return true;  }
,"checkPointCollision":
function(targetThrent, point3dBefore, point3dAfter) { var xBef = point3dBefore.X;var xAft = point3dAfter.X;var yBef = point3dBefore.Y;var yAft = point3dAfter.Y;var zBef = point3dBefore.Z;var zAft = point3dAfter.Z;var minX = targetThrent.L();var maxX = targetThrent.R();var minY = targetThrent.B();var maxY = targetThrent.T();var minZ = targetThrent.A();var maxZ = targetThrent.F();var xOverlap = false; var yOverlap = false; var zOverlap = false;if (xBef<xAft) { xOverlap = this.checkRangeOverlap(xBef, xAft, minX, maxX); } else { xOverlap = this.checkRangeOverlap(xAft, xBef, minX, maxX); }if (yBef<yAft) { yOverlap = this.checkRangeOverlap(yBef, yAft, minY, maxY); } else { yOverlap = this.checkRangeOverlap(yAft, yBef, minY, maxY); }if (zBef<zAft) { zOverlap = this.checkRangeOverlap(zBef, zAft, minZ, maxZ); } else { zOverlap = this.checkRangeOverlap(zAft, zBef, minZ, maxZ); }if (xOverlap==true && yOverlap==true && zOverlap==true) { return true; } return false;}
,"checkRangeOverlap":
function (inputOneMin, inputOneMax, inputTwoMin, inputTwoMax) {if (inputOneMin > inputTwoMax || inputOneMax < inputTwoMin) { return false; }return true;}
,"threnCollideContextual":
function(thren, before, after) { var hasCollide = false;var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name) { if (this.ZStraddle(before, after, all[i])===true && this.XStraddle(before, after, all[i])===true && this.YStraddle(before, after, all[i])===true) { hasCollide = true; } if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { hasCollide = true; } } }return hasCollide;}
,"ZStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.Z - before.Z;let secondDiff = target.Z - after.Z;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"XStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.X - before.X;let secondDiff = target.X - after.Y;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"YStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.Y - before.Y;let secondDiff = target.Y - after.Y;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"getFirstThrenCollide":
function(thren) { var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { return thren; } } }
,"threnCollide":
 function(thren) {var hasCollide = false;var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { hasCollide = true; } }return hasCollide;}
,"moveAll2D":
function(x, y) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } for (var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].X += x; this.AdhocSceneRefs[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } }
,"moveAll2DAround":
function(x, y, entName) { var ent = find(game.scene().Entities, entName); if (this.wouldCollide(ent.transpose(-x, -y)) === false) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } } }
,"quickMoveAll2DAround":
function(x, y, ent) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } for(var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].X += x; this.AdhocSceneRefs[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } }
,"tryMoveAll2DAround":
function(x, y, entName) {if (this.getMainTilegrid() === -1) { return this.moveAll2DAround(x, y, entName); } else { this.dynamic2DMove(x, y, entName, this.getMainTilegrid()); } }
,"dynamic2DMove":
function(x, y, entName, tileGrid) {var ent = game.findEntity(entName);if (this.wouldCollide(ent.transpose(-x, -y)) === false) {this.dynamic2DMoveX(x, ent, tileGrid);this.dynamic2DMoveY(y, ent, tileGrid); }}
,"dynamic2DMoveUp":
function(y, ent, tileGrid) {var amtMoveHeroTowardsCenter = (ent.pastCenterY() === false && ent.isCenteredY() === false) ? 0 : (ent.myCenterY() - viewportCenterY());if (amtMoveHeroTowardsCenter >= y) { ent.Y -= y; return; } else { ent.Y -= amtMoveHeroTowardsCenter; }var remainder = y - amtMoveHeroTowardsCenter;var tileGridSlack = 0 - tileGrid.Y;if (remainder <= Math.abs(tileGridSlack)) { this.quickMoveAll2DAround(0, remainder, ent); return; } else { this.quickMoveAll2DAround(0, Math.abs(tileGridSlack), ent); }remainder = remainder - Math.abs(tileGridSlack);ent.Y -= remainder;}
,"dynamic2DMoveDown":
function(y, ent, tileGrid) {var absY = Math.abs(y);var amtMoveHeroTowardsCenter = (ent.isCenteredY() || ent.pastCenterY()) ? 0 : viewportCenterY() - ent.myCenterY();if (amtMoveHeroTowardsCenter >= absY) { ent.Y -= y; return; } else { ent.Y += amtMoveHeroTowardsCenter; }var remainder = absY - amtMoveHeroTowardsCenter;var tileGridSlack = tileGrid.B() - getYDrawBounds2D();if (remainder <= tileGridSlack) { this.quickMoveAll2DAround(0, -remainder, ent); return; } else { this.quickMoveAll2DAround(0, tileGridSlack, ent); }remainder = remainder - tileGridSlack;ent.Y += remainder;}
,"dynamic2DMoveLeft":
function(x, ent, tileGrid) {var amtMoveHeroTowardsCenter = (ent.pastCenterX() === false && ent.isCenteredX() === false) ? 0 : (ent.myCenterX() - viewportCenterX());if (amtMoveHeroTowardsCenter >= x) { ent.X -= x; return; } else { ent.X -= amtMoveHeroTowardsCenter; }var remainder = x - amtMoveHeroTowardsCenter;var tileGridSlack = 0 - tileGrid.X;if (remainder <= Math.abs(tileGridSlack)) { this.quickMoveAll2DAround(remainder, 0, ent); return; } else { this.quickMoveAll2DAround(Math.abs(tileGridSlack), 0, ent); }remainder = remainder - Math.abs(tileGridSlack);ent.X -= remainder;}
,"dynamic2DMoveRight":
function(x, ent, tileGrid) {var absX = Math.abs(x);var amtMoveHeroTowardsCenter = (ent.isCenteredX() || ent.pastCenterX()) ? 0 : viewportCenterX() - ent.myCenterX();if (amtMoveHeroTowardsCenter >= absX) { ent.X -= x; return; } else { ent.X += amtMoveHeroTowardsCenter; }var remainder = absX - amtMoveHeroTowardsCenter;var tileGridSlack = tileGrid.R() - getXDrawBounds2D();if (remainder <= tileGridSlack) { this.quickMoveAll2DAround(-remainder, 0, ent); return; } else { this.quickMoveAll2DAround(tileGridSlack, 0, ent); }remainder = remainder - tileGridSlack;ent.X += remainder;}
,"dynamic2DMoveX":
function(x, ent, tileGrid) { var movingLeft = x > 0;if (movingLeft) { this.dynamic2DMoveLeft(x, ent, tileGrid); return; } else { this.dynamic2DMoveRight(x, ent, tileGrid); return; }var tileGridSlackX = x < 0 ? -1 * tileGrid.X : tileGrid.R() - getXDrawBounds2D(); if (ent.isCenteredX() !== true) { var centerSlackX = (x < 0 ? ((getXDrawBounds2D() / 2) - ent.X) : ent.X - (getXDrawBounds2D() / 2)); if (centerSlackX > Math.abs(x)) { ent.X -= x; }else if (centerSlackX < Math.abs(x) && centerSlackX > 0) { ent.X -= centerSlackX; }  }else if (tileGridSlackX > Math.abs(x)) { this.moveAll2DAround(x, 0, ent.Name); }else if (tileGridSlackX < Math.abs(x) && tileGridSlackX > 0) { this.moveAll2DAround(tileGridSlackX, 0, ent.Name); }}
,"dynamic2DMoveY":
function(y, ent, tileGrid) { var movingUp = y > 0;if (movingUp) { this.dynamic2DMoveUp(y, ent, tileGrid); return; } else { this.dynamic2DMoveDown(y, ent, tileGrid); return; }var tileGridSlackY = y < 0 ? -1 * tileGrid.Y : tileGrid.B() - getYDrawBounds2D();if (ent.isCenteredY() !== true) { var centerSlackY = (y < 0 ? ((getYDrawBounds2D() / 2) - ent.Y) : ent.Y - (getYDrawBounds2D() / 2)); if (centerSlackY > Math.abs(y)) { ent.Y -= y; }else if (centerSlackY < Math.abs(y) && centerSlackY > 0) { ent.Y -= centerSlackY; }  }else if (tileGridSlackY > Math.abs(y)) { this.moveAll2DAround(y, 0, ent.Name); }else if (tileGridSlackY < Math.abs(y) && tileGridSlackY > 0) { this.moveAll2DAround(tileGridSlackY, 0, ent.Name); }}
,"prepareForRenderer":
 function() {return {  };}
,"loadScene":
function() { loadThrentitiesIntoNewScene(this.allThrentities(), this.PointLights); }
,"allThrentities":
function() { return game.active().Omnipresent3D.concat(this.validLocalThrentities()); }
,"validLocalThrentities":
function() { return this.Threntities.filter(function(obj) { return Object.keys(obj).length > 0; }); }
,"getThrentity":
function (index) { var ent = game.active().getOmni3D(index); if (ent != null) { return ent; } var obj = this.Threntities[index]; if (obj == null || Object.keys(obj).length == 0) { return game.active().getOmni3D(index); } else { return this.Threntities[index]; } }
,"allEntities":
function() { return game.active().Omnipresent2D.concat(this.validLocalEntities()); }
,"validLocalEntities":
function() { return this.Entities.filter(function(obj) { return Object.keys(obj).length > 0; }); }
,"getEntity":
function (index) { var ent = game.active().getOmni2D(index); if (ent != null) { return ent; } var obj = this.Entities[index]; if (obj == null || Object.keys(obj).length == 0) { return game.active().getOmni2D(index); } else { return this.Entities[index]; } }
,"getMainTilegrid":
function() { for(var i in this.TileGrids) { if (this.TileGrids[i].MainGrid === true) { return this.TileGrids[i]; } } return -1; }
,"shiftToTop":
function() {  var main = this.getMainTilegrid(); if (main !== -1) { var moveY = main.Y; this.moveAll2D(0, moveY); return moveY; } }
,"shiftToBottom":
function() {  var main = this.getMainTilegrid(); if (main !== -1) { var moveY = -(main.B() - getYDrawBounds2D()); this.moveAll2D(0, moveY); return moveY; } }
,"shiftToRight":
function() { if (this.shiftedToRight == true) {  }  var main = this.getMainTilegrid(); if (main !== -1) {  var moveX = -(main.R() - getXDrawBounds2D()); this.moveAll2D(moveX, 0); this.shiftedToLeft = false; this.shiftedToRight = true; return moveX; } }
,"shiftToLeft":
function() { if (this.shiftedToLeft == true) {  } var main = this.getMainTilegrid(); if (main !== -1) {  var moveX = main.X; this.moveAll2D(moveX, 0);  this.shiftedToLeft = true; this.shiftedToRight = false; return moveX; } }
,"shiftedToLeft":
false
,"shiftedToRight":
false
,"shiftedToTop":
false
,"shiftedToBottom":
false
,"wouldCollide":
 function(entity) {var hasCollide = false;for (var i in this.TileGrids) { if (this.TileGrids[i].wouldCollide(entity) === true) { hasCollide = true; } }var all = this.allEntities(); for (var i in all) { if (all[i].NotWorldLevel !== true && all[i].NonCorporeal !== true && all[i].Disabled !== true && all[i].Name !== entity.name && all[i].wouldCollide(entity)) { hasCollide = true; } }return hasCollide;}
,"isSetup":
false
,"XResolution":640,"YResolution":400,"HasAmbientLight":false,"AmbientLightIntensity":75,"AmbientLightColor":"0xffffcf","Bounds2DX":0,"Bounds2DY":0,"TileGrids":[{"setup":
function(parent) { if (this.DelimitedGrid && this.DelimitedGrid.length > 0){ var rows = this.DelimitedGrid.split(';');for (var j in rows) { this.tiles.push([]); var cells = rows[j].split(',');  for (var i in cells) { var tile=this.getTile(parent, cells[i]); this.tiles[j].push(tile); } } } }
,"getTile":
function(parentScene, tileId) {  var eName = this.EntityNameCSVKey.split(',')[tileId]; var tile = find(parentScene.allEntities(), eName); /* tile.draw = function(x,y,w,h) { this.MyImage.active().render(x,y,w,h); }; */ return tile;  }
,"draw":
function() { if (this.SkipDraw==true) { return; } for(var j in this.tiles) { for(var i in this.tiles[j]) { if (this.tiles[j][i] != null && this.tiles[j][i].MyImage != null) { this.tiles[j][i].MyImage.active().render(this.X + (i * this.TW),this.Y + (j * this.TH),this.TW,this.TH); } } } }
,"update":
 function() {}
,"tiles":
 [] 
,"R":
 function() {return this.X + (this.getWidth() * this.TW);}
,"B":
 function() {return this.Y + (this.getHeight() * this.TH);}
,"wouldCollide":
 function(entity) {for(var j in this.tiles)      {       for (var i in this.tiles[j])       {        if (this.tiles[j][i] != null && this.tiles[j][i].ForceCollision===true)        {         var x = this.X + (i * this.TW);         var y = this.Y + (j * this.TH);         if (checkOverlap({X:x,Y:y,W:this.TW,H:this.TH}, entity) === true)         {          console.log('overlap found');         var events = this.tiles[j][i].collisionEvents;         if (events !== null)         {         }         if (this.tiles[j][i].LedgeCollision === true)         {          if (/*notideal*/downkey() && !leftkey() && !rightkey())          {           console.log('ledge collision detected');           /*arbitrary*/var speed = 4;           /* make entity.MyLogic have a non null ActionBlock? */           entity.Me.MyLogic.ActionBlock.MyActions.push({Depth:((this.TH/speed)*2)+1,SelfDestruct:true,Ct:0,Destroyed:false,update:function() { console.log('updating action');  if (this.BlockInput === true) { BlockInput(); } if (this.SelfDestruct === true && this.Ct + 1 == this.Depth) { this.Destroyed = true; } if (this.Destroyed !== true) { this.MyScript(); this.Ct++; } },MyTarget:entity,BlockInput:true,LocalData:speed,MyScript:function() { console.log('performing action...'); this.MyTarget.Me.Y += this.LocalData; }});          }         }         return true;         }        }       }      }       return false;}
,"getWidth":
function() { if (this.getHeight() > 0) { return this.tiles[0].length; } else { return 0; } }
,"getHeight":
function() { return this.tiles.length; }
,"EntityIndexCSVKey":"","EntityNameCSVKey":"tile1,tile2,tile3,tile4,tile5","DelimitedGrid":"4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4","SkipDraw":false,"MainGrid":true,"TW":32,"TH":32,"X":0,"Y":0,"Name":"","LocalData":"","TypeName":"TileGrid","Id":318}],"AdhocSceneRefs":[],"Entities":[{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2255}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2249},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2249},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'grass32');}
,"NameOfTarget":"grass32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6287}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2249},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile1","LocalData":"","TypeName":"Entity","Id":2249},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2256}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2250},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2250},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'stone32');}
,"NameOfTarget":"stone32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6288}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2250},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile2","LocalData":"","TypeName":"Entity","Id":2250},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2257}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2251},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2251},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":8,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water1');}
,"NameOfTarget":"water1","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6289},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water2');}
,"NameOfTarget":"water2","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6290},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water3');}
,"NameOfTarget":"water3","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6291},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water4');}
,"NameOfTarget":"water4","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6292},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water5');}
,"NameOfTarget":"water5","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6293},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water6');}
,"NameOfTarget":"water6","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6294},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water7');}
,"NameOfTarget":"water7","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6295},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water8');}
,"NameOfTarget":"water8","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6296},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water9');}
,"NameOfTarget":"water9","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6297},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water10');}
,"NameOfTarget":"water10","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6298},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water11');}
,"NameOfTarget":"water11","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6299},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water12');}
,"NameOfTarget":"water12","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6300},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water13');}
,"NameOfTarget":"water13","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6301},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water14');}
,"NameOfTarget":"water14","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6302},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water15');}
,"NameOfTarget":"water15","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6303}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2251},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile3","LocalData":"","TypeName":"Entity","Id":2251},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2258}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2252},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2252},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'stoneWall32');}
,"NameOfTarget":"stoneWall32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6304}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2252},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":true,"LedgeCollision":true,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile4","LocalData":"","TypeName":"Entity","Id":2252},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2259}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2253},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2253},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'dirt32');}
,"NameOfTarget":"dirt32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6305}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2253},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile5","LocalData":"","TypeName":"Entity","Id":2253},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2260}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2254},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2254},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return true;}
,"imageFilePath":"ivanGreatForest205_cc_tile60.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'ivanGreatForest205tile60');}
,"NameOfTarget":"","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6306}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2254},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":true,"LedgeCollision":true,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile6","LocalData":"","TypeName":"Entity","Id":2254}],"Threntities":[],"PointLights":[],"MyAudio":[],"MyLogic":{"update":
 function() {for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":null,"TypeName":"SceneProceduralStatement","Id":0},{"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"SceneProceduralStatement","Id":354}],"Name":"","LocalData":"","TypeName":"SceneLogicBox","Id":354},"Name":"","LocalData":"","TypeName":"Scene","Id":354},{"reloadThrentities":
function() { var allT = this.allThrentities(); for(var i in allT) { setupThrentity(allT[i]); } }
,"setup":
 function() {if (this.isSetup !== true) {for(var i in this.TileGrids) { this.TileGrids[i].setup(this); } for(var i in this.PointLights) { this.PointLights[i].setup(this); } if (this.MyAudio !== null) { for (var i = 0; i < this.MyAudio.length; i++) { this.MyAudio[i].setup(); } }if (game.active().Omnipresent2D.length > 0) { var indices = this.entityIndexArray(); var allE = this.allEntities();  for(var i in allE) { if (allE[i].MyIndex != '') { var ind = indices.indexOf(allE[i].MyIndex); if(ind != -1) { indices.splice(ind, 1); } } else { allE[i].setup(indices[i]); } }  } else { for(var i in this.Entities) { this.Entities[i].setup(i); } }if (game.active().Omnipresent3D.length > 0) { var indices = this.threntityIndexArray(); var allT = this.allThrentities(); for(var i in allT) { if (allT[i].MyIndex != '') { var ind = indices.indexOf(allT[i].MyIndex); if (ind != -1) { indices.splice(ind, 1); } } else { allT[i].setup(indices[i]); } }  } else { for(var i in this.Threntities) { this.Threntities[i].setup(i); } }if (this.HasAmbientLight == true) { addAmbientLightToCurrentScene(this.AmbientLightColor, this.AmbientLightIntensity / parseFloat(100)); }this.isSetup = true; }}
,"update":
 function() {this.MyLogic.update();for(var i in this.MyAudio) { this.MyAudio[i].update(); } var allE = this.allEntities(); for(var i in allE) { allE[i].update(); }var allT = this.allThrentities(); for(var i in allT) { allT[i].update(); }for(var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].update(this.AdhocSceneRefs[i].TargetName); } for(var i in this.TileGrids) { this.TileGrids[i].update(); } }
,"draw":
 function() {for(var i in this.TileGrids) { this.TileGrids[i].draw(); } var allE = this.allEntities(); for(var i in allE) { if (allE[i].Disabled !== true) { allE[i].draw(); } }var allT = this.allThrentities(); for(var i in allT) { allT[i].draw(); } }
,"entityIndexArray":
function() { var ray = []; for(var x in game.active().Omnipresent2D) { ray.push(game.active().Omnipresent2D[x].MyIndex); } var rayLen = ray.length; for(i=0;i<rayLen+this.Entities.length;i++) { if (ray.includes((i).toString())) {  } else {  ray.push(i); } } return ray; }
,"threntityIndexArray":
function() { var ray = []; for(var x in game.active().Omnipresent3D) { ray.push(game.active().Omnipresent3D[x].MyIndex); } var rayLen = ray.length; for(i=0;i<rayLen+this.Threntities.length;i++) { if (ray.includes((i).toString())) {  } else {  ray.push(i); } } return ray; }
,"checkMovePoint3d":
function(point3dBefore, point3dAfter) {  var all = this.allThrentities(); for(var i in all) { if (this.checkPointCollision(all[i], point3dBefore, point3dAfter)==true) { return false; } } return true;  }
,"checkPointCollision":
function(targetThrent, point3dBefore, point3dAfter) { var xBef = point3dBefore.X;var xAft = point3dAfter.X;var yBef = point3dBefore.Y;var yAft = point3dAfter.Y;var zBef = point3dBefore.Z;var zAft = point3dAfter.Z;var minX = targetThrent.L();var maxX = targetThrent.R();var minY = targetThrent.B();var maxY = targetThrent.T();var minZ = targetThrent.A();var maxZ = targetThrent.F();var xOverlap = false; var yOverlap = false; var zOverlap = false;if (xBef<xAft) { xOverlap = this.checkRangeOverlap(xBef, xAft, minX, maxX); } else { xOverlap = this.checkRangeOverlap(xAft, xBef, minX, maxX); }if (yBef<yAft) { yOverlap = this.checkRangeOverlap(yBef, yAft, minY, maxY); } else { yOverlap = this.checkRangeOverlap(yAft, yBef, minY, maxY); }if (zBef<zAft) { zOverlap = this.checkRangeOverlap(zBef, zAft, minZ, maxZ); } else { zOverlap = this.checkRangeOverlap(zAft, zBef, minZ, maxZ); }if (xOverlap==true && yOverlap==true && zOverlap==true) { return true; } return false;}
,"checkRangeOverlap":
function (inputOneMin, inputOneMax, inputTwoMin, inputTwoMax) {if (inputOneMin > inputTwoMax || inputOneMax < inputTwoMin) { return false; }return true;}
,"threnCollideContextual":
function(thren, before, after) { var hasCollide = false;var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name) { if (this.ZStraddle(before, after, all[i])===true && this.XStraddle(before, after, all[i])===true && this.YStraddle(before, after, all[i])===true) { hasCollide = true; } if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { hasCollide = true; } } }return hasCollide;}
,"ZStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.Z - before.Z;let secondDiff = target.Z - after.Z;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"XStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.X - before.X;let secondDiff = target.X - after.Y;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"YStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.Y - before.Y;let secondDiff = target.Y - after.Y;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"getFirstThrenCollide":
function(thren) { var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { return thren; } } }
,"threnCollide":
 function(thren) {var hasCollide = false;var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { hasCollide = true; } }return hasCollide;}
,"moveAll2D":
function(x, y) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } for (var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].X += x; this.AdhocSceneRefs[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } }
,"moveAll2DAround":
function(x, y, entName) { var ent = find(game.scene().Entities, entName); if (this.wouldCollide(ent.transpose(-x, -y)) === false) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } } }
,"quickMoveAll2DAround":
function(x, y, ent) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } for(var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].X += x; this.AdhocSceneRefs[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } }
,"tryMoveAll2DAround":
function(x, y, entName) {if (this.getMainTilegrid() === -1) { return this.moveAll2DAround(x, y, entName); } else { this.dynamic2DMove(x, y, entName, this.getMainTilegrid()); } }
,"dynamic2DMove":
function(x, y, entName, tileGrid) {var ent = game.findEntity(entName);if (this.wouldCollide(ent.transpose(-x, -y)) === false) {this.dynamic2DMoveX(x, ent, tileGrid);this.dynamic2DMoveY(y, ent, tileGrid); }}
,"dynamic2DMoveUp":
function(y, ent, tileGrid) {var amtMoveHeroTowardsCenter = (ent.pastCenterY() === false && ent.isCenteredY() === false) ? 0 : (ent.myCenterY() - viewportCenterY());if (amtMoveHeroTowardsCenter >= y) { ent.Y -= y; return; } else { ent.Y -= amtMoveHeroTowardsCenter; }var remainder = y - amtMoveHeroTowardsCenter;var tileGridSlack = 0 - tileGrid.Y;if (remainder <= Math.abs(tileGridSlack)) { this.quickMoveAll2DAround(0, remainder, ent); return; } else { this.quickMoveAll2DAround(0, Math.abs(tileGridSlack), ent); }remainder = remainder - Math.abs(tileGridSlack);ent.Y -= remainder;}
,"dynamic2DMoveDown":
function(y, ent, tileGrid) {var absY = Math.abs(y);var amtMoveHeroTowardsCenter = (ent.isCenteredY() || ent.pastCenterY()) ? 0 : viewportCenterY() - ent.myCenterY();if (amtMoveHeroTowardsCenter >= absY) { ent.Y -= y; return; } else { ent.Y += amtMoveHeroTowardsCenter; }var remainder = absY - amtMoveHeroTowardsCenter;var tileGridSlack = tileGrid.B() - getYDrawBounds2D();if (remainder <= tileGridSlack) { this.quickMoveAll2DAround(0, -remainder, ent); return; } else { this.quickMoveAll2DAround(0, tileGridSlack, ent); }remainder = remainder - tileGridSlack;ent.Y += remainder;}
,"dynamic2DMoveLeft":
function(x, ent, tileGrid) {var amtMoveHeroTowardsCenter = (ent.pastCenterX() === false && ent.isCenteredX() === false) ? 0 : (ent.myCenterX() - viewportCenterX());if (amtMoveHeroTowardsCenter >= x) { ent.X -= x; return; } else { ent.X -= amtMoveHeroTowardsCenter; }var remainder = x - amtMoveHeroTowardsCenter;var tileGridSlack = 0 - tileGrid.X;if (remainder <= Math.abs(tileGridSlack)) { this.quickMoveAll2DAround(remainder, 0, ent); return; } else { this.quickMoveAll2DAround(Math.abs(tileGridSlack), 0, ent); }remainder = remainder - Math.abs(tileGridSlack);ent.X -= remainder;}
,"dynamic2DMoveRight":
function(x, ent, tileGrid) {var absX = Math.abs(x);var amtMoveHeroTowardsCenter = (ent.isCenteredX() || ent.pastCenterX()) ? 0 : viewportCenterX() - ent.myCenterX();if (amtMoveHeroTowardsCenter >= absX) { ent.X -= x; return; } else { ent.X += amtMoveHeroTowardsCenter; }var remainder = absX - amtMoveHeroTowardsCenter;var tileGridSlack = tileGrid.R() - getXDrawBounds2D();if (remainder <= tileGridSlack) { this.quickMoveAll2DAround(-remainder, 0, ent); return; } else { this.quickMoveAll2DAround(tileGridSlack, 0, ent); }remainder = remainder - tileGridSlack;ent.X += remainder;}
,"dynamic2DMoveX":
function(x, ent, tileGrid) { var movingLeft = x > 0;if (movingLeft) { this.dynamic2DMoveLeft(x, ent, tileGrid); return; } else { this.dynamic2DMoveRight(x, ent, tileGrid); return; }var tileGridSlackX = x < 0 ? -1 * tileGrid.X : tileGrid.R() - getXDrawBounds2D(); if (ent.isCenteredX() !== true) { var centerSlackX = (x < 0 ? ((getXDrawBounds2D() / 2) - ent.X) : ent.X - (getXDrawBounds2D() / 2)); if (centerSlackX > Math.abs(x)) { ent.X -= x; }else if (centerSlackX < Math.abs(x) && centerSlackX > 0) { ent.X -= centerSlackX; }  }else if (tileGridSlackX > Math.abs(x)) { this.moveAll2DAround(x, 0, ent.Name); }else if (tileGridSlackX < Math.abs(x) && tileGridSlackX > 0) { this.moveAll2DAround(tileGridSlackX, 0, ent.Name); }}
,"dynamic2DMoveY":
function(y, ent, tileGrid) { var movingUp = y > 0;if (movingUp) { this.dynamic2DMoveUp(y, ent, tileGrid); return; } else { this.dynamic2DMoveDown(y, ent, tileGrid); return; }var tileGridSlackY = y < 0 ? -1 * tileGrid.Y : tileGrid.B() - getYDrawBounds2D();if (ent.isCenteredY() !== true) { var centerSlackY = (y < 0 ? ((getYDrawBounds2D() / 2) - ent.Y) : ent.Y - (getYDrawBounds2D() / 2)); if (centerSlackY > Math.abs(y)) { ent.Y -= y; }else if (centerSlackY < Math.abs(y) && centerSlackY > 0) { ent.Y -= centerSlackY; }  }else if (tileGridSlackY > Math.abs(y)) { this.moveAll2DAround(y, 0, ent.Name); }else if (tileGridSlackY < Math.abs(y) && tileGridSlackY > 0) { this.moveAll2DAround(tileGridSlackY, 0, ent.Name); }}
,"prepareForRenderer":
 function() {return {  };}
,"loadScene":
function() { loadThrentitiesIntoNewScene(this.allThrentities(), this.PointLights); }
,"allThrentities":
function() { return game.active().Omnipresent3D.concat(this.validLocalThrentities()); }
,"validLocalThrentities":
function() { return this.Threntities.filter(function(obj) { return Object.keys(obj).length > 0; }); }
,"getThrentity":
function (index) { var ent = game.active().getOmni3D(index); if (ent != null) { return ent; } var obj = this.Threntities[index]; if (obj == null || Object.keys(obj).length == 0) { return game.active().getOmni3D(index); } else { return this.Threntities[index]; } }
,"allEntities":
function() { return game.active().Omnipresent2D.concat(this.validLocalEntities()); }
,"validLocalEntities":
function() { return this.Entities.filter(function(obj) { return Object.keys(obj).length > 0; }); }
,"getEntity":
function (index) { var ent = game.active().getOmni2D(index); if (ent != null) { return ent; } var obj = this.Entities[index]; if (obj == null || Object.keys(obj).length == 0) { return game.active().getOmni2D(index); } else { return this.Entities[index]; } }
,"getMainTilegrid":
function() { for(var i in this.TileGrids) { if (this.TileGrids[i].MainGrid === true) { return this.TileGrids[i]; } } return -1; }
,"shiftToTop":
function() {  var main = this.getMainTilegrid(); if (main !== -1) { var moveY = main.Y; this.moveAll2D(0, moveY); return moveY; } }
,"shiftToBottom":
function() {  var main = this.getMainTilegrid(); if (main !== -1) { var moveY = -(main.B() - getYDrawBounds2D()); this.moveAll2D(0, moveY); return moveY; } }
,"shiftToRight":
function() { if (this.shiftedToRight == true) {  }  var main = this.getMainTilegrid(); if (main !== -1) {  var moveX = -(main.R() - getXDrawBounds2D()); this.moveAll2D(moveX, 0); this.shiftedToLeft = false; this.shiftedToRight = true; return moveX; } }
,"shiftToLeft":
function() { if (this.shiftedToLeft == true) {  } var main = this.getMainTilegrid(); if (main !== -1) {  var moveX = main.X; this.moveAll2D(moveX, 0);  this.shiftedToLeft = true; this.shiftedToRight = false; return moveX; } }
,"shiftedToLeft":
false
,"shiftedToRight":
false
,"shiftedToTop":
false
,"shiftedToBottom":
false
,"wouldCollide":
 function(entity) {var hasCollide = false;for (var i in this.TileGrids) { if (this.TileGrids[i].wouldCollide(entity) === true) { hasCollide = true; } }var all = this.allEntities(); for (var i in all) { if (all[i].NotWorldLevel !== true && all[i].NonCorporeal !== true && all[i].Disabled !== true && all[i].Name !== entity.name && all[i].wouldCollide(entity)) { hasCollide = true; } }return hasCollide;}
,"isSetup":
false
,"XResolution":640,"YResolution":400,"HasAmbientLight":false,"AmbientLightIntensity":75,"AmbientLightColor":"0xffffcf","Bounds2DX":0,"Bounds2DY":0,"TileGrids":[{"setup":
function(parent) { if (this.DelimitedGrid && this.DelimitedGrid.length > 0){ var rows = this.DelimitedGrid.split(';');for (var j in rows) { this.tiles.push([]); var cells = rows[j].split(',');  for (var i in cells) { var tile=this.getTile(parent, cells[i]); this.tiles[j].push(tile); } } } }
,"getTile":
function(parentScene, tileId) {  var eName = this.EntityNameCSVKey.split(',')[tileId]; var tile = find(parentScene.allEntities(), eName); /* tile.draw = function(x,y,w,h) { this.MyImage.active().render(x,y,w,h); }; */ return tile;  }
,"draw":
function() { if (this.SkipDraw==true) { return; } for(var j in this.tiles) { for(var i in this.tiles[j]) { if (this.tiles[j][i] != null && this.tiles[j][i].MyImage != null) { this.tiles[j][i].MyImage.active().render(this.X + (i * this.TW),this.Y + (j * this.TH),this.TW,this.TH); } } } }
,"update":
 function() {}
,"tiles":
 [] 
,"R":
 function() {return this.X + (this.getWidth() * this.TW);}
,"B":
 function() {return this.Y + (this.getHeight() * this.TH);}
,"wouldCollide":
 function(entity) {for(var j in this.tiles)      {       for (var i in this.tiles[j])       {        if (this.tiles[j][i] != null && this.tiles[j][i].ForceCollision===true)        {         var x = this.X + (i * this.TW);         var y = this.Y + (j * this.TH);         if (checkOverlap({X:x,Y:y,W:this.TW,H:this.TH}, entity) === true)         {          console.log('overlap found');         var events = this.tiles[j][i].collisionEvents;         if (events !== null)         {         }         if (this.tiles[j][i].LedgeCollision === true)         {          if (/*notideal*/downkey() && !leftkey() && !rightkey())          {           console.log('ledge collision detected');           /*arbitrary*/var speed = 4;           /* make entity.MyLogic have a non null ActionBlock? */           entity.Me.MyLogic.ActionBlock.MyActions.push({Depth:((this.TH/speed)*2)+1,SelfDestruct:true,Ct:0,Destroyed:false,update:function() { console.log('updating action');  if (this.BlockInput === true) { BlockInput(); } if (this.SelfDestruct === true && this.Ct + 1 == this.Depth) { this.Destroyed = true; } if (this.Destroyed !== true) { this.MyScript(); this.Ct++; } },MyTarget:entity,BlockInput:true,LocalData:speed,MyScript:function() { console.log('performing action...'); this.MyTarget.Me.Y += this.LocalData; }});          }         }         return true;         }        }       }      }       return false;}
,"getWidth":
function() { if (this.getHeight() > 0) { return this.tiles[0].length; } else { return 0; } }
,"getHeight":
function() { return this.tiles.length; }
,"EntityIndexCSVKey":"","EntityNameCSVKey":"tile1,tile2,tile3,tile4,tile5","DelimitedGrid":"4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4","SkipDraw":false,"MainGrid":true,"TW":32,"TH":32,"X":0,"Y":0,"Name":"","LocalData":"","TypeName":"TileGrid","Id":319}],"AdhocSceneRefs":[],"Entities":[{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2261}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2255},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2255},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'grass32');}
,"NameOfTarget":"grass32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6307}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2255},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile1","LocalData":"","TypeName":"Entity","Id":2255},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2262}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2256},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2256},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'stone32');}
,"NameOfTarget":"stone32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6308}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2256},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile2","LocalData":"","TypeName":"Entity","Id":2256},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2263}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2257},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2257},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":8,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water1');}
,"NameOfTarget":"water1","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6309},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water2');}
,"NameOfTarget":"water2","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6310},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water3');}
,"NameOfTarget":"water3","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6311},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water4');}
,"NameOfTarget":"water4","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6312},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water5');}
,"NameOfTarget":"water5","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6313},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water6');}
,"NameOfTarget":"water6","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6314},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water7');}
,"NameOfTarget":"water7","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6315},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water8');}
,"NameOfTarget":"water8","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6316},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water9');}
,"NameOfTarget":"water9","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6317},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water10');}
,"NameOfTarget":"water10","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6318},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water11');}
,"NameOfTarget":"water11","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6319},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water12');}
,"NameOfTarget":"water12","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6320},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water13');}
,"NameOfTarget":"water13","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6321},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water14');}
,"NameOfTarget":"water14","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6322},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water15');}
,"NameOfTarget":"water15","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6323}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2257},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile3","LocalData":"","TypeName":"Entity","Id":2257},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2264}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2258},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2258},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'stoneWall32');}
,"NameOfTarget":"stoneWall32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6324}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2258},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":true,"LedgeCollision":true,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile4","LocalData":"","TypeName":"Entity","Id":2258},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2265}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2259},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2259},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'dirt32');}
,"NameOfTarget":"dirt32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6325}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2259},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile5","LocalData":"","TypeName":"Entity","Id":2259},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2266}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2260},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2260},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return true;}
,"imageFilePath":"ivanGreatForest205_cc_tile60.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'ivanGreatForest205tile60');}
,"NameOfTarget":"","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6326}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2260},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":true,"LedgeCollision":true,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile6","LocalData":"","TypeName":"Entity","Id":2260}],"Threntities":[],"PointLights":[],"MyAudio":[],"MyLogic":{"update":
 function() {for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":null,"TypeName":"SceneProceduralStatement","Id":0},{"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"SceneProceduralStatement","Id":355}],"Name":"","LocalData":"","TypeName":"SceneLogicBox","Id":355},"Name":"","LocalData":"","TypeName":"Scene","Id":355},{"reloadThrentities":
function() { var allT = this.allThrentities(); for(var i in allT) { setupThrentity(allT[i]); } }
,"setup":
 function() {if (this.isSetup !== true) {for(var i in this.TileGrids) { this.TileGrids[i].setup(this); } for(var i in this.PointLights) { this.PointLights[i].setup(this); } if (this.MyAudio !== null) { for (var i = 0; i < this.MyAudio.length; i++) { this.MyAudio[i].setup(); } }if (game.active().Omnipresent2D.length > 0) { var indices = this.entityIndexArray(); var allE = this.allEntities();  for(var i in allE) { if (allE[i].MyIndex != '') { var ind = indices.indexOf(allE[i].MyIndex); if(ind != -1) { indices.splice(ind, 1); } } else { allE[i].setup(indices[i]); } }  } else { for(var i in this.Entities) { this.Entities[i].setup(i); } }if (game.active().Omnipresent3D.length > 0) { var indices = this.threntityIndexArray(); var allT = this.allThrentities(); for(var i in allT) { if (allT[i].MyIndex != '') { var ind = indices.indexOf(allT[i].MyIndex); if (ind != -1) { indices.splice(ind, 1); } } else { allT[i].setup(indices[i]); } }  } else { for(var i in this.Threntities) { this.Threntities[i].setup(i); } }if (this.HasAmbientLight == true) { addAmbientLightToCurrentScene(this.AmbientLightColor, this.AmbientLightIntensity / parseFloat(100)); }this.isSetup = true; }}
,"update":
 function() {this.MyLogic.update();for(var i in this.MyAudio) { this.MyAudio[i].update(); } var allE = this.allEntities(); for(var i in allE) { allE[i].update(); }var allT = this.allThrentities(); for(var i in allT) { allT[i].update(); }for(var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].update(this.AdhocSceneRefs[i].TargetName); } for(var i in this.TileGrids) { this.TileGrids[i].update(); } }
,"draw":
 function() {for(var i in this.TileGrids) { this.TileGrids[i].draw(); } var allE = this.allEntities(); for(var i in allE) { if (allE[i].Disabled !== true) { allE[i].draw(); } }var allT = this.allThrentities(); for(var i in allT) { allT[i].draw(); } }
,"entityIndexArray":
function() { var ray = []; for(var x in game.active().Omnipresent2D) { ray.push(game.active().Omnipresent2D[x].MyIndex); } var rayLen = ray.length; for(i=0;i<rayLen+this.Entities.length;i++) { if (ray.includes((i).toString())) {  } else {  ray.push(i); } } return ray; }
,"threntityIndexArray":
function() { var ray = []; for(var x in game.active().Omnipresent3D) { ray.push(game.active().Omnipresent3D[x].MyIndex); } var rayLen = ray.length; for(i=0;i<rayLen+this.Threntities.length;i++) { if (ray.includes((i).toString())) {  } else {  ray.push(i); } } return ray; }
,"checkMovePoint3d":
function(point3dBefore, point3dAfter) {  var all = this.allThrentities(); for(var i in all) { if (this.checkPointCollision(all[i], point3dBefore, point3dAfter)==true) { return false; } } return true;  }
,"checkPointCollision":
function(targetThrent, point3dBefore, point3dAfter) { var xBef = point3dBefore.X;var xAft = point3dAfter.X;var yBef = point3dBefore.Y;var yAft = point3dAfter.Y;var zBef = point3dBefore.Z;var zAft = point3dAfter.Z;var minX = targetThrent.L();var maxX = targetThrent.R();var minY = targetThrent.B();var maxY = targetThrent.T();var minZ = targetThrent.A();var maxZ = targetThrent.F();var xOverlap = false; var yOverlap = false; var zOverlap = false;if (xBef<xAft) { xOverlap = this.checkRangeOverlap(xBef, xAft, minX, maxX); } else { xOverlap = this.checkRangeOverlap(xAft, xBef, minX, maxX); }if (yBef<yAft) { yOverlap = this.checkRangeOverlap(yBef, yAft, minY, maxY); } else { yOverlap = this.checkRangeOverlap(yAft, yBef, minY, maxY); }if (zBef<zAft) { zOverlap = this.checkRangeOverlap(zBef, zAft, minZ, maxZ); } else { zOverlap = this.checkRangeOverlap(zAft, zBef, minZ, maxZ); }if (xOverlap==true && yOverlap==true && zOverlap==true) { return true; } return false;}
,"checkRangeOverlap":
function (inputOneMin, inputOneMax, inputTwoMin, inputTwoMax) {if (inputOneMin > inputTwoMax || inputOneMax < inputTwoMin) { return false; }return true;}
,"threnCollideContextual":
function(thren, before, after) { var hasCollide = false;var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name) { if (this.ZStraddle(before, after, all[i])===true && this.XStraddle(before, after, all[i])===true && this.YStraddle(before, after, all[i])===true) { hasCollide = true; } if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { hasCollide = true; } } }return hasCollide;}
,"ZStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.Z - before.Z;let secondDiff = target.Z - after.Z;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"XStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.X - before.X;let secondDiff = target.X - after.Y;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"YStraddle":
 function(before, after, target) {if (target.wouldCollide(before) || target.wouldCollide(after)) {return true;}let firstDiff = target.Y - before.Y;let secondDiff = target.Y - after.Y;if (firstDiff > 0 && secondDiff < 0 || firstDiff < 0 && secondDiff > 0) {return true;}return false;}
,"getFirstThrenCollide":
function(thren) { var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { return thren; } } }
,"threnCollide":
 function(thren) {var hasCollide = false;var all = this.allThrentities(); for (var i in all) { if (all[i].Name !== thren.name && all[i].wouldCollide(thren)) { hasCollide = true; } }return hasCollide;}
,"moveAll2D":
function(x, y) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } for (var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].X += x; this.AdhocSceneRefs[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } }
,"moveAll2DAround":
function(x, y, entName) { var ent = find(game.scene().Entities, entName); if (this.wouldCollide(ent.transpose(-x, -y)) === false) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } } }
,"quickMoveAll2DAround":
function(x, y, ent) { for(var i in this.TileGrids) { this.TileGrids[i].X += x; this.TileGrids[i].Y += y; } for(var i in this.AdhocSceneRefs) { this.AdhocSceneRefs[i].X += x; this.AdhocSceneRefs[i].Y += y; } var allE = this.allEntities(); for(var i in allE) { if (allE[i].NotWorldLevel) { } else { allE[i].X += x; allE[i].Y += y; } } }
,"tryMoveAll2DAround":
function(x, y, entName) {if (this.getMainTilegrid() === -1) { return this.moveAll2DAround(x, y, entName); } else { this.dynamic2DMove(x, y, entName, this.getMainTilegrid()); } }
,"dynamic2DMove":
function(x, y, entName, tileGrid) {var ent = game.findEntity(entName);if (this.wouldCollide(ent.transpose(-x, -y)) === false) {this.dynamic2DMoveX(x, ent, tileGrid);this.dynamic2DMoveY(y, ent, tileGrid); }}
,"dynamic2DMoveUp":
function(y, ent, tileGrid) {var amtMoveHeroTowardsCenter = (ent.pastCenterY() === false && ent.isCenteredY() === false) ? 0 : (ent.myCenterY() - viewportCenterY());if (amtMoveHeroTowardsCenter >= y) { ent.Y -= y; return; } else { ent.Y -= amtMoveHeroTowardsCenter; }var remainder = y - amtMoveHeroTowardsCenter;var tileGridSlack = 0 - tileGrid.Y;if (remainder <= Math.abs(tileGridSlack)) { this.quickMoveAll2DAround(0, remainder, ent); return; } else { this.quickMoveAll2DAround(0, Math.abs(tileGridSlack), ent); }remainder = remainder - Math.abs(tileGridSlack);ent.Y -= remainder;}
,"dynamic2DMoveDown":
function(y, ent, tileGrid) {var absY = Math.abs(y);var amtMoveHeroTowardsCenter = (ent.isCenteredY() || ent.pastCenterY()) ? 0 : viewportCenterY() - ent.myCenterY();if (amtMoveHeroTowardsCenter >= absY) { ent.Y -= y; return; } else { ent.Y += amtMoveHeroTowardsCenter; }var remainder = absY - amtMoveHeroTowardsCenter;var tileGridSlack = tileGrid.B() - getYDrawBounds2D();if (remainder <= tileGridSlack) { this.quickMoveAll2DAround(0, -remainder, ent); return; } else { this.quickMoveAll2DAround(0, tileGridSlack, ent); }remainder = remainder - tileGridSlack;ent.Y += remainder;}
,"dynamic2DMoveLeft":
function(x, ent, tileGrid) {var amtMoveHeroTowardsCenter = (ent.pastCenterX() === false && ent.isCenteredX() === false) ? 0 : (ent.myCenterX() - viewportCenterX());if (amtMoveHeroTowardsCenter >= x) { ent.X -= x; return; } else { ent.X -= amtMoveHeroTowardsCenter; }var remainder = x - amtMoveHeroTowardsCenter;var tileGridSlack = 0 - tileGrid.X;if (remainder <= Math.abs(tileGridSlack)) { this.quickMoveAll2DAround(remainder, 0, ent); return; } else { this.quickMoveAll2DAround(Math.abs(tileGridSlack), 0, ent); }remainder = remainder - Math.abs(tileGridSlack);ent.X -= remainder;}
,"dynamic2DMoveRight":
function(x, ent, tileGrid) {var absX = Math.abs(x);var amtMoveHeroTowardsCenter = (ent.isCenteredX() || ent.pastCenterX()) ? 0 : viewportCenterX() - ent.myCenterX();if (amtMoveHeroTowardsCenter >= absX) { ent.X -= x; return; } else { ent.X += amtMoveHeroTowardsCenter; }var remainder = absX - amtMoveHeroTowardsCenter;var tileGridSlack = tileGrid.R() - getXDrawBounds2D();if (remainder <= tileGridSlack) { this.quickMoveAll2DAround(-remainder, 0, ent); return; } else { this.quickMoveAll2DAround(tileGridSlack, 0, ent); }remainder = remainder - tileGridSlack;ent.X += remainder;}
,"dynamic2DMoveX":
function(x, ent, tileGrid) { var movingLeft = x > 0;if (movingLeft) { this.dynamic2DMoveLeft(x, ent, tileGrid); return; } else { this.dynamic2DMoveRight(x, ent, tileGrid); return; }var tileGridSlackX = x < 0 ? -1 * tileGrid.X : tileGrid.R() - getXDrawBounds2D(); if (ent.isCenteredX() !== true) { var centerSlackX = (x < 0 ? ((getXDrawBounds2D() / 2) - ent.X) : ent.X - (getXDrawBounds2D() / 2)); if (centerSlackX > Math.abs(x)) { ent.X -= x; }else if (centerSlackX < Math.abs(x) && centerSlackX > 0) { ent.X -= centerSlackX; }  }else if (tileGridSlackX > Math.abs(x)) { this.moveAll2DAround(x, 0, ent.Name); }else if (tileGridSlackX < Math.abs(x) && tileGridSlackX > 0) { this.moveAll2DAround(tileGridSlackX, 0, ent.Name); }}
,"dynamic2DMoveY":
function(y, ent, tileGrid) { var movingUp = y > 0;if (movingUp) { this.dynamic2DMoveUp(y, ent, tileGrid); return; } else { this.dynamic2DMoveDown(y, ent, tileGrid); return; }var tileGridSlackY = y < 0 ? -1 * tileGrid.Y : tileGrid.B() - getYDrawBounds2D();if (ent.isCenteredY() !== true) { var centerSlackY = (y < 0 ? ((getYDrawBounds2D() / 2) - ent.Y) : ent.Y - (getYDrawBounds2D() / 2)); if (centerSlackY > Math.abs(y)) { ent.Y -= y; }else if (centerSlackY < Math.abs(y) && centerSlackY > 0) { ent.Y -= centerSlackY; }  }else if (tileGridSlackY > Math.abs(y)) { this.moveAll2DAround(y, 0, ent.Name); }else if (tileGridSlackY < Math.abs(y) && tileGridSlackY > 0) { this.moveAll2DAround(tileGridSlackY, 0, ent.Name); }}
,"prepareForRenderer":
 function() {return {  };}
,"loadScene":
function() { loadThrentitiesIntoNewScene(this.allThrentities(), this.PointLights); }
,"allThrentities":
function() { return game.active().Omnipresent3D.concat(this.validLocalThrentities()); }
,"validLocalThrentities":
function() { return this.Threntities.filter(function(obj) { return Object.keys(obj).length > 0; }); }
,"getThrentity":
function (index) { var ent = game.active().getOmni3D(index); if (ent != null) { return ent; } var obj = this.Threntities[index]; if (obj == null || Object.keys(obj).length == 0) { return game.active().getOmni3D(index); } else { return this.Threntities[index]; } }
,"allEntities":
function() { return game.active().Omnipresent2D.concat(this.validLocalEntities()); }
,"validLocalEntities":
function() { return this.Entities.filter(function(obj) { return Object.keys(obj).length > 0; }); }
,"getEntity":
function (index) { var ent = game.active().getOmni2D(index); if (ent != null) { return ent; } var obj = this.Entities[index]; if (obj == null || Object.keys(obj).length == 0) { return game.active().getOmni2D(index); } else { return this.Entities[index]; } }
,"getMainTilegrid":
function() { for(var i in this.TileGrids) { if (this.TileGrids[i].MainGrid === true) { return this.TileGrids[i]; } } return -1; }
,"shiftToTop":
function() {  var main = this.getMainTilegrid(); if (main !== -1) { var moveY = main.Y; this.moveAll2D(0, moveY); return moveY; } }
,"shiftToBottom":
function() {  var main = this.getMainTilegrid(); if (main !== -1) { var moveY = -(main.B() - getYDrawBounds2D()); this.moveAll2D(0, moveY); return moveY; } }
,"shiftToRight":
function() { if (this.shiftedToRight == true) {  }  var main = this.getMainTilegrid(); if (main !== -1) {  var moveX = -(main.R() - getXDrawBounds2D()); this.moveAll2D(moveX, 0); this.shiftedToLeft = false; this.shiftedToRight = true; return moveX; } }
,"shiftToLeft":
function() { if (this.shiftedToLeft == true) {  } var main = this.getMainTilegrid(); if (main !== -1) {  var moveX = main.X; this.moveAll2D(moveX, 0);  this.shiftedToLeft = true; this.shiftedToRight = false; return moveX; } }
,"shiftedToLeft":
false
,"shiftedToRight":
false
,"shiftedToTop":
false
,"shiftedToBottom":
false
,"wouldCollide":
 function(entity) {var hasCollide = false;for (var i in this.TileGrids) { if (this.TileGrids[i].wouldCollide(entity) === true) { hasCollide = true; } }var all = this.allEntities(); for (var i in all) { if (all[i].NotWorldLevel !== true && all[i].NonCorporeal !== true && all[i].Disabled !== true && all[i].Name !== entity.name && all[i].wouldCollide(entity)) { hasCollide = true; } }return hasCollide;}
,"isSetup":
false
,"XResolution":640,"YResolution":400,"HasAmbientLight":false,"AmbientLightIntensity":75,"AmbientLightColor":"0xffffcf","Bounds2DX":0,"Bounds2DY":0,"TileGrids":[{"setup":
function(parent) { if (this.DelimitedGrid && this.DelimitedGrid.length > 0){ var rows = this.DelimitedGrid.split(';');for (var j in rows) { this.tiles.push([]); var cells = rows[j].split(',');  for (var i in cells) { var tile=this.getTile(parent, cells[i]); this.tiles[j].push(tile); } } } }
,"getTile":
function(parentScene, tileId) {  var eName = this.EntityNameCSVKey.split(',')[tileId]; var tile = find(parentScene.allEntities(), eName); /* tile.draw = function(x,y,w,h) { this.MyImage.active().render(x,y,w,h); }; */ return tile;  }
,"draw":
function() { if (this.SkipDraw==true) { return; } for(var j in this.tiles) { for(var i in this.tiles[j]) { if (this.tiles[j][i] != null && this.tiles[j][i].MyImage != null) { this.tiles[j][i].MyImage.active().render(this.X + (i * this.TW),this.Y + (j * this.TH),this.TW,this.TH); } } } }
,"update":
 function() {}
,"tiles":
 [] 
,"R":
 function() {return this.X + (this.getWidth() * this.TW);}
,"B":
 function() {return this.Y + (this.getHeight() * this.TH);}
,"wouldCollide":
 function(entity) {for(var j in this.tiles)      {       for (var i in this.tiles[j])       {        if (this.tiles[j][i] != null && this.tiles[j][i].ForceCollision===true)        {         var x = this.X + (i * this.TW);         var y = this.Y + (j * this.TH);         if (checkOverlap({X:x,Y:y,W:this.TW,H:this.TH}, entity) === true)         {          console.log('overlap found');         var events = this.tiles[j][i].collisionEvents;         if (events !== null)         {         }         if (this.tiles[j][i].LedgeCollision === true)         {          if (/*notideal*/downkey() && !leftkey() && !rightkey())          {           console.log('ledge collision detected');           /*arbitrary*/var speed = 4;           /* make entity.MyLogic have a non null ActionBlock? */           entity.Me.MyLogic.ActionBlock.MyActions.push({Depth:((this.TH/speed)*2)+1,SelfDestruct:true,Ct:0,Destroyed:false,update:function() { console.log('updating action');  if (this.BlockInput === true) { BlockInput(); } if (this.SelfDestruct === true && this.Ct + 1 == this.Depth) { this.Destroyed = true; } if (this.Destroyed !== true) { this.MyScript(); this.Ct++; } },MyTarget:entity,BlockInput:true,LocalData:speed,MyScript:function() { console.log('performing action...'); this.MyTarget.Me.Y += this.LocalData; }});          }         }         return true;         }        }       }      }       return false;}
,"getWidth":
function() { if (this.getHeight() > 0) { return this.tiles[0].length; } else { return 0; } }
,"getHeight":
function() { return this.tiles.length; }
,"EntityIndexCSVKey":"","EntityNameCSVKey":"tile1,tile2,tile3,tile4,tile5","DelimitedGrid":"4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4;4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4","SkipDraw":false,"MainGrid":true,"TW":32,"TH":32,"X":0,"Y":0,"Name":"","LocalData":"","TypeName":"TileGrid","Id":320}],"AdhocSceneRefs":[],"Entities":[{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2267}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2261},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2261},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'grass32');}
,"NameOfTarget":"grass32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6327}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2261},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile1","LocalData":"","TypeName":"Entity","Id":2261},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2268}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2262},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2262},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'stone32');}
,"NameOfTarget":"stone32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6328}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2262},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile2","LocalData":"","TypeName":"Entity","Id":2262},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2269}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2263},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2263},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":8,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water1');}
,"NameOfTarget":"water1","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6329},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water2');}
,"NameOfTarget":"water2","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6330},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water3');}
,"NameOfTarget":"water3","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6331},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water4');}
,"NameOfTarget":"water4","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6332},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water5');}
,"NameOfTarget":"water5","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6333},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water6');}
,"NameOfTarget":"water6","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6334},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water7');}
,"NameOfTarget":"water7","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6335},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water8');}
,"NameOfTarget":"water8","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6336},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water9');}
,"NameOfTarget":"water9","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6337},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water10');}
,"NameOfTarget":"water10","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6338},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water11');}
,"NameOfTarget":"water11","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6339},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water12');}
,"NameOfTarget":"water12","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6340},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water13');}
,"NameOfTarget":"water13","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6341},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water14');}
,"NameOfTarget":"water14","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6342},{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'water15');}
,"NameOfTarget":"water15","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6343}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2263},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile3","LocalData":"","TypeName":"Entity","Id":2263},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2270}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2264},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2264},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'stoneWall32');}
,"NameOfTarget":"stoneWall32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6344}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2264},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":true,"LedgeCollision":true,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile4","LocalData":"","TypeName":"Entity","Id":2264},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2271}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2265},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2265},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return false;}
,"imageFilePath":null,"render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'dirt32');}
,"NameOfTarget":"dirt32","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6345}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2265},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":false,"LedgeCollision":false,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile5","LocalData":"","TypeName":"Entity","Id":2265},{"setup":
function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } 
,"cycleLogic":
function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } 
,"update":
function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } 
,"draw":
 function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }}
,"transpose":
function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; }
,"checkOmnipresence":
function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } }
,"makeOmnipresent":
function(index) { return false; /* not omnipresent */ }
,"center":
 function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };}
,"R":
 function() {return this.X + this.W;}
,"B":
 function() {return this.Y + this.H;}
,"isAdjacent":
 function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;}
,"isCentered":
function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); }
,"pastCenterX":
function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); }
,"pastCenterY":
function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); }
,"isCenteredX":
function() { return this.myCenterX()===(getXDrawBounds2D()/2);  }
,"isCenteredY":
function() { return this.myCenterY()===(getYDrawBounds2D()/2); }
,"myCenterX":
function() { return this.X + (this.W/2);  }
,"myCenterY":
function() { return this.Y + (this.H/2); }
,"myCenter":
function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  }
,"wouldCollide":
 function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());}
,"move":
function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; }
,"isCarrying":
function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); }
,"isAtop":
function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); }
,"getThoseAtop":
 function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; }
,"moveWithCargo":
function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); }
,"destroyMe":
function() { game.scene().Entities[this.MyIndex] = {}; }
,"MyLogic":{"setup":
function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  }
,"update":
 function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":"","TypeName":"ProceduralStatement","Id":0},{"setup":
function(index) { this.setupParent(index);   }
,"me":
function() { return game.active().active().getEntity(this.myParentEntity); }
,"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"ProceduralStatement","Id":2272}],"MyInputs":[],"ActionBlock":{"active":
 function() {return this.MyActions[this.Index];}
,"update":
 function() {if (this.Index < this.MyActions.length) { if (this.active().Ct + 1 < this.active().Depth) { this.active().update(); } else { this.active().Ct = 0; this.Index++; } } else { if (this.AutoRun) { this.Index = 0; this.update(); } }}
,"run":
 function() {this.Index = 0;}
,"setup":
 function(index) {for(var i in this.MyActions) { this.MyActions[i].setup(index); } }
,"AutoRun":false,"Index":0,"MyActions":[],"Name":"","LocalData":"","TypeName":"ActionDescriptionBlock","Id":2266},"Name":"","LocalData":"","TypeName":"LogicBox","Id":2266},"MyImage":{"active":
 function() {return this.ImageFrames[this.Target];}
,"Target":0,"CycleLength":0,"ImageFrames":[{"hasImagePath":
 function() {return true;}
,"imageFilePath":"ivanGreatForest205_cc_tile60.png","render":
 function(x,y,w,h) {/*alert(x.toString() + ' and y='+ y.toString());*/ drawImage(x,y,w,h,'ivanGreatForest205tile60');}
,"NameOfTarget":"","Name":"","LocalData":"","TypeName":"ImageFrame","Id":6346}],"Name":"","LocalData":"","TypeName":"ImageBox","Id":2266},"MyColor":"","X":0,"Y":0,"W":32,"H":32,"MX":0,"MY":0,"Disabled":true,"MyIndex":"","Omnipresent":false,"NotWorldLevel":false,"NonCorporeal":false,"ForceCollision":true,"LedgeCollision":true,"AnimationCount":0,"IsAOPObject":
function() { return true; }
,"ModelName":"","ClassName":"","Name":"tile6","LocalData":"","TypeName":"Entity","Id":2266}],"Threntities":[],"PointLights":[],"MyAudio":[],"MyLogic":{"update":
 function() {for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":null,"Name":null,"LocalData":null,"TypeName":"SceneProceduralStatement","Id":0},{"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {}
,"MyScript":"","Name":"","LocalData":"","TypeName":"SceneProceduralStatement","Id":356}],"Name":"","LocalData":"","TypeName":"SceneLogicBox","Id":356},"Name":"","LocalData":"","TypeName":"Scene","Id":356}],"MyLogic":{"update":
 function() {for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } }
,"OnUpdate":[{"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {if (leftkey()) { game.scene().tryMoveAll2DAround(8, 0, 'hero'); }}
,"MyScript":"if (leftkey()) [( game.scene().tryMoveAll2DAround(8, 0, **hero**); )]","Name":"","LocalData":"","TypeName":"SceneContextProceduralStatement","Id":185},{"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {if (rightkey()) { game.scene().tryMoveAll2DAround(-8, 0, 'hero'); }}
,"MyScript":"if (rightkey()) [( game.scene().tryMoveAll2DAround(-8, 0, **hero**); )]","Name":"","LocalData":"","TypeName":"SceneContextProceduralStatement","Id":186},{"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {if (upkey()) { game.scene().tryMoveAll2DAround(0, 8, 'hero'); }}
,"MyScript":"if (upkey()) [( game.scene().tryMoveAll2DAround(0, 8, **hero**); )]","Name":"","LocalData":"","TypeName":"SceneContextProceduralStatement","Id":187},{"myParentEntity":
{}
,"setupParent":
 function(index) {this.myParentEntity = index;}
,"invoke":
 function() {if (downkey()) { game.scene().tryMoveAll2DAround(0, -8, 'hero'); }}
,"MyScript":"if (downkey()) [( game.scene().tryMoveAll2DAround(0, -8, **hero**); )]","Name":"","LocalData":"","TypeName":"SceneContextProceduralStatement","Id":188}],"Name":"","LocalData":"","TypeName":"SceneContextLogicBox","Id":44},"MyDashboard":{"draw":
 function() {for(var i in this.MyLabels) { this.MyLabels[i].render(); } for(var i in this.MyBars) { this.MyBars[i].render(); } }
,"initialize":
function() { for(var i in this.MyLabels) { this.MyLabels[i].ParentDash = this; }for(var i in this.MyBars) { this.MyBars[i].ParentDash = this; }}
,"MyLabels":[],"MyBars":[],"Name":"","LocalData":"","TypeName":"Dashboard","Id":44},"KeyHandlers":[{"isDown":
 function() { return keyval('up'); }
,"isNewPress":
 function() {return this.isDown() && !this.wasDown;}
,"update":
 function() {this.wasDown = this.isDown()}
,"wasDown":
false
,"KeyName":"up","Name":null,"LocalData":null,"TypeName":"KeyHandler","Id":0},{"isDown":
 function() { return keyval('down'); }
,"isNewPress":
 function() {return this.isDown() && !this.wasDown;}
,"update":
 function() {this.wasDown = this.isDown()}
,"wasDown":
false
,"KeyName":"down","Name":null,"LocalData":null,"TypeName":"KeyHandler","Id":0},{"isDown":
 function() { return keyval('left'); }
,"isNewPress":
 function() {return this.isDown() && !this.wasDown;}
,"update":
 function() {this.wasDown = this.isDown()}
,"wasDown":
false
,"KeyName":"left","Name":null,"LocalData":null,"TypeName":"KeyHandler","Id":0},{"isDown":
 function() { return keyval('right'); }
,"isNewPress":
 function() {return this.isDown() && !this.wasDown;}
,"update":
 function() {this.wasDown = this.isDown()}
,"wasDown":
false
,"KeyName":"right","Name":null,"LocalData":null,"TypeName":"KeyHandler","Id":0},{"isDown":
 function() { return keyval('a'); }
,"isNewPress":
 function() {return this.isDown() && !this.wasDown;}
,"update":
 function() {this.wasDown = this.isDown()}
,"wasDown":
false
,"KeyName":"a","Name":null,"LocalData":null,"TypeName":"KeyHandler","Id":0},{"isDown":
 function() { return keyval('s'); }
,"isNewPress":
 function() {return this.isDown() && !this.wasDown;}
,"update":
 function() {this.wasDown = this.isDown()}
,"wasDown":
false
,"KeyName":"s","Name":null,"LocalData":null,"TypeName":"KeyHandler","Id":0},{"isDown":
 function() { return keyval('d'); }
,"isNewPress":
 function() {return this.isDown() && !this.wasDown;}
,"update":
 function() {this.wasDown = this.isDown()}
,"wasDown":
false
,"KeyName":"d","Name":null,"LocalData":null,"TypeName":"KeyHandler","Id":0},{"isDown":
 function() { return keyval('f'); }
,"isNewPress":
 function() {return this.isDown() && !this.wasDown;}
,"update":
 function() {this.wasDown = this.isDown()}
,"wasDown":
false
,"KeyName":"f","Name":null,"LocalData":null,"TypeName":"KeyHandler","Id":0},{"isDown":
 function() { return keyval('q'); }
,"isNewPress":
 function() {return this.isDown() && !this.wasDown;}
,"update":
 function() {this.wasDown = this.isDown()}
,"wasDown":
false
,"KeyName":"q","Name":null,"LocalData":null,"TypeName":"KeyHandler","Id":0},{"isDown":
 function() { return keyval('w'); }
,"isNewPress":
 function() {return this.isDown() && !this.wasDown;}
,"update":
 function() {this.wasDown = this.isDown()}
,"wasDown":
false
,"KeyName":"w","Name":null,"LocalData":null,"TypeName":"KeyHandler","Id":0},{"isDown":
 function() { return keyval('e'); }
,"isNewPress":
 function() {return this.isDown() && !this.wasDown;}
,"update":
 function() {this.wasDown = this.isDown()}
,"wasDown":
false
,"KeyName":"e","Name":null,"LocalData":null,"TypeName":"KeyHandler","Id":0},{"isDown":
 function() { return keyval('r'); }
,"isNewPress":
 function() {return this.isDown() && !this.wasDown;}
,"update":
 function() {this.wasDown = this.isDown()}
,"wasDown":
false
,"KeyName":"r","Name":null,"LocalData":null,"TypeName":"KeyHandler","Id":0},{"isDown":
 function() { return keyval('space'); }
,"isNewPress":
 function() {return this.isDown() && !this.wasDown;}
,"update":
 function() {this.wasDown = this.isDown()}
,"wasDown":
false
,"KeyName":"space","Name":null,"LocalData":null,"TypeName":"KeyHandler","Id":0},{"isDown":
 function() { return keyval('up'); }
,"isNewPress":
 function() {return this.isDown() && !this.wasDown;}
,"update":
 function() {this.wasDown = this.isDown()}
,"wasDown":
false
,"KeyName":"up","Name":"","LocalData":"","TypeName":"KeyHandler","Id":560},{"isDown":
 function() { return keyval('down'); }
,"isNewPress":
 function() {return this.isDown() && !this.wasDown;}
,"update":
 function() {this.wasDown = this.isDown()}
,"wasDown":
false
,"KeyName":"down","Name":"","LocalData":"","TypeName":"KeyHandler","Id":561},{"isDown":
 function() { return keyval('left'); }
,"isNewPress":
 function() {return this.isDown() && !this.wasDown;}
,"update":
 function() {this.wasDown = this.isDown()}
,"wasDown":
false
,"KeyName":"left","Name":"","LocalData":"","TypeName":"KeyHandler","Id":562},{"isDown":
 function() { return keyval('right'); }
,"isNewPress":
 function() {return this.isDown() && !this.wasDown;}
,"update":
 function() {this.wasDown = this.isDown()}
,"wasDown":
false
,"KeyName":"right","Name":"","LocalData":"","TypeName":"KeyHandler","Id":563},{"isDown":
 function() { return keyval('a'); }
,"isNewPress":
 function() {return this.isDown() && !this.wasDown;}
,"update":
 function() {this.wasDown = this.isDown()}
,"wasDown":
false
,"KeyName":"a","Name":"","LocalData":"","TypeName":"KeyHandler","Id":564},{"isDown":
 function() { return keyval('s'); }
,"isNewPress":
 function() {return this.isDown() && !this.wasDown;}
,"update":
 function() {this.wasDown = this.isDown()}
,"wasDown":
false
,"KeyName":"s","Name":"","LocalData":"","TypeName":"KeyHandler","Id":565},{"isDown":
 function() { return keyval('d'); }
,"isNewPress":
 function() {return this.isDown() && !this.wasDown;}
,"update":
 function() {this.wasDown = this.isDown()}
,"wasDown":
false
,"KeyName":"d","Name":"","LocalData":"","TypeName":"KeyHandler","Id":566},{"isDown":
 function() { return keyval('f'); }
,"isNewPress":
 function() {return this.isDown() && !this.wasDown;}
,"update":
 function() {this.wasDown = this.isDown()}
,"wasDown":
false
,"KeyName":"f","Name":"","LocalData":"","TypeName":"KeyHandler","Id":567},{"isDown":
 function() { return keyval('q'); }
,"isNewPress":
 function() {return this.isDown() && !this.wasDown;}
,"update":
 function() {this.wasDown = this.isDown()}
,"wasDown":
false
,"KeyName":"q","Name":"","LocalData":"","TypeName":"KeyHandler","Id":568},{"isDown":
 function() { return keyval('w'); }
,"isNewPress":
 function() {return this.isDown() && !this.wasDown;}
,"update":
 function() {this.wasDown = this.isDown()}
,"wasDown":
false
,"KeyName":"w","Name":"","LocalData":"","TypeName":"KeyHandler","Id":569},{"isDown":
 function() { return keyval('e'); }
,"isNewPress":
 function() {return this.isDown() && !this.wasDown;}
,"update":
 function() {this.wasDown = this.isDown()}
,"wasDown":
false
,"KeyName":"e","Name":"","LocalData":"","TypeName":"KeyHandler","Id":570},{"isDown":
 function() { return keyval('r'); }
,"isNewPress":
 function() {return this.isDown() && !this.wasDown;}
,"update":
 function() {this.wasDown = this.isDown()}
,"wasDown":
false
,"KeyName":"r","Name":"","LocalData":"","TypeName":"KeyHandler","Id":571},{"isDown":
 function() { return keyval('space'); }
,"isNewPress":
 function() {return this.isDown() && !this.wasDown;}
,"update":
 function() {this.wasDown = this.isDown()}
,"wasDown":
false
,"KeyName":"space","Name":"","LocalData":"","TypeName":"KeyHandler","Id":572}],"XResolution2D":"0.4","YResolution2D":"0.4","getOmni2D":
function(index) { for(var i in this.Omnipresent2D) { if (this.Omnipresent2D[i].MyIndex == index) { return this.Omnipresent2D[i]; } } }
,"getOmni3D":
function(index) { for(var i in this.Omnipresent3D) { if (this.Omnipresent3D[i].MyIndex == index) { return this.Omnipresent3D[i]; } } }
,"Omnipresent2D":
[]
,"Omnipresent3D":
[]
,"SceneGrids":[{"update":
function(target) { for(var i in this.SceneRefs) { if (this.SceneRefs[i].LocalScene === game.active().Target) { this.SceneRefs[i].update(target); } } }
,"TargetEntity":"hero","DelimitedGrid":"0,1,2,3;4,5,6,7;8,9,10,11;12,13,14,15","SceneList":"","WorldWrap":false,"SceneRefs":[{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":0,"Y":416,"W":768,"H":4,"TargetX":0,"TargetY":-8,"SkipXMove":true,"SkipYMove":false,"TargetScene":4,"LocalScene":0,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":656,"Y":0,"W":4,"H":768,"TargetX":-8,"TargetY":0,"SkipXMove":false,"SkipYMove":true,"TargetScene":1,"LocalScene":0,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":0,"Y":416,"W":768,"H":4,"TargetX":0,"TargetY":-8,"SkipXMove":true,"SkipYMove":false,"TargetScene":5,"LocalScene":1,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":-16,"Y":0,"W":4,"H":768,"TargetX":624,"TargetY":0,"SkipXMove":false,"SkipYMove":true,"TargetScene":0,"LocalScene":1,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":656,"Y":0,"W":4,"H":768,"TargetX":-8,"TargetY":0,"SkipXMove":false,"SkipYMove":true,"TargetScene":2,"LocalScene":1,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":0,"Y":416,"W":768,"H":4,"TargetX":0,"TargetY":-8,"SkipXMove":true,"SkipYMove":false,"TargetScene":6,"LocalScene":2,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":-16,"Y":0,"W":4,"H":768,"TargetX":624,"TargetY":0,"SkipXMove":false,"SkipYMove":true,"TargetScene":1,"LocalScene":2,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":656,"Y":0,"W":4,"H":768,"TargetX":-8,"TargetY":0,"SkipXMove":false,"SkipYMove":true,"TargetScene":3,"LocalScene":2,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":0,"Y":416,"W":768,"H":4,"TargetX":0,"TargetY":-8,"SkipXMove":true,"SkipYMove":false,"TargetScene":7,"LocalScene":3,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":-16,"Y":0,"W":4,"H":768,"TargetX":624,"TargetY":0,"SkipXMove":false,"SkipYMove":true,"TargetScene":2,"LocalScene":3,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":0,"Y":-16,"W":768,"H":4,"TargetX":0,"TargetY":384,"SkipXMove":true,"SkipYMove":false,"TargetScene":0,"LocalScene":4,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":0,"Y":416,"W":768,"H":4,"TargetX":0,"TargetY":-8,"SkipXMove":true,"SkipYMove":false,"TargetScene":8,"LocalScene":4,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":656,"Y":0,"W":4,"H":768,"TargetX":-8,"TargetY":0,"SkipXMove":false,"SkipYMove":true,"TargetScene":5,"LocalScene":4,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":0,"Y":-16,"W":768,"H":4,"TargetX":0,"TargetY":384,"SkipXMove":true,"SkipYMove":false,"TargetScene":1,"LocalScene":5,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":0,"Y":416,"W":768,"H":4,"TargetX":0,"TargetY":-8,"SkipXMove":true,"SkipYMove":false,"TargetScene":9,"LocalScene":5,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":-16,"Y":0,"W":4,"H":768,"TargetX":624,"TargetY":0,"SkipXMove":false,"SkipYMove":true,"TargetScene":4,"LocalScene":5,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":656,"Y":0,"W":4,"H":768,"TargetX":-8,"TargetY":0,"SkipXMove":false,"SkipYMove":true,"TargetScene":6,"LocalScene":5,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":0,"Y":-16,"W":768,"H":4,"TargetX":0,"TargetY":384,"SkipXMove":true,"SkipYMove":false,"TargetScene":2,"LocalScene":6,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":0,"Y":416,"W":768,"H":4,"TargetX":0,"TargetY":-8,"SkipXMove":true,"SkipYMove":false,"TargetScene":10,"LocalScene":6,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":-16,"Y":0,"W":4,"H":768,"TargetX":624,"TargetY":0,"SkipXMove":false,"SkipYMove":true,"TargetScene":5,"LocalScene":6,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":656,"Y":0,"W":4,"H":768,"TargetX":-8,"TargetY":0,"SkipXMove":false,"SkipYMove":true,"TargetScene":7,"LocalScene":6,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":0,"Y":-16,"W":768,"H":4,"TargetX":0,"TargetY":384,"SkipXMove":true,"SkipYMove":false,"TargetScene":3,"LocalScene":7,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":0,"Y":416,"W":768,"H":4,"TargetX":0,"TargetY":-8,"SkipXMove":true,"SkipYMove":false,"TargetScene":11,"LocalScene":7,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":-16,"Y":0,"W":4,"H":768,"TargetX":624,"TargetY":0,"SkipXMove":false,"SkipYMove":true,"TargetScene":6,"LocalScene":7,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":0,"Y":-16,"W":768,"H":4,"TargetX":0,"TargetY":384,"SkipXMove":true,"SkipYMove":false,"TargetScene":4,"LocalScene":8,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":0,"Y":416,"W":768,"H":4,"TargetX":0,"TargetY":-8,"SkipXMove":true,"SkipYMove":false,"TargetScene":12,"LocalScene":8,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":656,"Y":0,"W":4,"H":768,"TargetX":-8,"TargetY":0,"SkipXMove":false,"SkipYMove":true,"TargetScene":9,"LocalScene":8,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":0,"Y":-16,"W":768,"H":4,"TargetX":0,"TargetY":384,"SkipXMove":true,"SkipYMove":false,"TargetScene":5,"LocalScene":9,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":0,"Y":416,"W":768,"H":4,"TargetX":0,"TargetY":-8,"SkipXMove":true,"SkipYMove":false,"TargetScene":13,"LocalScene":9,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":-16,"Y":0,"W":4,"H":768,"TargetX":624,"TargetY":0,"SkipXMove":false,"SkipYMove":true,"TargetScene":8,"LocalScene":9,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":656,"Y":0,"W":4,"H":768,"TargetX":-8,"TargetY":0,"SkipXMove":false,"SkipYMove":true,"TargetScene":10,"LocalScene":9,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":0,"Y":-16,"W":768,"H":4,"TargetX":0,"TargetY":384,"SkipXMove":true,"SkipYMove":false,"TargetScene":6,"LocalScene":10,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":0,"Y":416,"W":768,"H":4,"TargetX":0,"TargetY":-8,"SkipXMove":true,"SkipYMove":false,"TargetScene":14,"LocalScene":10,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":-16,"Y":0,"W":4,"H":768,"TargetX":624,"TargetY":0,"SkipXMove":false,"SkipYMove":true,"TargetScene":9,"LocalScene":10,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":656,"Y":0,"W":4,"H":768,"TargetX":-8,"TargetY":0,"SkipXMove":false,"SkipYMove":true,"TargetScene":11,"LocalScene":10,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":0,"Y":-16,"W":768,"H":4,"TargetX":0,"TargetY":384,"SkipXMove":true,"SkipYMove":false,"TargetScene":7,"LocalScene":11,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":0,"Y":416,"W":768,"H":4,"TargetX":0,"TargetY":-8,"SkipXMove":true,"SkipYMove":false,"TargetScene":15,"LocalScene":11,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":-16,"Y":0,"W":4,"H":768,"TargetX":624,"TargetY":0,"SkipXMove":false,"SkipYMove":true,"TargetScene":10,"LocalScene":11,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":0,"Y":-16,"W":768,"H":4,"TargetX":0,"TargetY":384,"SkipXMove":true,"SkipYMove":false,"TargetScene":8,"LocalScene":12,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":656,"Y":0,"W":4,"H":768,"TargetX":-8,"TargetY":0,"SkipXMove":false,"SkipYMove":true,"TargetScene":13,"LocalScene":12,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":0,"Y":-16,"W":768,"H":4,"TargetX":0,"TargetY":384,"SkipXMove":true,"SkipYMove":false,"TargetScene":9,"LocalScene":13,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":-16,"Y":0,"W":4,"H":768,"TargetX":624,"TargetY":0,"SkipXMove":false,"SkipYMove":true,"TargetScene":12,"LocalScene":13,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":656,"Y":0,"W":4,"H":768,"TargetX":-8,"TargetY":0,"SkipXMove":false,"SkipYMove":true,"TargetScene":14,"LocalScene":13,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":0,"Y":-16,"W":768,"H":4,"TargetX":0,"TargetY":384,"SkipXMove":true,"SkipYMove":false,"TargetScene":10,"LocalScene":14,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":-16,"Y":0,"W":4,"H":768,"TargetX":624,"TargetY":0,"SkipXMove":false,"SkipYMove":true,"TargetScene":13,"LocalScene":14,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":656,"Y":0,"W":4,"H":768,"TargetX":-8,"TargetY":0,"SkipXMove":false,"SkipYMove":true,"TargetScene":15,"LocalScene":14,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":0,"Y":-16,"W":768,"H":4,"TargetX":0,"TargetY":384,"SkipXMove":true,"SkipYMove":false,"TargetScene":11,"LocalScene":15,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":-16,"Y":0,"W":4,"H":768,"TargetX":624,"TargetY":0,"SkipXMove":false,"SkipYMove":true,"TargetScene":14,"LocalScene":15,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0}],"Name":"","LocalData":"","TypeName":"SceneGrid","Id":33},{"update":
function(target) { for(var i in this.SceneRefs) { if (this.SceneRefs[i].LocalScene === game.active().Target) { this.SceneRefs[i].update(target); } } }
,"TargetEntity":"hero","DelimitedGrid":"16,17,18;19,20,21","SceneList":"","WorldWrap":false,"SceneRefs":[{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":0,"Y":416,"W":768,"H":4,"TargetX":0,"TargetY":-8,"SkipXMove":true,"SkipYMove":false,"TargetScene":19,"LocalScene":16,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":656,"Y":0,"W":4,"H":768,"TargetX":-8,"TargetY":0,"SkipXMove":false,"SkipYMove":true,"TargetScene":17,"LocalScene":16,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":0,"Y":416,"W":768,"H":4,"TargetX":0,"TargetY":-8,"SkipXMove":true,"SkipYMove":false,"TargetScene":20,"LocalScene":17,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":-16,"Y":0,"W":4,"H":768,"TargetX":624,"TargetY":0,"SkipXMove":false,"SkipYMove":true,"TargetScene":16,"LocalScene":17,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":656,"Y":0,"W":4,"H":768,"TargetX":-8,"TargetY":0,"SkipXMove":false,"SkipYMove":true,"TargetScene":18,"LocalScene":17,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":0,"Y":416,"W":768,"H":4,"TargetX":0,"TargetY":-8,"SkipXMove":true,"SkipYMove":false,"TargetScene":21,"LocalScene":18,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":-16,"Y":0,"W":4,"H":768,"TargetX":624,"TargetY":0,"SkipXMove":false,"SkipYMove":true,"TargetScene":17,"LocalScene":18,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":0,"Y":-16,"W":768,"H":4,"TargetX":0,"TargetY":384,"SkipXMove":true,"SkipYMove":false,"TargetScene":16,"LocalScene":19,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":656,"Y":0,"W":4,"H":768,"TargetX":-8,"TargetY":0,"SkipXMove":false,"SkipYMove":true,"TargetScene":20,"LocalScene":19,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":0,"Y":-16,"W":768,"H":4,"TargetX":0,"TargetY":384,"SkipXMove":true,"SkipYMove":false,"TargetScene":17,"LocalScene":20,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":-16,"Y":0,"W":4,"H":768,"TargetX":624,"TargetY":0,"SkipXMove":false,"SkipYMove":true,"TargetScene":19,"LocalScene":20,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":656,"Y":0,"W":4,"H":768,"TargetX":-8,"TargetY":0,"SkipXMove":false,"SkipYMove":true,"TargetScene":21,"LocalScene":20,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":0,"Y":-16,"W":768,"H":4,"TargetX":0,"TargetY":384,"SkipXMove":true,"SkipYMove":false,"TargetScene":18,"LocalScene":21,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0},{"update":
function(target) { var t = game.findEntity(target); if (t === null) { alert('could not find ' + target); } else if (this.criteria(t) === true) { this.changeScenes(t); } }
,"criteria":
function(ent) { return wouldCollide(ent, this.bounds()); }
,"bounds":
function() { return {X:this.X,Y:this.Y,W:this.W,H:this.H}; }
,"changeScenes":
function(ent) {  game.active().setScene(this.TargetScene); this.moveTarget(ent); /* ent.X and ent.Y should be appropriately changed*/ }
,"moveTarget":
function(ent) { if (this.SkipXMove !== true) { var xMove = 0; if (ent.X > this.TargetX) { xMove = game.scene().shiftToLeft(); } else { xMove = game.scene().shiftToRight(); } ent.X = this.TargetX; this.X += (xMove*4); } if (this.SkipYMove !== true) { var yMove = 0; if (ent.Y > this.TargetY) { yMove = game.scene().shiftToTop(); } else { yMove = game.scene().shiftToBottom(); } ent.Y = this.TargetY; this.Y += yMove; } }
,"X":-16,"Y":0,"W":4,"H":768,"TargetX":624,"TargetY":0,"SkipXMove":false,"SkipYMove":true,"TargetScene":20,"LocalScene":21,"Name":null,"LocalData":null,"TypeName":"SceneRef","Id":0}],"Name":"","LocalData":"","TypeName":"SceneGrid","Id":34}],"SceneCubes":[],"Name":"","LocalData":"","TypeName":"SceneContext","Id":44}],"EventBoard":{"setEventValue":
 function(nameOf,value) {for(var i in this.EventItems) { if (this.EventItems[i].Name == nameOf) { this.EventItems[i].Value = value; return 'success'; } } this.addEvent(nameOf,value);}
,"addEvent":
 function(nameOf,value) {this.EventItems.push({Name:nameOf,Value:value})}
,"getEventValue":
 function(nameOf) {for (var i in this.EventItems) { if (this.EventItems[i].Name == nameOf) { return this.EventItems[i].Value; } } return 'null';}
,"webServiceUrl":
 function(loadVsSave) {var locRef = location.href; var segments = locRef.split('/'); locRef = segments[0] + '//' + segments[2] + '/AccessObject.asmx/' + (loadVsSave ? 'Load' : 'Save') + 'Game'; return locRef;}
,"loadGame":
 function(targetIndex) {var newData = '';function storeData(data) { xData = data.substring(data.indexOf('http://clearwinggames.com/') + 28); xData = xData.replace('</string>',''); alert(xData); newData = xData; integrateData(xData); }var loadObj = {GameSave:{},GameName:game.Name,TargetIndex:targetIndex};$.get(this.webServiceUrl(true),'jsonObject=' + JSON.stringify(loadObj),function(data){ alert(data); storeData(data); },'text');function integrateData(xData) {alert('running ' + xData + 'against eventboard.');var newObj = jQuery.parseJSON(xData);for (var i in newObj.Deliverable.DataItems) {if (game.EventBoard.getEventValue(newObj.Deliverable.DataItems[i].Name) !== 'null') { game.EventBoard.setEventValue(newObj.Deliverable.DataItems[i].Name, newObj.Deliverable.DataItems[i].Value); } else {game.EventBoard.EventItems.push({ Value: newObj.Deliverable.DataItems[i].Value }); }}}}
,"saveGame":
 function(targetIndex) {var saveObj = {DataItems: [], GameName: game.Name, TargetIndex:targetIndex };for(var i in this.EventItems) {saveObj.DataItems.push({ Name:this.EventItems[i].Name, Value: this.EventItems[i].Value });}$.post(this.webServiceUrl(false), 'jsonObject=' + JSON.stringify(saveObj), function(data) { alert(data); }, 'text');}
,"EventItems":[],"Name":"","LocalData":"","TypeName":"EventBoard","Id":44},"DataLibrary":{"updateDashboardTo":
function(nameOf) { let dash = this.getViewByName(nameOf).asDashboard(); game.active().MyDashboard = dash; }
,"getViewByName":
function(nameOf) { for (var i in this.DataViews) { if (this.DataViews[i].Name==nameOf) { return this.DataViews[i]; } } }
,"getModelByName":
 function(name) { for(var i in this.DataModels) {if (this.DataModels[i].Name == name) { return this.DataModels[i]; }}return null;}
,"DataModels":[],"DataViews":[],"Name":"","LocalData":"","TypeName":"DataLibrary","Id":44},"AOPEngine":{"setup":
 function() {for(var i in this.AdviceBlocks) { this.AdviceBlocks[i].setup(); }  console.log('aops');}
,"AdviceBlocks":[],"Name":"","LocalData":"","TypeName":"AOPEngine","Id":44},"Classes":
{Entity: function Entity(){this.MyLogic = new game.Classes.LogicBox();;this.MyImage = new game.Classes.ImageBox();;this.MyColor = null;this.X = 0;this.Y = 0;this.W = 32;this.H = 32;this.MX = null;this.MY = null;this.Disabled = null;this.MyIndex = null;this.Omnipresent = null;this.NotWorldLevel = null;this.NonCorporeal = null;this.ForceCollision = null;this.LedgeCollision = null;this.AnimationCount = null;this.ModelName = null;this.ClassName = null;this.Name = null;this.LocalData = null;this.Id = null;this.setup = function(index) {  this.MyLogic.setup(index);  this.makeOmnipresent(index); } ;this.cycleLogic = function() { if (this.AnimationCount >= this.MyImage.CycleLength) { this.AnimationCount = 0; if (this.MyImage.ImageFrames.length <= this.MyImage.Target + 1) { this.MyImage.Target = 0; } else { this.MyImage.Target++; } } else { this.AnimationCount++; } } ;this.update = function() { if(this.checkOmnipresence()) { this.MyLogic.update(); if (this.MyImage.CycleLength > 0) { this.cycleLogic(); } } } ;this.draw =  function() {if (this.MyImage.ImageFrames.length > 0) { this.MyImage.active().render(this.X, this.Y, this.W, this.H); } else { drawRectangle(this.X, this.Y, this.W, this.H, this.MyColor); }};this.transpose = function(xDisp, yDisp) { return { Me: this, MyLogic: this.MyLogic, name: this.Name, X: this.X + xDisp, Y: this.Y + yDisp, W: this.W, H: this.H  }; };this.checkOmnipresence = function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Entities[this.MyIndex] = {}; return false; } };this.makeOmnipresent = function(index) { return false; /* not omnipresent */ };this.center =  function() {return { x: this.X + (this.W / 2), y: this.Y + (this.H / 2) };};this.R =  function() {return this.X + this.W;};this.B =  function() {return this.Y + this.H;};this.isAdjacent =  function(entity) {return this.X == entity.X + entity.W || this.R() == entity.X || this.Y == entity.Y + entity.H || this.B() == entity.Y;};this.isCentered = function() { var myCenter = this.myCenter(); return myCenter.X===(getXDrawBounds2D() / 2)&&myCenter.Y===(getYDrawBounds2D() / 2); };this.pastCenterX = function() { return (this.myCenterX() > (getXDrawBounds2D()/2)); };this.pastCenterY = function() { return (this.myCenterY() > (getYDrawBounds2D()/2)); };this.isCenteredX = function() { return this.myCenterX()===(getXDrawBounds2D()/2);  };this.isCenteredY = function() { return this.myCenterY()===(getYDrawBounds2D()/2); };this.myCenterX = function() { return this.X + (this.W/2);  };this.myCenterY = function() { return this.Y + (this.H/2); };this.myCenter = function() { return {X:this.X + (this.W/2),Y:this.Y + (this.H/2)};  };this.wouldCollide =  function(entity) {return (entity.X + entity.W > this.X && entity.X < this.R() && entity.Y + entity.H > this.Y && entity.Y < this.B());};this.move = function(xAmt, yAmt) { this.X += xAmt; this.Y += yAmt; };this.isCarrying = function(other) { return this.Y == other.B() && this.R() > other.X && this.X < other.R(); };this.isAtop = function(other) { return this.B() == other.Y && this.R() > other.X && this.X < other.R(); };this.getThoseAtop =  function() { let those = game.scene().allEntities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; };this.moveWithCargo = function(xAmt, yAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt); } this.move(xAmt, yAmt); };this.destroyMe = function() { game.scene().Entities[this.MyIndex] = {}; };this.IsAOPObject = function() { return true; };this.TypeName = Entity;},Threntity: function Threntity(){this.MyIndex = null;this.MX = null;this.MY = null;this.MZ = null;this.prevMY = null;this.W = null;this.H = null;this.D = null;this.TileX = null;this.TileY = null;this.Omnipresent = null;this.AnimationCount = null;this.MyLogic = null;this.MyTexture = null;this.UpTexture = null;this.DownTexture = null;this.EastTexture = null;this.WestTexture = null;this.NorthTexture = null;this.SouthTexture = null;this.MyPrimitives = null;this.X = null;this.Y = null;this.Z = null;this.ModelName = null;this.ClassName = null;this.Name = null;this.LocalData = null;this.Id = null;this.drop =  function() {game.scene().Threntities.splice(this.MyIndex, 1);};this.transpose =  function(xDisp,yDisp,zDisp) {let newThrent = new cwg.Threntity(); newThrent.name = this.Name; newThrent.X = this.X + xDisp; newThrent.Y = this.Y + yDisp; newThrent.Z = this.Z + zDisp; newThrent.H = this.H; newThrent.W = this.W; newThrent.D = this.D; return newThrent;};this.setup =  function(index) {this.MyIndex = index;for (var i in this.MyPrimitives) { this.MyPrimitives[i].setup(this); }setupThrentity(this);this.MyLogic.setup(index);this.makeOmnipresent(index);};this.cycleLogic = function() { if (this.MyTexture.CycleLength > 0) {if (this.AnimationCount >= this.MyTexture.CycleLength) { this.AnimationCount = 0; if (this.MyTexture.ImageFrames.length <= this.MyTexture.Target + 1) { this.setImageTarget(0); } else { this.setImageTarget(this.MyTexture.Target + 1); } } else { this.AnimationCount++; } } for (var i in this.MyPrimitives) { this.MyPrimitives[i].cycleLogic(); } } ;this.setImageTarget = function(target){ this.MyTexture.ImageFrames[this.MyTexture.Target].material = this.myCube().material; this.MyTexture.Target = target; this.myCube().material = this.MyTexture.ImageFrames[this.MyTexture.Target].getMaterial(this); };this.draw =  function() {};this.update =  function() {if (this.isActive && this.checkOmnipresence()) {this.prevMY = this.MY;this.updateCube();for(var i in this.MyLogic.OnUpdate) { this.MyLogic.OnUpdate[i].invoke(); } this.MyLogic.ActionBlock.update();for(var i in this.MyLogic.MyInputs) { this.MyLogic.MyInputs[i].update(); } for(var i in this.MyPrimitives) { this.MyPrimitives[i].update(); } if (this.MyTexture.CycleLength > 0) { this.cycleLogic(); }}};this.checkOmnipresence = function() { if (this.Omnipresent !== true) { return true; } else { this.Omnipresent = false; game.active().active().Threntities[this.MyIndex] = {}; return false; } };this.makeOmnipresent = function(index) { return false; /* not omnipresent */ };this.myCube =  function() {return this.cube;};this.cube = {};this.updateCubeMaterial = function() { };this.updateCube =  function() {this.myCube().position.x = this.X; this.myCube().position.y = this.Y; this.myCube().position.z = this.Z;};this.doesBorder =  function(threntity) {var wouldNot = !this.wouldCollide(threntity); var would = (threntity.wouldCollide(this.transpose(1,0,0)) || threntity.wouldCollide(this.transpose(-1,0,0)) || threntity.wouldCollide(this.transpose(0,0,1)) || threntity.wouldCollide(this.transpose(0,0,-1)) || threntity.wouldCollide(this.transpose(0,1,0)) || threntity.wouldCollide(this.transpose(0,-1,0))); return wouldNot && would;};this.collideZX =  function(threntity) {return this.collideZ(threntity) && this.collideX(threntity);};this.collideX =  function(threntity) {return (this.X + (this.W/2) > threntity.X - (threntity.W/2) && this.X - (this.W/2) < threntity.X + (threntity.W/2));};this.collideY =  function(threntity) {return (this.Y - (this.H / 2) < threntity.Y + (threntity.H / 2) && this.Y + (this.H / 2) > threntity.Y - (threntity.H / 2));};this.collideZ =  function(threntity) {return (this.Z + (this.D / 2) > threntity.Z - (threntity.D / 2) && this.Z - (this.D / 2) < threntity.Z + (threntity.D / 2));};this.wouldCollide =  function(threntity) {return this.collideX(threntity) && this.collideY(threntity) && this.collideZ(threntity);};this.move = function(xAmt, yAmt, zAmt) { this.X += xAmt; this.Y += yAmt; this.Z += zAmt; };this.isCarrying = function(other) { return this.deviationOfOne(this.T(), other.B()) && this.R() > other.X && this.X < other.R() && this.F() > other.Z && this.Z < other.F(); };this.isAtop = function(other) { return this.deviationOfOne(this.B(), other.T()) && this.R() > other.X && this.X < other.R() && this.F() > other.Z && this.Z < other.F(); };this.deviationOfOne = function(fVal, sVal) { if ((fVal - sVal <= 1 && fVal - sVal >= -1) || (sVal - fVal <= 1 && sVal - fVal >= -1)) return true; else { return false; } };this.getThoseAtop =  function() { let those = game.scene().allThrentities(); let found = []; for(var i in those) { if (this.isCarrying(those[i])==true) { found.push(those[i]); } } return found; };this.moveWithCargo = function(xAmt, yAmt, zAmt) { let found = this.getThoseAtop(); for(var i in found) { found[i].move(xAmt, yAmt, zAmt); } this.move(xAmt, yAmt, zAmt); };this.destroyMe = function() { game.scene().Threntities[this.MyIndex] = {}; };this.jump =  function(thrust) {if (this.notFalling()) { this.MY = thrust; }};this.notFalling =  function() {return this.MY == 0 && this.prevMY == 0;};this.L =  function() {return this.X - (this.W / parseFloat(2));};this.R =  function() {return this.X + (this.W / parseFloat(2));};this.T =  function() {return this.Y + (this.H / parseFloat(2));};this.B = function() { return this.Y - (this.H / parseFloat(2)); };this.A = function() { return this.Z - (this.D / parseFloat(2)); };this.F =  function() {return this.Z + (this.D / parseFloat(2));};this.isActive = true;this.IsAOPObject = function() { return true; };this.TypeName = Threntity;},ImageBox: function ImageBox(){this.Target = null;this.CycleLength = null;this.ImageFrames = [];this.Name = null;this.LocalData = null;this.Id = null;this.active =  function() {return this.ImageFrames[this.Target];};this.TypeName = ImageBox;},LogicBox: function LogicBox(){this.OnUpdate = [];this.MyInputs = [];this.ActionBlock = {setup:function() { },update:function() { }};this.Name = null;this.LocalData = null;this.Id = null;this.setup = function(index) { for(var i in this.OnUpdate) { this.OnUpdate[i].setup(index); } this.ActionBlock.setup(index);for(var i in this.MyInputs) { this.MyInputs[i].setup(index); }  };this.update =  function() {for(var i in this.MyInputs) { this.MyInputs[i].update(); } this.ActionBlock.update();for(var i in this.OnUpdate) { this.OnUpdate[i].invoke(); } };this.TypeName = LogicBox;},Dashboard: function Dashboard(){this.MyLabels = null;this.MyBars = null;this.Name = null;this.LocalData = null;this.Id = null;this.draw =  function() {for(var i in this.MyLabels) { this.MyLabels[i].render(); } for(var i in this.MyBars) { this.MyBars[i].render(); } };this.initialize = function() { for(var i in this.MyLabels) { this.MyLabels[i].ParentDash = this; }for(var i in this.MyBars) { this.MyBars[i].ParentDash = this; }};this.TypeName = Dashboard;},DashLabel: function DashLabel(){this.Caption = null;this.FontSize = null;this.X = null;this.Y = null;this.MyColor = null;this.DataModelName = null;this.SubmitTarget = null;this.ModelName = null;this.ClassName = null;this.Name = null;this.LocalData = null;this.Id = null;this.getCaption =  function() { return this.processText(this.Caption);} ;this.setCaption =  function(newCaption) {this.Caption = newCaption;};this.render =  function() {drawString(this.X, this.Y, this.getCaption(), this.MyColor, this.FontSize);};this.executeMethod =  function(name) {let dataModel = this.getDataModel();if (!dataModel || dataModel == null) { return; }let entry = dataModel.getEntry(name);entry.executeMethod(this);};this.processText =  function(text) { let dataModel = this.getDataModel();if (!dataModel || dataModel == null) { return text; }return dataModel.processText(text);} ;this.submit =  function() {this.executeMethod(this.SubmitTarget);};this.getDataModel =  function() {if (Object.keys(this.MyDataModel).length === 0 && this.MyDataModel.constructor === Object) { /* do nothing */ } else { return this.MyDataModel; }if (this.DataModelName != null && this.DataModelName.length > 0) {this.MyDataModel = game.DataLibrary.getModelByName(this.DataModelName);return this.MyDataModel;}else { return null; }};this.MyDataModel = {};this.ParentDash = {};this.IsAOPObject = function() { return true; };this.TypeName = DashLabel;},DashBar: function DashBar(){this.H = null;this.MaxWidth = null;this.MaxValue = null;this.Value = null;this.X = null;this.Y = null;this.MyColor = null;this.DataModelName = null;this.SubmitTarget = null;this.ModelName = null;this.ClassName = null;this.Name = null;this.LocalData = null;this.Id = null;this.calculateWidth =  function() {return this.MaxWidth * (this.Value / this.MaxValue);};this.render =  function() {drawRectangle(this.X, this.Y, this.calculateWidth(), this.H, this.MyColor);};this.executeMethod =  function(name) {let dataModel = this.getDataModel();if (!dataModel || dataModel == null) { return; }let entry = dataModel.getEntry(name);entry.executeMethod(this);};this.processText =  function(text) { let dataModel = this.getDataModel();if (!dataModel || dataModel == null) { return text; }return dataModel.processText(text);} ;this.submit =  function() {this.executeMethod(this.SubmitTarget);};this.getDataModel =  function() {if (Object.keys(this.MyDataModel).length === 0 && this.MyDataModel.constructor === Object) { /* do nothing */ } else { return this.MyDataModel; }if (this.DataModelName != null && this.DataModelName.length > 0) {this.MyDataModel = game.DataLibrary.getModelByName(this.DataModelName);return this.MyDataModel;}else { return null; }};this.MyDataModel = {};this.ParentDash = {};this.IsAOPObject = function() { return true; };this.TypeName = DashBar;},}
,"Name":"ivanGreatForest205","LocalData":"","TypeName":"Game","Id":48};
</script><img id="grass32" src="grass32.png" style="display: none;" /><img id="stone32" src="stone32.png" style="display: none;" /><img id="water1" src="water1.png" style="display: none;" /><img id="water2" src="water2.png" style="display: none;" /><img id="water3" src="water3.png" style="display: none;" /><img id="water4" src="water4.png" style="display: none;" /><img id="water5" src="water5.png" style="display: none;" /><img id="water6" src="water6.png" style="display: none;" /><img id="water7" src="water7.png" style="display: none;" /><img id="water8" src="water8.png" style="display: none;" /><img id="water9" src="water9.png" style="display: none;" /><img id="water10" src="water10.png" style="display: none;" /><img id="water11" src="water11.png" style="display: none;" /><img id="water12" src="water12.png" style="display: none;" /><img id="water13" src="water13.png" style="display: none;" /><img id="water14" src="water14.png" style="display: none;" /><img id="water15" src="water15.png" style="display: none;" /><img id="stoneWall32" src="stoneWall32.png" style="display: none;" /><img id="dirt32" src="dirt32.png" style="display: none;" /><img id="ivanGreatForest205tile60" src="ivanGreatForest205_cc_tile60.png" style="display: none;" /><img id="ivanGreatForest205tile60" src="ivanGreatForest205_cc_tile60.png" style="display: none;" /><img id="ivanGreatForest205testStairsDown0" src="ivanGreatForest205_cc_testStairsDown0.png" style="display: none;" /><img id="grass32" src="grass32.png" style="display: none;" /><img id="stone32" src="stone32.png" style="display: none;" /><img id="water1" src="water1.png" style="display: none;" /><img id="water2" src="water2.png" style="display: none;" /><img id="water3" src="water3.png" style="display: none;" /><img id="water4" src="water4.png" style="display: none;" /><img id="water5" src="water5.png" style="display: none;" /><img id="water6" src="water6.png" style="display: none;" /><img id="water7" src="water7.png" style="display: none;" /><img id="water8" src="water8.png" style="display: none;" /><img id="water9" src="water9.png" style="display: none;" /><img id="water10" src="water10.png" style="display: none;" /><img id="water11" src="water11.png" style="display: none;" /><img id="water12" src="water12.png" style="display: none;" /><img id="water13" src="water13.png" style="display: none;" /><img id="water14" src="water14.png" style="display: none;" /><img id="water15" src="water15.png" style="display: none;" /><img id="stoneWall32" src="stoneWall32.png" style="display: none;" /><img id="water1" src="water1.png" style="display: none;" /><img id="water2" src="water2.png" style="display: none;" /><img id="water3" src="water3.png" style="display: none;" /><img id="water4" src="water4.png" style="display: none;" /><img id="water5" src="water5.png" style="display: none;" /><img id="water6" src="water6.png" style="display: none;" /><img id="water7" src="water7.png" style="display: none;" /><img id="water8" src="water8.png" style="display: none;" /><img id="water9" src="water9.png" style="display: none;" /><img id="water10" src="water10.png" style="display: none;" /><img id="water11" src="water11.png" style="display: none;" /><img id="water12" src="water12.png" style="display: none;" /><img id="water13" src="water13.png" style="display: none;" /><img id="water14" src="water14.png" style="display: none;" /><img id="water15" src="water15.png" style="display: none;" /><img id="ivanGreatForest205tile60" src="ivanGreatForest205_cc_tile60.png" style="display: none;" /><img id="ivanGreatForest205tile60" src="ivanGreatForest205_cc_tile60.png" style="display: none;" /><img id="ivanGreatForest205tile60" src="ivanGreatForest205_cc_tile60.png" style="display: none;" /><img id="ivanGreatForest205testStairs0" src="ivanGreatForest205_cc_testStairs0.png" style="display: none;" /><img id="ivanGreatForest205tile60" src="ivanGreatForest205_cc_tile60.png" style="display: none;" /><img id="ivanGreatForest205tile60" src="ivanGreatForest205_cc_tile60.png" style="display: none;" /><img id="ivanGreatForest205tile60" src="ivanGreatForest205_cc_tile60.png" style="display: none;" /><script>function getCanvas()
 {
var canvas = document.getElementById('gameCanvas');
return canvas.getContext('2d');
}
function toggleFullScreen() {
var canv = document.getElementById('gameCanvas');
if (canv.webkitRequestFullscreen) {
canv.webkitRequestFullscreen();
}
else {
canv.mozRequestFullScreen();
}
reallignCanvases();
}
var reallignCanvases = function() {
var rect = document.getElementById('canvasDiv').getBoundingClientRect();
$('#threeCanvas').css({'left':rect.left-10,'top':rect.top-10,'width':rect.width+10,'height':rect.height+10});
$('#gameCanvas').css({'left':rect.left-10,'top':rect.top-10,'width':rect.width+10,'height':rect.height+10,'position':'absolute'});
}
function cAlert(msg) {
game.fadingMessage(msg, 90);
}
function cAlert(msg,dur) {
game.fadingMessage(msg,dur);
}
function pAlert(msg) {
}
function drawStringWithFont(x, y, msg, colorString, fontData)
 {
getCanvas().font=fontData;
 getCanvas().fillStyle = colorString;
 getCanvas().fillText(msg, x, y);
}
function drawString(x, y, msg, colorString)
 {
getCanvas().font='16px Georgia';
 getCanvas().fillStyle = colorString;
 getCanvas().fillText(msg, x, y);
}
function drawString(x, y, msg, colorString, fontSize) {
getCanvas().font = fontSize + 'px Georgia';
getCanvas().fillStyle = colorString;
getCanvas().fillText(msg, x, y);
}
function drawRectangle(x, y, w, h, color)
 {
getCanvas().fillStyle = color;
getCanvas().fillRect(x,y,w,h);
}
function drawImage(x, y, idOf) {
var imgObj = document.getElementById(idOf);
if (imgObj) {
getCanvas().drawImage(imgObj, x, y);
}
}
function drawImage(x, y, w, h, idOf) {
var imgObj = document.getElementById(idOf);
if (imgObj) {
getCanvas().drawImage(imgObj, x, y, w, h);
} else { alert('imgObj not ready or not found.'); }
}
var context = new (window.AudioContext || window.webkitAudioContext)();
function playNote(note,dur,inst) {
if (note > 0) {
var osc = context.createOscillator(); // instantiate an oscillator
osc.type = inst; // 'sine' is the default - also square, sawtooth, triangle
osc.frequency.value = note; // Hz
osc.connect(context.destination); // connect it to the destination
osc.start(); // start the oscillator
osc.stop(context.currentTime + dur);
}
}
function rgb(r, g, b) {
return 'rgb(' + r.toString() + ',' + g.toString() + ',' + b.toString() + ')';}
var scene = new THREE.Scene();
var threejsClearColor = 0x000000;
var camera = new THREE.PerspectiveCamera( 75, (4/3), 0.25, 18000 );
var renderer = new THREE.WebGLRenderer({ canvas: threeCanvas, alpha: false, autoclear: true });
renderer.setClearColor(threejsClearColor);
function updateClearColor(newColor) { renderer.setClearColor(newColor); }
function addAmbientLightToCurrentScene(color, intensity) { scene.add(new THREE.AmbientLight(color, intensity)); }
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
camera.position.y = 120;
camera.position.z = 300;
setupContent(scene);
var renderThree = function () {
requestAnimationFrame( renderThree );
renderer.render(scene, camera);
};
renderThree();
function setupContent(scene) {
var geometries = [];
for (var j in geometries) {
for ( var i = 0; i < geometries[j].faces.length; i += 2 ) {
var hex = [0xff0000,0x00ff00,0x0000ff,0xff00ff,0x00ffff,0xffff00,0xff7f00,0x7f00ff,0x7fff00,0x007fff][i];
geometries[j].faces[ i ].color.setHex( hex );
geometries[j].faces[ i + 1 ].color.setHex( hex );
}
var material = new THREE.MeshLambertMaterial({
vertexColors: THREE.FaceColors,
overdraw: 0.5 });var cube = new THREE.Mesh( geometries[j], material );
if (j > 0) { cube.position.z -= (200 * j); }
scene.add(cube);
}
}
function setupPointLight(pointLight) {
let newLight = new THREE.PointLight(pointLight.LightColor, pointLight.Intensity / parseFloat(100), pointLight.Distance, pointLight.Decay / parseFloat(100));
newLight.castShadow = true;
newLight.position.set(pointLight.X, pointLight.Y, pointLight.Z);
scene.add(newLight);
}
function setupThrentity(threntity) {
var geometry = new THREE.BoxGeometry(threntity.W, threntity.H, threntity.D);
if (threntity.MyTexture.ImageFrames.length > 0 && threntity.MyTexture.active().hasImagePath()) {
for(var i = 0; i < 1; i++) {
 if (threntity.MyTexture.ImageFrames[i].hasImagePath()){
var texture = new THREE.TextureLoader().load( threntity.MyTexture.ImageFrames[i].imageFilePath );
if (threntity.TileX > 0 && threntity.TileY > 0) { texture.wrapS = THREE.RepeatWrapping;
texture.wrapT = THREE.RepeatWrapping;
texture.repeat.set( threntity.TileX, threntity.TileY );
}
else if (threntity.TileX > 0) { texture.wrapS = THREE.RepeatWrapping;
texture.repeat.set( threntity.TileX, 1 );
}
else if (threntity.TileY > 0) { texture.wrapT = THREE.RepeatWrapping;
texture.repeat.set(1, threntity.TileY );
}
}
}
}
for ( var i = 0; i < geometry.faces.length; i += 2 ) {
var hex = [0xff0000,0x00ff00,0x0000ff,0xff00ff,0x00ffff,0xffff00,0xff7f00,0x7f00ff,0x7fff00,0x007fff][i];
geometry.faces[ i ].color.setHex( hex );
geometry.faces[ i + 1 ].color.setHex( hex );
}
var material;
if (threntity.MyTexture.ImageFrames.length == 0 || !threntity.MyTexture.active().hasImagePath()) {
material = new THREE.MeshLambertMaterial({
vertexColors: THREE.FaceColors,
overdraw: 0.5 });
}
 else {
material = new THREE.MeshLambertMaterial({
map: texture,overdraw: 0.5 });
}
var lCube = new THREE.Mesh( geometry, material );
lCube.position.x = threntity.X;
lCube.position.y = threntity.Y;
lCube.position.z = threntity.Z;
threntity.cube = lCube;
scene.add(threntity.myCube());
}
function setupPrimitiveAs(prim) {
var geom = new THREE.Geometry();
geom.vertices.push(new THREE.Vector3(prim.fX, prim.fY, prim.fZ));
geom.vertices.push(new THREE.Vector3(prim.sX, prim.sY, prim.sZ));
geom.vertices.push(new THREE.Vector3(prim.tX, prim.tY, prim.tZ));
geom.faces.push( new THREE.Face3( 0, 1, 2 ) );
if (prim.IsQuad === true) {
geom.faceVertexUvs[0][0] = [new THREE.Vector2(1, 1),new THREE.Vector2(1, 0),new THREE.Vector2(0, 0)]; 
 }
else {
geom.faceVertexUvs[0][0] = [new THREE.Vector2(1, 1),new THREE.Vector2(0, 1),new THREE.Vector2(0, 0)]; 
 }
if (prim.PrimitiveImages !== null && prim.PrimitiveImages.ImageFrames !== null && prim.PrimitiveImages.ImageFrames.length > 0 && prim.PrimitiveImages.active().hasImagePath()) {
var texture = new THREE.TextureLoader().load( prim.PrimitiveImages.active().imageFilePath );
material = new THREE.MeshLambertMaterial({
map: texture,side: THREE.DoubleSide,overdraw: 0.5 });
var mesh= new THREE.Mesh(geom, material);
scene.add(mesh);
return mesh;
}
else {
setupPrimitive(prim.fX, prim.fY, prim.fZ, prim.sX, prim.sY, prim.sZ, prim.tX, prim.tY, prim.tZ, prim.MyColor);
}
}
function setupPrimitive(fx, fy, fz, sx, sy, sz, tx, ty, tz, pColor) {
if (pColor === null || pColor.length === 0) { pColor = '#007'; }
var geom = new THREE.Geometry();
geom.vertices.push(new THREE.Vector3(fx, fy, fz));
geom.vertices.push(new THREE.Vector3(sx, sy, sz));
geom.vertices.push(new THREE.Vector3(tx, ty, tz));
geom.faces.push( new THREE.Face3( 0, 1, 2 ) );
geom.computeFaceNormals();
var normalMaterial = new THREE.MeshLambertMaterial({color: pColor, side: THREE.DoubleSide});
var mesh= new THREE.Mesh( geom, normalMaterial);
scene.add(mesh);
return mesh;
}
function getVectorDifference(v1, v2) {return {X:v1.X-v2.X,Y:v1.Y-v2.Y,Z:v1.Z-v2.Z};}
function combineVectors(v1, v2) {return {X:v1.X+v2.X,Y:v1.Y+v2.Y,Z:v1.Z+v2.Z};}
function getCameraVector() {
var vector = new THREE.Vector3(0,0,-1);
vector.applyQuaternion(camera.quaternion);
return vector;
}
function getThrentityVector(thrent) {
var vector = new THREE.Vector3(0,0,-1);
vector.applyQuaternion(thrent.quaternion);
return vector;
}
function moveCameraForward(amt) {
var targetVector = getCameraVector();
var xAmt = targetVector.x * (amt);
var yAmt = targetVector.y * (amt);
var zAmt = targetVector.z * (amt);
camera.position.x += xAmt;
camera.position.y += yAmt;
camera.position.z += zAmt;
}
function moveCameraForwardUnless(amt) {
var targetVector = getCameraVector();
var xAmt = targetVector.x * (amt);
var yAmt = targetVector.y * (amt);
var zAmt = targetVector.z * (amt);
var before = new cwg.Threntity();
before.X = camera.position.x; before.Y = camera.position.y; before.Z = camera.position.z;
 var after = before.transpose(xAmt, yAmt, zAmt);
if (game.scene().checkMovePoint3d(before, after)==true) {camera.position.x += xAmt;
camera.position.y += yAmt;
camera.position.z += zAmt;
} else {  } }
function moveThrentityForward(thrent, amt) {
var targetVector = getThrentityVector(thrent.myCube());
var xAmt = targetVector.x * (amt);
var yAmt = targetVector.y * (amt);
var zAmt = targetVector.z * (amt);
thrent.X += xAmt;
thrent.Y += yAmt;
thrent.Z += zAmt;
}
function runMainSetup() {
 cwg = game.Classes;
mainSetup();
}
function mainSetup() {
reallignCanvases();
game.setup();
}
</script><script>startGame();</script></body></html>